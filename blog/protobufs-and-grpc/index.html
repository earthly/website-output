<!doctype html>
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">
<link rel="icon" type="image/png" href="/blog/assets/images/favicon.png">
<!-- begin _includes/seo.html -->





<title>Using gRPC with Golang, Python, and Ruby - Earthly Blog</title>
<meta name="description" content="I was surprised to learn that Google protocol buffers (protobufs), were first introduced nearly two decades ago. They were used internally at google as early as 2001 and were open sourced 2008.   Following this success, in 2016 Google released gRPC.   gRPC offered a way to define remote procedure calls using protobufs for serialization. Due to protobuf’s binary serialization format, it offered a significant speed up compared to using JSON over HTTP. The use of proto files for a precise definition of a service’s API. This was a big innovation.     gRPC is a great solution for communicating between internal microservices. There’s plenty of articles and documentation that covers protobufs and gRPC, but when I am considering a new technology, I learn best by seeing a working example.  In this blog post I’m going build an example using Go, Python and Ruby.   First Step: Implementing a gRPC Client using Go   Let’s write an in-memory key/value micro-service in Go, and some clients in both Python and Ruby.   Our server will allow users to set and get data from a key/value store.      Interacting with the server     First let’s design our API in a proto file:       syntax = &quot;proto3&quot;;     package simplekeyvalue;     option go_package = &quot;kvapi&quot;;          // The key/value API contains two procedures for storing and retrieving data     service KeyValue {       rpc Set (SetRequest) returns (SetReply) {}       rpc Get (GetRequest) returns (GetReply) {}     }          // SetRequest contains a key and value to set     message SetRequest {       string key = 1;       string value = 2;     }          // SetReply contains nothing     message SetReply {     }          // GetRequest contains a key and value to set     message GetRequest {       string key = 1;     }          // GetReply contains the value     message GetReply {       string value = 1;     }   Next we need to compile this proto file into Go code. On a Mac one might be tempted to run brew install protobuf, or if you’re on Linux you might want to see if apt-get install protoc will magically work, but rather than do that, we will use earthly to containerize these tools. This will allow you to share this code with other developers, and ensure everyone can compile proto files across multiple platforms using the same version to eliminate compatibility issues.   Here’s what an Earthfile would look like for installing Google protobufs inside an Ubuntu image, and generating the protobuf code using the protoc-gen-go-grpc tool:       FROM ubuntu:20.10     WORKDIR /defs          RUN apt-get update &amp;&amp; apt-get install -y wget unzip          # setup protoc     RUN wget -O protoc.zip https://github.com/protocolbuffers/protobuf/releases/download/v3.13.0/protoc-3.13.0-linux-x86_64.zip     RUN unzip protoc.zip -d /usr/local/          proto-go:       RUN apt-get install -y golang git       ENV GO111MODULE=on       ENV PATH=$PATH:/root/go/bin       RUN go get google.golang.org/protobuf/cmd/protoc-gen-go \           google.golang.org/grpc/cmd/protoc-gen-go-grpc       COPY api.proto /defs       RUN mkdir /defs/go-api       RUN protoc --proto_path=/defs --go_out=/defs/go-api \           --go-grpc_out=/defs/go-api /defs/api.proto       SAVE ARTIFACT ./go-api /go-pb AS LOCAL go-pb   This will then produce two go files under the go-pb directory: api.pb.go and api_grpc.pb.go which contains the auto generated protobuf and grpc code respectively.   At this point, assuming that earth is already installed, give it a try for yourself with code from our example repository:      git clone https://github.com/earthly/example-grpc-key-value-store.git     cd example-grpc-key-value-store/proto     earth +proto-go  The next step is to write the server code that will implement the set and get methods:       package main          import (      &quot;context&quot;      &quot;fmt&quot;      &quot;log&quot;      &quot;net&quot;           pb &quot;github.com/earthly/example-grpc-key-value-store/go-server/kvapi&quot;           &quot;google.golang.org/grpc&quot;     )          const (      port = &quot;:50051&quot;     )          var errKeyNotFound = fmt.Errorf(&quot;key not found&quot;)          // server is used to implement kvapi.KeyValueServer     type server struct {      pb.UnimplementedKeyValueServer      data map[string]string     }          // Set stores a given value under a given key     func (s *server) Set(ctx context.Context, in *pb.SetRequest) (*pb.SetReply, error) {      key := in.GetKey()      value := in.GetValue()      log.Printf(&quot;serving set request for key %q and value %q&quot;, key, value)           s.data[key] = value           reply := &amp;pb.SetReply{}      return reply, nil     }          // Get returns a value associated with a key to the client     func (s *server) Get(ctx context.Context, in *pb.GetRequest) (*pb.GetReply, error) {      key := in.GetKey()      log.Printf(&quot;serving get request for key %q&quot;, key)           value, ok := s.data[key]      if !ok {       return nil, errKeyNotFound      }           reply := &amp;pb.GetReply{       Value: value,      }      return reply, nil     }          func main() {      lis, err := net.Listen(&quot;tcp&quot;, port)      if err != nil {       log.Fatalf(&quot;failed to listen: %v&quot;, err)      }      log.Printf(&quot;Listening on %s&quot;, port)      serverInstance := server{       data: make(map[string]string),      }      s := grpc.NewServer()      pb.RegisterKeyValueServer(s, &amp;serverInstance)      if err := s.Serve(lis); err != nil {       log.Fatalf(&quot;failed to serve: %v&quot;, err)      }     }   Next we will compile the go code and save it as a docker image with the following Earthfile:       FROM golang:1.13-alpine3.11          WORKDIR /kvserver          kvserver:         COPY go.mod go.sum ./         RUN go mod download         COPY ../proto+proto-go/go-pb kvapi         COPY --dir cmd ./         RUN go build -o kvserver cmd/server/main.go         SAVE ARTIFACT kvserver          kvserver-docker:         FROM alpine:latest         COPY +kvserver/kvserver /kvserver         ENTRYPOINT /kvserver         SAVE IMAGE as kvserver:latest   You can give it a try on your own by using our example code in our GitHub repository, just run:       git clone https://github.com/earthly/example-grpc-key-value-store.git     cd example-grpc-key-value-store/go-server     earth +kvserver-docker   Then start up the server in Docker, by running:       docker run --rm --network=host kvserver:latest    Next step: Implementing a gRPC Client Using Python   Now that we’ve built and launched our Go-based key-value-store server, we’ll cover how to talk to it using a Python client. Remember that initial Earthfile that generated the Go code? We’ll extend it to pip install grpc tooling, and generate Python code:       proto-py:       RUN apt-get install -y python3 python3-pip       RUN pip3 install grpcio grpcio-tools       COPY api.proto /defs       RUN mkdir /defs/py-api       RUN python3 -m grpc_tools.protoc -I /defs --python_out=/defs/py-api \           --grpc_python_out=/defs/py-api /defs/api.proto       SAVE ARTIFACT ./py-api /py-pb AS LOCAL py-pb   Then we’ll create a client that reads command line arguments, and if the argument contains an equals sign, it will store the value in the server, and otherwise it will retrieve the value from the server:       import sys     import grpc          import api_pb2     import api_pb2_grpc          addr = &#39;127.0.0.1:50051&#39;          if len(sys.argv) &lt; 2:         print(&#39;program requires arguments in the form key, or key=value&#39;)         sys.exit(1)          channel = grpc.insecure_channel(addr)     stub = api_pb2_grpc.KeyValueStub(channel)          for arg in sys.argv[1:]:         if &#39;=&#39; in arg:             # send a value to the server             key, value = arg.split(&#39;=&#39;)             try:                 set_request = api_pb2.SetRequest(key=key, value=value)                 set_response = stub.Set(set_request)             except grpc.RpcError as e:                 print(f&#39;failed to send key to server: {e.details}&#39;)             else:                 print(f&#39;sent &quot;{key}&quot; to server&#39;)         else:             # get a value from the server             key = arg             try:                 get_request = api_pb2.GetRequest(key=key)                 get_response = stub.Get(get_request)             except grpc.RpcError as e:                 print(f&#39;failed to get key from server: {e.details}&#39;)             else:                 value = get_response.value                 print(f&#39;server returned value &quot;{value}&quot; for key &quot;{key}&quot;&#39;)   We then store this python code, along with the generated gRPC protobuf code with the following Earthfile:       FROM python:3          RUN pip install grpcio protobuf pycodestyle          WORKDIR /kvclient          code:         COPY client.py .         COPY ../proto+proto-go/go-pb kvapi          lint:         FROM +code         RUN pycodestyle client.py          kvclient-docker:         FROM +code         SAVE IMAGE as python-kvclient:latest          all:         BUILD +lint         BUILD +kvclient-docker   You can give it a try for yourself with the example code:       git clone https://github.com/earthly/example-grpc-key-value-store.git     cd example-grpc-key-value-store/python-client     earth +kvclient-docker   Then you can run it and set the weather to sunny with:      docker run --rm --network=host python-kvclient:latest python3 /kvclient/client.py weather=sunny  And if all went well, you should see some output on both the client and server consoles:      # client output     sent &quot;weather&quot; to server          # server output     2020/11/12 23:15:18 Listening on :50051     2020/11/12 23:15:34 serving set request for key &quot;weather&quot; and value &quot;sunny&quot;   Final Step: Implementing a gRPC Client Using Ruby   We’ve come a long ways with our Go and Python gRPC examples, but what if you also wanted to include a Ruby gRPC client implementation too? Well let’s extend our proto Earthfile to generate Ruby protobufs too:       proto-rb:       RUN apt-get install -y ruby       RUN gem install grpc grpc-tools       COPY api.proto /defs       RUN mkdir /defs/rb-api       RUN grpc_tools_ruby_protoc -I /defs --ruby_out=/defs/rb-api --grpc_out=/defs/rb-api /defs/api.proto       SAVE ARTIFACT ./rb-api /rb-pb AS LOCAL rb-pb   We can then use this generated Ruby gRPC code with a simple ruby client example that performs a get request for keys listed as command line arguments:       $LOAD_PATH.unshift &#39;.&#39;          require &#39;grpc&#39;     require &#39;api_pb&#39;     require &#39;api_services_pb&#39;           stub = Simplekeyvalue::KeyValue::Stub.new(       &#39;127.0.0.1:50051&#39;, :this_channel_is_insecure     )           ARGV.map do |arg|       request = Simplekeyvalue::GetRequest.new(key: arg)       response = stub.get(request)       puts response.value     end      git clone https://github.com/earthly/example-grpc-key-value-store.git     cd example-grpc-key-value-store/ruby-client     earth +kvclient-docker  Then you can try querying the server to see what the weather was set to:      docker run --rm --network=host ruby-kvclient:latest ruby /kvclient/client.rb weather And if all went well, it’ll tell you that it’s sunny outside.     It’s Sunny Outside     So there we go.  You can find the code for the server and the two clients in GitHub.">


  <meta name="author" content="Alex Couture-Beil">
  
  <meta property="article:author" content="Alex Couture-Beil">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Earthly Blog">
<meta property="og:title" content="Using gRPC with Golang, Python, and Ruby">
<meta property="og:url" content="https://earthly.dev/blog/protobufs-and-grpc/">


  <meta property="og:description" content="I was surprised to learn that Google protocol buffers (protobufs), were first introduced nearly two decades ago. They were used internally at google as early as 2001 and were open sourced 2008.   Following this success, in 2016 Google released gRPC.   gRPC offered a way to define remote procedure calls using protobufs for serialization. Due to protobuf’s binary serialization format, it offered a significant speed up compared to using JSON over HTTP. The use of proto files for a precise definition of a service’s API. This was a big innovation.     gRPC is a great solution for communicating between internal microservices. There’s plenty of articles and documentation that covers protobufs and gRPC, but when I am considering a new technology, I learn best by seeing a working example.  In this blog post I’m going build an example using Go, Python and Ruby.   First Step: Implementing a gRPC Client using Go   Let’s write an in-memory key/value micro-service in Go, and some clients in both Python and Ruby.   Our server will allow users to set and get data from a key/value store.      Interacting with the server     First let’s design our API in a proto file:       syntax = &quot;proto3&quot;;     package simplekeyvalue;     option go_package = &quot;kvapi&quot;;          // The key/value API contains two procedures for storing and retrieving data     service KeyValue {       rpc Set (SetRequest) returns (SetReply) {}       rpc Get (GetRequest) returns (GetReply) {}     }          // SetRequest contains a key and value to set     message SetRequest {       string key = 1;       string value = 2;     }          // SetReply contains nothing     message SetReply {     }          // GetRequest contains a key and value to set     message GetRequest {       string key = 1;     }          // GetReply contains the value     message GetReply {       string value = 1;     }   Next we need to compile this proto file into Go code. On a Mac one might be tempted to run brew install protobuf, or if you’re on Linux you might want to see if apt-get install protoc will magically work, but rather than do that, we will use earthly to containerize these tools. This will allow you to share this code with other developers, and ensure everyone can compile proto files across multiple platforms using the same version to eliminate compatibility issues.   Here’s what an Earthfile would look like for installing Google protobufs inside an Ubuntu image, and generating the protobuf code using the protoc-gen-go-grpc tool:       FROM ubuntu:20.10     WORKDIR /defs          RUN apt-get update &amp;&amp; apt-get install -y wget unzip          # setup protoc     RUN wget -O protoc.zip https://github.com/protocolbuffers/protobuf/releases/download/v3.13.0/protoc-3.13.0-linux-x86_64.zip     RUN unzip protoc.zip -d /usr/local/          proto-go:       RUN apt-get install -y golang git       ENV GO111MODULE=on       ENV PATH=$PATH:/root/go/bin       RUN go get google.golang.org/protobuf/cmd/protoc-gen-go \           google.golang.org/grpc/cmd/protoc-gen-go-grpc       COPY api.proto /defs       RUN mkdir /defs/go-api       RUN protoc --proto_path=/defs --go_out=/defs/go-api \           --go-grpc_out=/defs/go-api /defs/api.proto       SAVE ARTIFACT ./go-api /go-pb AS LOCAL go-pb   This will then produce two go files under the go-pb directory: api.pb.go and api_grpc.pb.go which contains the auto generated protobuf and grpc code respectively.   At this point, assuming that earth is already installed, give it a try for yourself with code from our example repository:      git clone https://github.com/earthly/example-grpc-key-value-store.git     cd example-grpc-key-value-store/proto     earth +proto-go  The next step is to write the server code that will implement the set and get methods:       package main          import (      &quot;context&quot;      &quot;fmt&quot;      &quot;log&quot;      &quot;net&quot;           pb &quot;github.com/earthly/example-grpc-key-value-store/go-server/kvapi&quot;           &quot;google.golang.org/grpc&quot;     )          const (      port = &quot;:50051&quot;     )          var errKeyNotFound = fmt.Errorf(&quot;key not found&quot;)          // server is used to implement kvapi.KeyValueServer     type server struct {      pb.UnimplementedKeyValueServer      data map[string]string     }          // Set stores a given value under a given key     func (s *server) Set(ctx context.Context, in *pb.SetRequest) (*pb.SetReply, error) {      key := in.GetKey()      value := in.GetValue()      log.Printf(&quot;serving set request for key %q and value %q&quot;, key, value)           s.data[key] = value           reply := &amp;pb.SetReply{}      return reply, nil     }          // Get returns a value associated with a key to the client     func (s *server) Get(ctx context.Context, in *pb.GetRequest) (*pb.GetReply, error) {      key := in.GetKey()      log.Printf(&quot;serving get request for key %q&quot;, key)           value, ok := s.data[key]      if !ok {       return nil, errKeyNotFound      }           reply := &amp;pb.GetReply{       Value: value,      }      return reply, nil     }          func main() {      lis, err := net.Listen(&quot;tcp&quot;, port)      if err != nil {       log.Fatalf(&quot;failed to listen: %v&quot;, err)      }      log.Printf(&quot;Listening on %s&quot;, port)      serverInstance := server{       data: make(map[string]string),      }      s := grpc.NewServer()      pb.RegisterKeyValueServer(s, &amp;serverInstance)      if err := s.Serve(lis); err != nil {       log.Fatalf(&quot;failed to serve: %v&quot;, err)      }     }   Next we will compile the go code and save it as a docker image with the following Earthfile:       FROM golang:1.13-alpine3.11          WORKDIR /kvserver          kvserver:         COPY go.mod go.sum ./         RUN go mod download         COPY ../proto+proto-go/go-pb kvapi         COPY --dir cmd ./         RUN go build -o kvserver cmd/server/main.go         SAVE ARTIFACT kvserver          kvserver-docker:         FROM alpine:latest         COPY +kvserver/kvserver /kvserver         ENTRYPOINT /kvserver         SAVE IMAGE as kvserver:latest   You can give it a try on your own by using our example code in our GitHub repository, just run:       git clone https://github.com/earthly/example-grpc-key-value-store.git     cd example-grpc-key-value-store/go-server     earth +kvserver-docker   Then start up the server in Docker, by running:       docker run --rm --network=host kvserver:latest    Next step: Implementing a gRPC Client Using Python   Now that we’ve built and launched our Go-based key-value-store server, we’ll cover how to talk to it using a Python client. Remember that initial Earthfile that generated the Go code? We’ll extend it to pip install grpc tooling, and generate Python code:       proto-py:       RUN apt-get install -y python3 python3-pip       RUN pip3 install grpcio grpcio-tools       COPY api.proto /defs       RUN mkdir /defs/py-api       RUN python3 -m grpc_tools.protoc -I /defs --python_out=/defs/py-api \           --grpc_python_out=/defs/py-api /defs/api.proto       SAVE ARTIFACT ./py-api /py-pb AS LOCAL py-pb   Then we’ll create a client that reads command line arguments, and if the argument contains an equals sign, it will store the value in the server, and otherwise it will retrieve the value from the server:       import sys     import grpc          import api_pb2     import api_pb2_grpc          addr = &#39;127.0.0.1:50051&#39;          if len(sys.argv) &lt; 2:         print(&#39;program requires arguments in the form key, or key=value&#39;)         sys.exit(1)          channel = grpc.insecure_channel(addr)     stub = api_pb2_grpc.KeyValueStub(channel)          for arg in sys.argv[1:]:         if &#39;=&#39; in arg:             # send a value to the server             key, value = arg.split(&#39;=&#39;)             try:                 set_request = api_pb2.SetRequest(key=key, value=value)                 set_response = stub.Set(set_request)             except grpc.RpcError as e:                 print(f&#39;failed to send key to server: {e.details}&#39;)             else:                 print(f&#39;sent &quot;{key}&quot; to server&#39;)         else:             # get a value from the server             key = arg             try:                 get_request = api_pb2.GetRequest(key=key)                 get_response = stub.Get(get_request)             except grpc.RpcError as e:                 print(f&#39;failed to get key from server: {e.details}&#39;)             else:                 value = get_response.value                 print(f&#39;server returned value &quot;{value}&quot; for key &quot;{key}&quot;&#39;)   We then store this python code, along with the generated gRPC protobuf code with the following Earthfile:       FROM python:3          RUN pip install grpcio protobuf pycodestyle          WORKDIR /kvclient          code:         COPY client.py .         COPY ../proto+proto-go/go-pb kvapi          lint:         FROM +code         RUN pycodestyle client.py          kvclient-docker:         FROM +code         SAVE IMAGE as python-kvclient:latest          all:         BUILD +lint         BUILD +kvclient-docker   You can give it a try for yourself with the example code:       git clone https://github.com/earthly/example-grpc-key-value-store.git     cd example-grpc-key-value-store/python-client     earth +kvclient-docker   Then you can run it and set the weather to sunny with:      docker run --rm --network=host python-kvclient:latest python3 /kvclient/client.py weather=sunny  And if all went well, you should see some output on both the client and server consoles:      # client output     sent &quot;weather&quot; to server          # server output     2020/11/12 23:15:18 Listening on :50051     2020/11/12 23:15:34 serving set request for key &quot;weather&quot; and value &quot;sunny&quot;   Final Step: Implementing a gRPC Client Using Ruby   We’ve come a long ways with our Go and Python gRPC examples, but what if you also wanted to include a Ruby gRPC client implementation too? Well let’s extend our proto Earthfile to generate Ruby protobufs too:       proto-rb:       RUN apt-get install -y ruby       RUN gem install grpc grpc-tools       COPY api.proto /defs       RUN mkdir /defs/rb-api       RUN grpc_tools_ruby_protoc -I /defs --ruby_out=/defs/rb-api --grpc_out=/defs/rb-api /defs/api.proto       SAVE ARTIFACT ./rb-api /rb-pb AS LOCAL rb-pb   We can then use this generated Ruby gRPC code with a simple ruby client example that performs a get request for keys listed as command line arguments:       $LOAD_PATH.unshift &#39;.&#39;          require &#39;grpc&#39;     require &#39;api_pb&#39;     require &#39;api_services_pb&#39;           stub = Simplekeyvalue::KeyValue::Stub.new(       &#39;127.0.0.1:50051&#39;, :this_channel_is_insecure     )           ARGV.map do |arg|       request = Simplekeyvalue::GetRequest.new(key: arg)       response = stub.get(request)       puts response.value     end      git clone https://github.com/earthly/example-grpc-key-value-store.git     cd example-grpc-key-value-store/ruby-client     earth +kvclient-docker  Then you can try querying the server to see what the weather was set to:      docker run --rm --network=host ruby-kvclient:latest ruby /kvclient/client.rb weather And if all went well, it’ll tell you that it’s sunny outside.     It’s Sunny Outside     So there we go.  You can find the code for the server and the two clients in GitHub.">



  <meta property="og:image" content="/blog/generated/assets/images/protobufs-and-grpc/header-800-d036ae2fd.jpg">



  <meta name="twitter:site" content="@EarthlyTech">
  <meta name="twitter:title" content="Using gRPC with Golang, Python, and Ruby">
  <meta name="twitter:description" content="I was surprised to learn that Google protocol buffers (protobufs), were first introduced nearly two decades ago. They were used internally at google as early as 2001 and were open sourced 2008.   Following this success, in 2016 Google released gRPC.   gRPC offered a way to define remote procedure calls using protobufs for serialization. Due to protobuf’s binary serialization format, it offered a significant speed up compared to using JSON over HTTP. The use of proto files for a precise definition of a service’s API. This was a big innovation.     gRPC is a great solution for communicating between internal microservices. There’s plenty of articles and documentation that covers protobufs and gRPC, but when I am considering a new technology, I learn best by seeing a working example.  In this blog post I’m going build an example using Go, Python and Ruby.   First Step: Implementing a gRPC Client using Go   Let’s write an in-memory key/value micro-service in Go, and some clients in both Python and Ruby.   Our server will allow users to set and get data from a key/value store.      Interacting with the server     First let’s design our API in a proto file:       syntax = &quot;proto3&quot;;     package simplekeyvalue;     option go_package = &quot;kvapi&quot;;          // The key/value API contains two procedures for storing and retrieving data     service KeyValue {       rpc Set (SetRequest) returns (SetReply) {}       rpc Get (GetRequest) returns (GetReply) {}     }          // SetRequest contains a key and value to set     message SetRequest {       string key = 1;       string value = 2;     }          // SetReply contains nothing     message SetReply {     }          // GetRequest contains a key and value to set     message GetRequest {       string key = 1;     }          // GetReply contains the value     message GetReply {       string value = 1;     }   Next we need to compile this proto file into Go code. On a Mac one might be tempted to run brew install protobuf, or if you’re on Linux you might want to see if apt-get install protoc will magically work, but rather than do that, we will use earthly to containerize these tools. This will allow you to share this code with other developers, and ensure everyone can compile proto files across multiple platforms using the same version to eliminate compatibility issues.   Here’s what an Earthfile would look like for installing Google protobufs inside an Ubuntu image, and generating the protobuf code using the protoc-gen-go-grpc tool:       FROM ubuntu:20.10     WORKDIR /defs          RUN apt-get update &amp;&amp; apt-get install -y wget unzip          # setup protoc     RUN wget -O protoc.zip https://github.com/protocolbuffers/protobuf/releases/download/v3.13.0/protoc-3.13.0-linux-x86_64.zip     RUN unzip protoc.zip -d /usr/local/          proto-go:       RUN apt-get install -y golang git       ENV GO111MODULE=on       ENV PATH=$PATH:/root/go/bin       RUN go get google.golang.org/protobuf/cmd/protoc-gen-go \           google.golang.org/grpc/cmd/protoc-gen-go-grpc       COPY api.proto /defs       RUN mkdir /defs/go-api       RUN protoc --proto_path=/defs --go_out=/defs/go-api \           --go-grpc_out=/defs/go-api /defs/api.proto       SAVE ARTIFACT ./go-api /go-pb AS LOCAL go-pb   This will then produce two go files under the go-pb directory: api.pb.go and api_grpc.pb.go which contains the auto generated protobuf and grpc code respectively.   At this point, assuming that earth is already installed, give it a try for yourself with code from our example repository:      git clone https://github.com/earthly/example-grpc-key-value-store.git     cd example-grpc-key-value-store/proto     earth +proto-go  The next step is to write the server code that will implement the set and get methods:       package main          import (      &quot;context&quot;      &quot;fmt&quot;      &quot;log&quot;      &quot;net&quot;           pb &quot;github.com/earthly/example-grpc-key-value-store/go-server/kvapi&quot;           &quot;google.golang.org/grpc&quot;     )          const (      port = &quot;:50051&quot;     )          var errKeyNotFound = fmt.Errorf(&quot;key not found&quot;)          // server is used to implement kvapi.KeyValueServer     type server struct {      pb.UnimplementedKeyValueServer      data map[string]string     }          // Set stores a given value under a given key     func (s *server) Set(ctx context.Context, in *pb.SetRequest) (*pb.SetReply, error) {      key := in.GetKey()      value := in.GetValue()      log.Printf(&quot;serving set request for key %q and value %q&quot;, key, value)           s.data[key] = value           reply := &amp;pb.SetReply{}      return reply, nil     }          // Get returns a value associated with a key to the client     func (s *server) Get(ctx context.Context, in *pb.GetRequest) (*pb.GetReply, error) {      key := in.GetKey()      log.Printf(&quot;serving get request for key %q&quot;, key)           value, ok := s.data[key]      if !ok {       return nil, errKeyNotFound      }           reply := &amp;pb.GetReply{       Value: value,      }      return reply, nil     }          func main() {      lis, err := net.Listen(&quot;tcp&quot;, port)      if err != nil {       log.Fatalf(&quot;failed to listen: %v&quot;, err)      }      log.Printf(&quot;Listening on %s&quot;, port)      serverInstance := server{       data: make(map[string]string),      }      s := grpc.NewServer()      pb.RegisterKeyValueServer(s, &amp;serverInstance)      if err := s.Serve(lis); err != nil {       log.Fatalf(&quot;failed to serve: %v&quot;, err)      }     }   Next we will compile the go code and save it as a docker image with the following Earthfile:       FROM golang:1.13-alpine3.11          WORKDIR /kvserver          kvserver:         COPY go.mod go.sum ./         RUN go mod download         COPY ../proto+proto-go/go-pb kvapi         COPY --dir cmd ./         RUN go build -o kvserver cmd/server/main.go         SAVE ARTIFACT kvserver          kvserver-docker:         FROM alpine:latest         COPY +kvserver/kvserver /kvserver         ENTRYPOINT /kvserver         SAVE IMAGE as kvserver:latest   You can give it a try on your own by using our example code in our GitHub repository, just run:       git clone https://github.com/earthly/example-grpc-key-value-store.git     cd example-grpc-key-value-store/go-server     earth +kvserver-docker   Then start up the server in Docker, by running:       docker run --rm --network=host kvserver:latest    Next step: Implementing a gRPC Client Using Python   Now that we’ve built and launched our Go-based key-value-store server, we’ll cover how to talk to it using a Python client. Remember that initial Earthfile that generated the Go code? We’ll extend it to pip install grpc tooling, and generate Python code:       proto-py:       RUN apt-get install -y python3 python3-pip       RUN pip3 install grpcio grpcio-tools       COPY api.proto /defs       RUN mkdir /defs/py-api       RUN python3 -m grpc_tools.protoc -I /defs --python_out=/defs/py-api \           --grpc_python_out=/defs/py-api /defs/api.proto       SAVE ARTIFACT ./py-api /py-pb AS LOCAL py-pb   Then we’ll create a client that reads command line arguments, and if the argument contains an equals sign, it will store the value in the server, and otherwise it will retrieve the value from the server:       import sys     import grpc          import api_pb2     import api_pb2_grpc          addr = &#39;127.0.0.1:50051&#39;          if len(sys.argv) &lt; 2:         print(&#39;program requires arguments in the form key, or key=value&#39;)         sys.exit(1)          channel = grpc.insecure_channel(addr)     stub = api_pb2_grpc.KeyValueStub(channel)          for arg in sys.argv[1:]:         if &#39;=&#39; in arg:             # send a value to the server             key, value = arg.split(&#39;=&#39;)             try:                 set_request = api_pb2.SetRequest(key=key, value=value)                 set_response = stub.Set(set_request)             except grpc.RpcError as e:                 print(f&#39;failed to send key to server: {e.details}&#39;)             else:                 print(f&#39;sent &quot;{key}&quot; to server&#39;)         else:             # get a value from the server             key = arg             try:                 get_request = api_pb2.GetRequest(key=key)                 get_response = stub.Get(get_request)             except grpc.RpcError as e:                 print(f&#39;failed to get key from server: {e.details}&#39;)             else:                 value = get_response.value                 print(f&#39;server returned value &quot;{value}&quot; for key &quot;{key}&quot;&#39;)   We then store this python code, along with the generated gRPC protobuf code with the following Earthfile:       FROM python:3          RUN pip install grpcio protobuf pycodestyle          WORKDIR /kvclient          code:         COPY client.py .         COPY ../proto+proto-go/go-pb kvapi          lint:         FROM +code         RUN pycodestyle client.py          kvclient-docker:         FROM +code         SAVE IMAGE as python-kvclient:latest          all:         BUILD +lint         BUILD +kvclient-docker   You can give it a try for yourself with the example code:       git clone https://github.com/earthly/example-grpc-key-value-store.git     cd example-grpc-key-value-store/python-client     earth +kvclient-docker   Then you can run it and set the weather to sunny with:      docker run --rm --network=host python-kvclient:latest python3 /kvclient/client.py weather=sunny  And if all went well, you should see some output on both the client and server consoles:      # client output     sent &quot;weather&quot; to server          # server output     2020/11/12 23:15:18 Listening on :50051     2020/11/12 23:15:34 serving set request for key &quot;weather&quot; and value &quot;sunny&quot;   Final Step: Implementing a gRPC Client Using Ruby   We’ve come a long ways with our Go and Python gRPC examples, but what if you also wanted to include a Ruby gRPC client implementation too? Well let’s extend our proto Earthfile to generate Ruby protobufs too:       proto-rb:       RUN apt-get install -y ruby       RUN gem install grpc grpc-tools       COPY api.proto /defs       RUN mkdir /defs/rb-api       RUN grpc_tools_ruby_protoc -I /defs --ruby_out=/defs/rb-api --grpc_out=/defs/rb-api /defs/api.proto       SAVE ARTIFACT ./rb-api /rb-pb AS LOCAL rb-pb   We can then use this generated Ruby gRPC code with a simple ruby client example that performs a get request for keys listed as command line arguments:       $LOAD_PATH.unshift &#39;.&#39;          require &#39;grpc&#39;     require &#39;api_pb&#39;     require &#39;api_services_pb&#39;           stub = Simplekeyvalue::KeyValue::Stub.new(       &#39;127.0.0.1:50051&#39;, :this_channel_is_insecure     )           ARGV.map do |arg|       request = Simplekeyvalue::GetRequest.new(key: arg)       response = stub.get(request)       puts response.value     end      git clone https://github.com/earthly/example-grpc-key-value-store.git     cd example-grpc-key-value-store/ruby-client     earth +kvclient-docker  Then you can try querying the server to see what the weather was set to:      docker run --rm --network=host ruby-kvclient:latest ruby /kvclient/client.rb weather And if all went well, it’ll tell you that it’s sunny outside.     It’s Sunny Outside     So there we go.  You can find the code for the server and the two clients in GitHub.">
  <meta name="twitter:url" content="https://earthly.dev/blog/protobufs-and-grpc/">

  
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://earthly.dev/blog/generated/assets/images/protobufs-and-grpc/header-800-d036ae2fd.jpg">
  

  



  <meta property="article:published_time" content="2020-11-13T00:00:00-05:00">





  

  


<link rel="canonical" href="https://earthly.dev/blog/protobufs-and-grpc/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Organization",
      "url": "https://earthly.dev/blog/",
      "logo": "/assets/images/logo-header.png"
    
  }
</script>






<!-- end _includes/seo.html -->



  <link href="/blog/feed.xml" type="application/atom+xml" rel="alternate" title="Earthly Blog Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/blog/assets/css/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->


  
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-161831101-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-161831101-5');
</script>
  <!-- Facebook Pixel Code -->
<script>
    !function(f,b,e,v,n,t,s)
    {if(f.fbq)return;n=f.fbq=function(){n.callMethod?
    n.callMethod.apply(n,arguments):n.queue.push(arguments)};
    if(!f._fbq)f._fbq=n;n.push=n;n.loaded=!0;n.version='2.0';
    n.queue=[];t=b.createElement(e);t.async=!0;
    t.src=v;s=b.getElementsByTagName(e)[0];
    s.parentNode.insertBefore(t,s)}(window, document,'script',
    'https://connect.facebook.net/en_US/fbevents.js');
    fbq('init', '259843109045285');
    fbq('track', 'PageView');
    </script>
    <noscript><img height="1" width="1" style="display:none"
    src="https://www.facebook.com/tr?id=259843109045285&ev=PageView&noscript=1"
    />
</noscript>
 <!-- End Facebook Pixel Code -->
  <!-- Twitter universal website tag code -->
<script>
  !function(e,t,n,s,u,a){e.twq||(s=e.twq=function(){s.exe?s.exe.apply(s,arguments):s.queue.push(arguments);
  },s.version='1.1',s.queue=[],u=t.createElement(n),u.async=!0,u.src='//static.ads-twitter.com/uwt.js',
  a=t.getElementsByTagName(n)[0],a.parentNode.insertBefore(u,a))}(window,document,'script');
  // Insert Twitter Pixel ID and Standard Event data below
  twq('init','o5s6p');
  twq('track','PageView');
  </script>
  <!-- End Twitter universal website tag code -->


  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/"><img src="/blog/assets/images/white-logo.png" alt="Earthly"></a>
        
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/blog/">Blog home</a>
            </li><li class="masthead__menu-item">
              <a href="/blog/categories/articles/">Articles</a>
            </li><li class="masthead__menu-item">
              <a href="/blog/categories/news/">News</a>
            </li><li class="masthead__menu-item">
              <a href="/blog/categories/tutorials/">Tutorials</a>
            </li><li class="masthead__menu-item">
              <a href="https://github.com/earthly/earthly">GitHub</a>
            </li></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      




  







<div class="page__hero"
  style=" background-image: url('');"
>
  
      <picture class="page__hero-image"><source srcset="/blog/generated/assets/images/protobufs-and-grpc/header-400-a0270ba14.webp 400w, /blog/generated/assets/images/protobufs-and-grpc/header-600-a0270ba14.webp 600w, /blog/generated/assets/images/protobufs-and-grpc/header-800-a0270ba14.webp 800w, /blog/generated/assets/images/protobufs-and-grpc/header-1000-a0270ba14.webp 1000w, /blog/generated/assets/images/protobufs-and-grpc/header-1200-a0270ba14.webp 1200w" type="image/webp"><source srcset="/blog/generated/assets/images/protobufs-and-grpc/header-400-a0270ba14.png 400w, /blog/generated/assets/images/protobufs-and-grpc/header-600-a0270ba14.png 600w, /blog/generated/assets/images/protobufs-and-grpc/header-800-a0270ba14.png 800w, /blog/generated/assets/images/protobufs-and-grpc/header-1000-a0270ba14.png 1000w, /blog/generated/assets/images/protobufs-and-grpc/header-1200-a0270ba14.png 1200w" type="image/png"><img src="/blog/generated/assets/images/protobufs-and-grpc/header-800-a0270ba14.jpg" alt="Using gRPC with Golang, Python, and Ruby"></picture>

  
  
</div>





<div id="main" role="main">
  
  <div class="sidebar">
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Using gRPC with Golang, Python, and Ruby">
    <meta itemprop="description" content="I was surprised to learn that Google protocol buffers (protobufs), were first introduced nearly two decades ago. They were used internally at google as early as 2001 and were open sourced 2008.Following this success, in 2016 Google released gRPC.   gRPC offered a way to define remote procedure calls using protobufs for serialization. Due to protobuf’s binary serialization format, it offered a significant speed up compared to using JSON over HTTP. The use of proto files for a precise definition of a service’s API. This was a big innovation.  gRPC is a great solution for communicating between internal microservices. There’s plenty of articles and documentation that covers protobufs and gRPC, but when I am considering a new technology, I learn best by seeing a working example.  In this blog post I’m going build an example using Go, Python and Ruby.First Step: Implementing a gRPC Client using GoLet’s write an in-memory key/value micro-service in Go, and some clients in both Python and Ruby.Our server will allow users to set and get data from a key/value store.Interacting with the serverFirst let’s design our API in a proto file:    syntax = &quot;proto3&quot;;    package simplekeyvalue;    option go_package = &quot;kvapi&quot;;        // The key/value API contains two procedures for storing and retrieving data    service KeyValue {      rpc Set (SetRequest) returns (SetReply) {}      rpc Get (GetRequest) returns (GetReply) {}    }        // SetRequest contains a key and value to set    message SetRequest {      string key = 1;      string value = 2;    }        // SetReply contains nothing    message SetReply {    }        // GetRequest contains a key and value to set    message GetRequest {      string key = 1;    }        // GetReply contains the value    message GetReply {      string value = 1;    }Next we need to compile this proto file into Go code. On a Mac one might be tempted to run brew install protobuf, or if you’re on Linux you might want to see if apt-get install protoc will magically work, but rather than do that, we will use earthly to containerize these tools. This will allow you to share this code with other developers, and ensure everyone can compile proto files across multiple platforms using the same version to eliminate compatibility issues.Here’s what an Earthfile would look like for installing Google protobufs inside an Ubuntu image, and generating the protobuf code using the protoc-gen-go-grpc tool:    FROM ubuntu:20.10    WORKDIR /defs        RUN apt-get update &amp;&amp; apt-get install -y wget unzip        # setup protoc    RUN wget -O protoc.zip https://github.com/protocolbuffers/protobuf/releases/download/v3.13.0/protoc-3.13.0-linux-x86_64.zip    RUN unzip protoc.zip -d /usr/local/        proto-go:      RUN apt-get install -y golang git      ENV GO111MODULE=on      ENV PATH=$PATH:/root/go/bin      RUN go get google.golang.org/protobuf/cmd/protoc-gen-go \          google.golang.org/grpc/cmd/protoc-gen-go-grpc      COPY api.proto /defs      RUN mkdir /defs/go-api      RUN protoc --proto_path=/defs --go_out=/defs/go-api \          --go-grpc_out=/defs/go-api /defs/api.proto      SAVE ARTIFACT ./go-api /go-pb AS LOCAL go-pbThis will then produce two go files under the go-pb directory: api.pb.go and api_grpc.pb.go which contains the auto generated protobuf and grpc code respectively.At this point, assuming that earth is already installed, give it a try for yourself with code from our example repository:    git clone https://github.com/earthly/example-grpc-key-value-store.git    cd example-grpc-key-value-store/proto    earth +proto-goThe next step is to write the server code that will implement the set and get methods:    package main        import (     &quot;context&quot;     &quot;fmt&quot;     &quot;log&quot;     &quot;net&quot;         pb &quot;github.com/earthly/example-grpc-key-value-store/go-server/kvapi&quot;         &quot;google.golang.org/grpc&quot;    )        const (     port = &quot;:50051&quot;    )        var errKeyNotFound = fmt.Errorf(&quot;key not found&quot;)        // server is used to implement kvapi.KeyValueServer    type server struct {     pb.UnimplementedKeyValueServer     data map[string]string    }        // Set stores a given value under a given key    func (s *server) Set(ctx context.Context, in *pb.SetRequest) (*pb.SetReply, error) {     key := in.GetKey()     value := in.GetValue()     log.Printf(&quot;serving set request for key %q and value %q&quot;, key, value)         s.data[key] = value         reply := &amp;pb.SetReply{}     return reply, nil    }        // Get returns a value associated with a key to the client    func (s *server) Get(ctx context.Context, in *pb.GetRequest) (*pb.GetReply, error) {     key := in.GetKey()     log.Printf(&quot;serving get request for key %q&quot;, key)         value, ok := s.data[key]     if !ok {      return nil, errKeyNotFound     }         reply := &amp;pb.GetReply{      Value: value,     }     return reply, nil    }        func main() {     lis, err := net.Listen(&quot;tcp&quot;, port)     if err != nil {      log.Fatalf(&quot;failed to listen: %v&quot;, err)     }     log.Printf(&quot;Listening on %s&quot;, port)     serverInstance := server{      data: make(map[string]string),     }     s := grpc.NewServer()     pb.RegisterKeyValueServer(s, &amp;serverInstance)     if err := s.Serve(lis); err != nil {      log.Fatalf(&quot;failed to serve: %v&quot;, err)     }    }Next we will compile the go code and save it as a docker image with the following Earthfile:    FROM golang:1.13-alpine3.11        WORKDIR /kvserver        kvserver:        COPY go.mod go.sum ./        RUN go mod download        COPY ../proto+proto-go/go-pb kvapi        COPY --dir cmd ./        RUN go build -o kvserver cmd/server/main.go        SAVE ARTIFACT kvserver        kvserver-docker:        FROM alpine:latest        COPY +kvserver/kvserver /kvserver        ENTRYPOINT /kvserver        SAVE IMAGE as kvserver:latestYou can give it a try on your own by using our example code in our GitHub repository, just run:    git clone https://github.com/earthly/example-grpc-key-value-store.git    cd example-grpc-key-value-store/go-server    earth +kvserver-dockerThen start up the server in Docker, by running:    docker run --rm --network=host kvserver:latestNext step: Implementing a gRPC Client Using PythonNow that we’ve built and launched our Go-based key-value-store server, we’ll cover how to talk to it using a Python client. Remember that initial Earthfile that generated the Go code? We’ll extend it to pip install grpc tooling, and generate Python code:    proto-py:      RUN apt-get install -y python3 python3-pip      RUN pip3 install grpcio grpcio-tools      COPY api.proto /defs      RUN mkdir /defs/py-api      RUN python3 -m grpc_tools.protoc -I /defs --python_out=/defs/py-api \          --grpc_python_out=/defs/py-api /defs/api.proto      SAVE ARTIFACT ./py-api /py-pb AS LOCAL py-pbThen we’ll create a client that reads command line arguments, and if the argument contains an equals sign, it will store the value in the server, and otherwise it will retrieve the value from the server:    import sys    import grpc        import api_pb2    import api_pb2_grpc        addr = &#39;127.0.0.1:50051&#39;        if len(sys.argv) &lt; 2:        print(&#39;program requires arguments in the form key, or key=value&#39;)        sys.exit(1)        channel = grpc.insecure_channel(addr)    stub = api_pb2_grpc.KeyValueStub(channel)        for arg in sys.argv[1:]:        if &#39;=&#39; in arg:            # send a value to the server            key, value = arg.split(&#39;=&#39;)            try:                set_request = api_pb2.SetRequest(key=key, value=value)                set_response = stub.Set(set_request)            except grpc.RpcError as e:                print(f&#39;failed to send key to server: {e.details}&#39;)            else:                print(f&#39;sent &quot;{key}&quot; to server&#39;)        else:            # get a value from the server            key = arg            try:                get_request = api_pb2.GetRequest(key=key)                get_response = stub.Get(get_request)            except grpc.RpcError as e:                print(f&#39;failed to get key from server: {e.details}&#39;)            else:                value = get_response.value                print(f&#39;server returned value &quot;{value}&quot; for key &quot;{key}&quot;&#39;)We then store this python code, along with the generated gRPC protobuf code with the following Earthfile:    FROM python:3        RUN pip install grpcio protobuf pycodestyle        WORKDIR /kvclient        code:        COPY client.py .        COPY ../proto+proto-go/go-pb kvapi        lint:        FROM +code        RUN pycodestyle client.py        kvclient-docker:        FROM +code        SAVE IMAGE as python-kvclient:latest        all:        BUILD +lint        BUILD +kvclient-dockerYou can give it a try for yourself with the example code:    git clone https://github.com/earthly/example-grpc-key-value-store.git    cd example-grpc-key-value-store/python-client    earth +kvclient-dockerThen you can run it and set the weather to sunny with:    docker run --rm --network=host python-kvclient:latest python3 /kvclient/client.py weather=sunnyAnd if all went well, you should see some output on both the client and server consoles:    # client output    sent &quot;weather&quot; to server        # server output    2020/11/12 23:15:18 Listening on :50051    2020/11/12 23:15:34 serving set request for key &quot;weather&quot; and value &quot;sunny&quot;Final Step: Implementing a gRPC Client Using RubyWe’ve come a long ways with our Go and Python gRPC examples, but what if you also wanted to include a Ruby gRPC client implementation too? Well let’s extend our proto Earthfile to generate Ruby protobufs too:    proto-rb:      RUN apt-get install -y ruby      RUN gem install grpc grpc-tools      COPY api.proto /defs      RUN mkdir /defs/rb-api      RUN grpc_tools_ruby_protoc -I /defs --ruby_out=/defs/rb-api --grpc_out=/defs/rb-api /defs/api.proto      SAVE ARTIFACT ./rb-api /rb-pb AS LOCAL rb-pbWe can then use this generated Ruby gRPC code with a simple ruby client example that performs a get request for keys listed as command line arguments:    $LOAD_PATH.unshift &#39;.&#39;        require &#39;grpc&#39;    require &#39;api_pb&#39;    require &#39;api_services_pb&#39;         stub = Simplekeyvalue::KeyValue::Stub.new(      &#39;127.0.0.1:50051&#39;, :this_channel_is_insecure    )         ARGV.map do |arg|      request = Simplekeyvalue::GetRequest.new(key: arg)      response = stub.get(request)      puts response.value    end    git clone https://github.com/earthly/example-grpc-key-value-store.git    cd example-grpc-key-value-store/ruby-client    earth +kvclient-dockerThen you can try querying the server to see what the weather was set to:    docker run --rm --network=host ruby-kvclient:latest ruby /kvclient/client.rb weatherAnd if all went well, it’ll tell you that it’s sunny outside.It’s Sunny OutsideSo there we go.  You can find the code for the server and the two clients in GitHub.">
    <meta itemprop="datePublished" content="2020-11-13T00:00:00-05:00">
    

    <div class="page__inner-wrap">
      

      <section class="page__content" itemprop="text">
        
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">Using gRPC with Golang, Python, and Ruby
</h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          6 minute read
        
        
        &nbsp;	&nbsp;<i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2020-11-13T00:00:00-05:00">November 13, 2020</time>
        

      </span>
    
    <span>
      
      
      
      <div class="author__avatar_top">
          <picture class="image-author"><source srcset="/blog/generated/assets/images/authors/alexcouturebeil-240-5d6b0185c.webp 240w" type="image/webp"><source srcset="/blog/generated/assets/images/authors/alexcouturebeil-240-8935b6224.jpg 240w" type="image/jpeg"><img src="/blog/generated/assets/images/authors/alexcouturebeil-240-8935b6224.jpg" alt="Alex Couture-Beil %"></picture>

          &nbsp;	&nbsp;
          Alex Couture-Beil
      </div>
      
    </span>
  </p>


        </header>
      
        
          <aside class="sidebar__right ">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#first-step-implementing-a-grpc-client-using-go">First Step: Implementing a gRPC Client using Go</a></li><li><a href="#next-step-implementing-a-grpc-client-using-python">Next step: Implementing a gRPC Client Using Python</a></li><li><a href="#final-step-implementing-a-grpc-client-using-ruby">Final Step: Implementing a gRPC Client Using Ruby</a></li></ul>

            </nav>
          </aside>
        
        <p>I was surprised to learn that Google protocol buffers (protobufs), were first introduced nearly two decades ago. They were used internally at google as early as 2001 and were open sourced 2008.</p>
<p>Following this success, in 2016 Google released gRPC.   gRPC offered a way to define remote procedure calls using protobufs for serialization. Due to protobuf’s binary serialization format, it offered a significant speed up compared to using JSON over HTTP. The use of proto files for a precise definition of a service’s API. This was a big innovation.  </p>
<p>gRPC is a great solution for communicating between internal microservices. There’s <a href="https://phenopackets-schema.readthedocs.io/en/latest/protobuf.html">plenty</a> <a href="https://www.ionos.ca/digitalguide/websites/web-development/protocol-buffers-explained/">of</a> <a href="https://www.baeldung.com/google-protocol-buffer">articles</a> and documentation that covers <a href="https://developers.google.com/protocol-buffers">protobufs</a> and <a href="https://grpc.io/">gRPC</a>, but when I am considering a new technology, I learn best by seeing a working example.  In this blog post I’m going build an example using Go, Python and Ruby.</p>
<h2 id="first-step-implementing-a-grpc-client-using-go">First Step: Implementing a gRPC Client using Go</h2>
<p>Let’s write an in-memory key/value micro-service in Go, and some clients in both Python and Ruby.</p>
<p>Our server will allow users to set and get data from a key/value store.</p>
<figure class>
<img src="/blog/assets/images/protobufs-and-grpc/server.png"
       alt="hand drawn cartoon for a person talking to a computer server">
<figcaption>
<p>Interacting with the server</p>
</figcaption>
</figure>
<p>First let’s design our API in a proto file:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode protobuf"><code class="sourceCode protobuf"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>    syntax = <span class="st">&quot;proto3&quot;</span>;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">package</span> simplekeyvalue;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">option</span> go_package = <span class="st">&quot;kvapi&quot;</span>;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// The key/value API contains two procedures for storing and retrieving data</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    service KeyValue {</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>      rpc Set (SetRequest) returns (SetReply) {}</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>      rpc Get (GetRequest) returns (GetReply) {}</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// SetRequest contains a key and value to set</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">message</span> SetRequest {</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>      <span class="dt">string</span> key = <span class="dv">1</span>;</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>      <span class="dt">string</span> value = <span class="dv">2</span>;</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// SetReply contains nothing</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">message</span> SetReply {</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">// GetRequest contains a key and value to set</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">message</span> GetRequest {</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>      <span class="dt">string</span> key = <span class="dv">1</span>;</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">// GetReply contains the value</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">message</span> GetReply {</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>      <span class="dt">string</span> value = <span class="dv">1</span>;</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p>Next we need to compile this proto file into Go code. On a Mac one might be tempted to run <em>brew install protobuf</em>, or if you’re on Linux you might want to see if <em>apt-get install protoc</em> will magically work, but rather than do that, we will use earthly to containerize these tools. This will allow you to share this code with other developers, and ensure everyone can compile proto files across multiple platforms using the same version to eliminate compatibility issues.</p>
<p>Here’s what an Earthfile would look like for installing Google protobufs inside an Ubuntu image, and generating the protobuf code using the protoc-gen-go-grpc tool:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> ubuntu:20.10</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WORKDIR</span> /defs</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">RUN</span> apt-get update &amp;&amp; apt-get install -y wget unzip</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># setup protoc</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">RUN</span> wget -O protoc.zip https://github.com/protocolbuffers/protobuf/releases/download/v3.13.0/protoc-3.13.0-linux-x86_64.zip</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">RUN</span> unzip protoc.zip -d /usr/local/</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    proto-go:</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>      <span class="kw">RUN</span> apt-get install -y golang git</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>      <span class="kw">ENV</span> GO111MODULE=on</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>      <span class="kw">ENV</span> PATH=$PATH:/root/go/bin</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>      <span class="kw">RUN</span> go get google.golang.org/protobuf/cmd/protoc-gen-go \</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>          google.golang.org/grpc/cmd/protoc-gen-go-grpc</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>      <span class="kw">COPY</span> api.proto /defs</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>      <span class="kw">RUN</span> mkdir /defs/go-api</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>      <span class="kw">RUN</span> protoc --proto_path=/defs --go_out=/defs/go-api \</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>          --go-grpc_out=/defs/go-api /defs/api.proto</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>      SAVE ARTIFACT ./go-api /go-pb AS LOCAL go-pb</span></code></pre></div>
<p>This will then produce two go files under the go-pb directory: api.pb.go and api_grpc.pb.go which contains the auto generated protobuf and grpc code respectively.</p>
<p>At this point, assuming that earth is already <a href="https://docs.earthly.dev/installation">installed</a>, give it a try for yourself with code from our <a href="https://github.com/earthly/example-grpc-key-value-store">example repository</a>:</p>
<pre><code>    git clone https://github.com/earthly/example-grpc-key-value-store.git
    cd example-grpc-key-value-store/proto
    earth +proto-go</code></pre>
<p>The next step is to write the server code that will implement the set and get methods:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">package</span> main</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">import</span> <span class="op">(</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>     <span class="st">&quot;context&quot;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>     <span class="st">&quot;fmt&quot;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>     <span class="st">&quot;log&quot;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>     <span class="st">&quot;net&quot;</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>     pb <span class="st">&quot;github.com/earthly/example-grpc-key-value-store/go-server/kvapi&quot;</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>     <span class="st">&quot;google.golang.org/grpc&quot;</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">)</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> <span class="op">(</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>     port <span class="op">=</span> <span class="st">&quot;:50051&quot;</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">)</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> errKeyNotFound <span class="op">=</span> fmt<span class="op">.</span>Errorf<span class="op">(</span><span class="st">&quot;key not found&quot;</span><span class="op">)</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// server is used to implement kvapi.KeyValueServer</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> server <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>     pb<span class="op">.</span>UnimplementedKeyValueServer</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>     data <span class="kw">map</span><span class="op">[</span><span class="dt">string</span><span class="op">]</span><span class="dt">string</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Set stores a given value under a given key</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">func</span> <span class="op">(</span>s <span class="op">*</span>server<span class="op">)</span> Set<span class="op">(</span>ctx context<span class="op">.</span>Context<span class="op">,</span> in <span class="op">*</span>pb<span class="op">.</span>SetRequest<span class="op">)</span> <span class="op">(*</span>pb<span class="op">.</span>SetReply<span class="op">,</span> <span class="dt">error</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>     key <span class="op">:=</span> in<span class="op">.</span>GetKey<span class="op">()</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>     value <span class="op">:=</span> in<span class="op">.</span>GetValue<span class="op">()</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>     log<span class="op">.</span>Printf<span class="op">(</span><span class="st">&quot;serving set request for key %q and value %q&quot;</span><span class="op">,</span> key<span class="op">,</span> value<span class="op">)</span></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>     s<span class="op">.</span>data<span class="op">[</span>key<span class="op">]</span> <span class="op">=</span> value</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>     reply <span class="op">:=</span> <span class="op">&amp;</span>pb<span class="op">.</span>SetReply<span class="op">{}</span></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>     <span class="kw">return</span> reply<span class="op">,</span> <span class="ot">nil</span></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Get returns a value associated with a key to the client</span></span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">func</span> <span class="op">(</span>s <span class="op">*</span>server<span class="op">)</span> Get<span class="op">(</span>ctx context<span class="op">.</span>Context<span class="op">,</span> in <span class="op">*</span>pb<span class="op">.</span>GetRequest<span class="op">)</span> <span class="op">(*</span>pb<span class="op">.</span>GetReply<span class="op">,</span> <span class="dt">error</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>     key <span class="op">:=</span> in<span class="op">.</span>GetKey<span class="op">()</span></span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>     log<span class="op">.</span>Printf<span class="op">(</span><span class="st">&quot;serving get request for key %q&quot;</span><span class="op">,</span> key<span class="op">)</span></span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>     value<span class="op">,</span> ok <span class="op">:=</span> s<span class="op">.</span>data<span class="op">[</span>key<span class="op">]</span></span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a>     <span class="kw">if</span> <span class="op">!</span>ok <span class="op">{</span></span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a>      <span class="kw">return</span> <span class="ot">nil</span><span class="op">,</span> errKeyNotFound</span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a>     <span class="op">}</span></span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a>     reply <span class="op">:=</span> <span class="op">&amp;</span>pb<span class="op">.</span>GetReply<span class="op">{</span></span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a>      Value<span class="op">:</span> value<span class="op">,</span></span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a>     <span class="op">}</span></span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a>     <span class="kw">return</span> reply<span class="op">,</span> <span class="ot">nil</span></span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-54"><a href="#cb4-54" aria-hidden="true" tabindex="-1"></a>    <span class="kw">func</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb4-55"><a href="#cb4-55" aria-hidden="true" tabindex="-1"></a>     lis<span class="op">,</span> err <span class="op">:=</span> net<span class="op">.</span>Listen<span class="op">(</span><span class="st">&quot;tcp&quot;</span><span class="op">,</span> port<span class="op">)</span></span>
<span id="cb4-56"><a href="#cb4-56" aria-hidden="true" tabindex="-1"></a>     <span class="kw">if</span> err <span class="op">!=</span> <span class="ot">nil</span> <span class="op">{</span></span>
<span id="cb4-57"><a href="#cb4-57" aria-hidden="true" tabindex="-1"></a>      log<span class="op">.</span>Fatalf<span class="op">(</span><span class="st">&quot;failed to listen: %v&quot;</span><span class="op">,</span> err<span class="op">)</span></span>
<span id="cb4-58"><a href="#cb4-58" aria-hidden="true" tabindex="-1"></a>     <span class="op">}</span></span>
<span id="cb4-59"><a href="#cb4-59" aria-hidden="true" tabindex="-1"></a>     log<span class="op">.</span>Printf<span class="op">(</span><span class="st">&quot;Listening on %s&quot;</span><span class="op">,</span> port<span class="op">)</span></span>
<span id="cb4-60"><a href="#cb4-60" aria-hidden="true" tabindex="-1"></a>     serverInstance <span class="op">:=</span> server<span class="op">{</span></span>
<span id="cb4-61"><a href="#cb4-61" aria-hidden="true" tabindex="-1"></a>      data<span class="op">:</span> <span class="bu">make</span><span class="op">(</span><span class="kw">map</span><span class="op">[</span><span class="dt">string</span><span class="op">]</span><span class="dt">string</span><span class="op">),</span></span>
<span id="cb4-62"><a href="#cb4-62" aria-hidden="true" tabindex="-1"></a>     <span class="op">}</span></span>
<span id="cb4-63"><a href="#cb4-63" aria-hidden="true" tabindex="-1"></a>     s <span class="op">:=</span> grpc<span class="op">.</span>NewServer<span class="op">()</span></span>
<span id="cb4-64"><a href="#cb4-64" aria-hidden="true" tabindex="-1"></a>     pb<span class="op">.</span>RegisterKeyValueServer<span class="op">(</span>s<span class="op">,</span> <span class="op">&amp;</span>serverInstance<span class="op">)</span></span>
<span id="cb4-65"><a href="#cb4-65" aria-hidden="true" tabindex="-1"></a>     <span class="kw">if</span> err <span class="op">:=</span> s<span class="op">.</span>Serve<span class="op">(</span>lis<span class="op">);</span> err <span class="op">!=</span> <span class="ot">nil</span> <span class="op">{</span></span>
<span id="cb4-66"><a href="#cb4-66" aria-hidden="true" tabindex="-1"></a>      log<span class="op">.</span>Fatalf<span class="op">(</span><span class="st">&quot;failed to serve: %v&quot;</span><span class="op">,</span> err<span class="op">)</span></span>
<span id="cb4-67"><a href="#cb4-67" aria-hidden="true" tabindex="-1"></a>     <span class="op">}</span></span>
<span id="cb4-68"><a href="#cb4-68" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>Next we will compile the go code and save it as a docker image with the following Earthfile:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> golang:1.13-alpine3.11</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WORKDIR</span> /kvserver</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    kvserver:</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">COPY</span> go.mod go.sum ./</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">RUN</span> go mod download</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">COPY</span> ../proto+proto-go/go-pb kvapi</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">COPY</span> --dir cmd ./</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">RUN</span> go build -o kvserver cmd/server/main.go</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        SAVE ARTIFACT kvserver</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    kvserver-docker:</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">FROM</span> alpine:latest</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">COPY</span> +kvserver/kvserver /kvserver</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">ENTRYPOINT</span> /kvserver</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>        SAVE IMAGE as kvserver:latest</span></code></pre></div>
<p>You can give it a try on your own by using our example code in our GitHub repository, just run:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>    <span class="fu">git</span> clone https://github.com/earthly/example-grpc-key-value-store.git</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">cd</span> example-grpc-key-value-store/go-server</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="ex">earth</span> +kvserver-docker</span></code></pre></div>
<p>Then start up the server in Docker, by running:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">docker</span> run <span class="at">--rm</span> <span class="at">--network</span><span class="op">=</span>host kvserver:latest</span></code></pre></div>
<hr />
<h2 id="next-step-implementing-a-grpc-client-using-python">Next step: Implementing a gRPC Client Using Python</h2>
<p>Now that we’ve built and launched our Go-based key-value-store server, we’ll cover how to talk to it using a Python client. Remember that initial Earthfile that generated the Go code? We’ll extend it to <em>pip install grpc</em> tooling, and generate Python code:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>    proto-py:</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>      <span class="kw">RUN</span> apt-get install -y python3 python3-pip</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>      <span class="kw">RUN</span> pip3 install grpcio grpcio-tools</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">COPY</span> api.proto /defs</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">RUN</span> mkdir /defs/py-api</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">RUN</span> python3 -m grpc_tools.protoc -I /defs --python_out=/defs/py-api \</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>          --grpc_python_out=/defs/py-api /defs/api.proto</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>      SAVE ARTIFACT ./py-api /py-pb AS LOCAL py-pb</span></code></pre></div>
<p>Then we’ll create a client that reads command line arguments, and if the argument contains an equals sign, it will store the value in the server, and otherwise it will retrieve the value from the server:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> sys</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> grpc</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> api_pb2</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> api_pb2_grpc</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    addr <span class="op">=</span> <span class="st">&#39;127.0.0.1:50051&#39;</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(sys.argv) <span class="op">&lt;</span> <span class="dv">2</span>:</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">&#39;program requires arguments in the form key, or key=value&#39;</span>)</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>        sys.exit(<span class="dv">1</span>)</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    channel <span class="op">=</span> grpc.insecure_channel(addr)</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    stub <span class="op">=</span> api_pb2_grpc.KeyValueStub(channel)</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> arg <span class="kw">in</span> sys.argv[<span class="dv">1</span>:]:</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="st">&#39;=&#39;</span> <span class="kw">in</span> arg:</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>            <span class="co"># send a value to the server</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>            key, value <span class="op">=</span> arg.split(<span class="st">&#39;=&#39;</span>)</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">try</span>:</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>                set_request <span class="op">=</span> api_pb2.SetRequest(key<span class="op">=</span>key, value<span class="op">=</span>value)</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>                set_response <span class="op">=</span> stub.Set(set_request)</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">except</span> grpc.RpcError <span class="im">as</span> e:</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>                <span class="bu">print</span>(<span class="ss">f&#39;failed to send key to server: </span><span class="sc">{e.</span>details<span class="sc">}</span><span class="ss">&#39;</span>)</span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>                <span class="bu">print</span>(<span class="ss">f&#39;sent &quot;</span><span class="sc">{</span>key<span class="sc">}</span><span class="ss">&quot; to server&#39;</span>)</span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>            <span class="co"># get a value from the server</span></span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>            key <span class="op">=</span> arg</span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">try</span>:</span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>                get_request <span class="op">=</span> api_pb2.GetRequest(key<span class="op">=</span>key)</span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>                get_response <span class="op">=</span> stub.Get(get_request)</span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">except</span> grpc.RpcError <span class="im">as</span> e:</span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a>                <span class="bu">print</span>(<span class="ss">f&#39;failed to get key from server: </span><span class="sc">{e.</span>details<span class="sc">}</span><span class="ss">&#39;</span>)</span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a>                value <span class="op">=</span> get_response.value</span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a>                <span class="bu">print</span>(<span class="ss">f&#39;server returned value &quot;</span><span class="sc">{</span>value<span class="sc">}</span><span class="ss">&quot; for key &quot;</span><span class="sc">{</span>key<span class="sc">}</span><span class="ss">&quot;&#39;</span>)</span></code></pre></div>
<p>We then store this python code, along with the generated gRPC protobuf code with the following Earthfile:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> python:3</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">RUN</span> pip install grpcio protobuf pycodestyle</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WORKDIR</span> /kvclient</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    code:</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">COPY</span> client.py .</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">COPY</span> ../proto+proto-go/go-pb kvapi</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    lint:</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">FROM</span> +code</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">RUN</span> pycodestyle client.py</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    kvclient-docker:</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">FROM</span> +code</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>        SAVE IMAGE as python-kvclient:latest</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>    all:</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>        BUILD +lint</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>        BUILD +kvclient-docker</span></code></pre></div>
<p>You can give it a try for yourself with the example code:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>    <span class="fu">git</span> clone https://github.com/earthly/example-grpc-key-value-store.git</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">cd</span> example-grpc-key-value-store/python-client</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="ex">earth</span> +kvclient-docker</span></code></pre></div>
<p>Then you can run it and set the weather to sunny with:</p>
<pre><code>    docker run --rm --network=host python-kvclient:latest python3 /kvclient/client.py weather=sunny</code></pre>
<p>And if all went well, you should see some output on both the client and server consoles:</p>
<pre><code>    # client output
    sent &quot;weather&quot; to server
    
    # server output
    2020/11/12 23:15:18 Listening on :50051
    2020/11/12 23:15:34 serving set request for key &quot;weather&quot; and value &quot;sunny&quot;</code></pre>
<hr />
<h2 id="final-step-implementing-a-grpc-client-using-ruby">Final Step: Implementing a gRPC Client Using Ruby</h2>
<p>We’ve come a long ways with our Go and Python gRPC examples, but what if you also wanted to include a Ruby gRPC client implementation too? Well let’s extend our proto Earthfile to generate Ruby protobufs too:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>    proto-rb:</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>      <span class="kw">RUN</span> apt-get install -y ruby</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>      <span class="kw">RUN</span> gem install grpc grpc-tools</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">COPY</span> api.proto /defs</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">RUN</span> mkdir /defs/rb-api</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">RUN</span> grpc_tools_ruby_protoc -I /defs --ruby_out=/defs/rb-api --grpc_out=/defs/rb-api /defs/api.proto</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>      SAVE ARTIFACT ./rb-api /rb-pb AS LOCAL rb-pb</span></code></pre></div>
<p>We can then use this generated Ruby gRPC code with a simple ruby client example that performs a get request for keys listed as command line arguments:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>    <span class="va">$LOAD_PATH</span><span class="at">.unshift</span> <span class="ch">&#39;.&#39;</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">require</span> <span class="vs">&#39;grpc&#39;</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">require</span> <span class="vs">&#39;api_pb&#39;</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">require</span> <span class="vs">&#39;api_services_pb&#39;</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>     </span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    stub <span class="kw">=</span> <span class="dt">Simplekeyvalue</span><span class="kw">::</span><span class="dt">KeyValue</span><span class="kw">::</span><span class="dt">Stub</span><span class="at">.new</span>(</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>      <span class="vs">&#39;127.0.0.1:50051&#39;</span>, <span class="wa">:this_channel_is_insecure</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>     </span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    <span class="cn">ARGV</span><span class="at">.map</span> <span class="cf">do</span> <span class="kw">|</span>arg<span class="kw">|</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>      request <span class="kw">=</span> <span class="dt">Simplekeyvalue</span><span class="kw">::</span><span class="dt">GetRequest</span><span class="at">.new</span>(<span class="wa">key: </span>arg)</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>      response <span class="kw">=</span> stub<span class="at">.get</span>(request)</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>      <span class="fu">puts</span> response<span class="at">.value</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span></code></pre></div>
<pre><code>    git clone https://github.com/earthly/example-grpc-key-value-store.git
    cd example-grpc-key-value-store/ruby-client
    earth +kvclient-docker</code></pre>
<p>Then you can try querying the server to see what the weather was set to:</p>
<pre><code>    docker run --rm --network=host ruby-kvclient:latest ruby /kvclient/client.rb weather</code></pre>
And if all went well, it’ll tell you that it’s sunny outside.
<figure class>
<img src="/blog/assets/images/protobufs-and-grpc/sun.png"
       alt="drawing of the sunn">
<figcaption>
<p>It’s Sunny Outside</p>
</figcaption>
</figure>
<p>So there we go.  You can find the code for the server and the two clients in <a href="https://github.com/earthly/example-grpc-key-value-store">GitHub</a>.</p>

        
      </section>

      


<div itemscope itemtype="https://schema.org/Person">
  <!-- <h5>About The Author</h5> -->

  
    <div class="author__avatar">
      
        <picture class="image-author"><source srcset="/blog/generated/assets/images/authors/alexcouturebeil-240-5d6b0185c.webp 240w" type="image/webp"><source srcset="/blog/generated/assets/images/authors/alexcouturebeil-240-8935b6224.jpg 240w" type="image/jpeg"><img src="/blog/generated/assets/images/authors/alexcouturebeil-240-8935b6224.jpg" alt="Alex Couture-Beil %"></picture>

      
    </div>
  

  <div class="author__content">
    
      <h4 class="author__name" itemprop="name">
        Alex Couture-Beil
    
    
    </h4>
    
      <div class="author__bio" itemprop="description">
        <p>Alex enjoys writing code, growing vegetables, and the great outdoors.</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <!-- <button class="btn btn--inverse">Follow</button> -->
    <ul class="author__urls social-icons">
      

     

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

      <footer class="page__meta">
        
        



  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/blog/categories/tutorials" class="page__taxonomy-item" rel="tag">Tutorials</a>
    
    </span>
  </p>



        
  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2020-11-13T00:00:00-05:00">November 13, 2020</time></p>


      </footer>

      

      
  <nav class="pagination">
    
      <a href="/blog/dont-be-weird/" class="pagination--pager" title="Technology choice? Don’t be weird
">Previous</a>
    
    
      <a href="/blog/youre-using-docker-compose-wrong/" class="pagination--pager" title="You’re using docker-compose wrong
">Next</a>
    
  </nav>

    </div>
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">You may also enjoy</h4>
      <div class="grid__wrapper">
        
          










<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
      <div class="archive__item-teaser">
        <picture><source srcset="/blog/generated/assets/images/python-concatenate-lists/header-600-b885e9e5f.webp 600w, /blog/generated/assets/images/python-concatenate-lists/header-800-b885e9e5f.webp 800w" type="image/webp"><source srcset="/blog/generated/assets/images/python-concatenate-lists/header-600-e31d70141.jpg 600w, /blog/generated/assets/images/python-concatenate-lists/header-800-e31d70141.jpg 800w" type="image/jpeg"><img src="/blog/generated/assets/images/python-concatenate-lists/header-800-e31d70141.jpg"></picture>

      </div>
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/blog/python-concatenate-lists/" rel="permalink">Python Concatenate Lists
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          6 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">


Concatenate Two Lists in Python


Problem: You have two lists and you’d like to join them into a new list. Solution:


Python 3.8.2
&gt;&gt;&gt; one = [&q...</p>
  </article>
</div>

        
          










<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
      <div class="archive__item-teaser">
        <picture><source srcset="/blog/generated/assets/images/g++-makefile/header-600-0b9fb0c93.webp 600w, /blog/generated/assets/images/g++-makefile/header-800-0b9fb0c93.webp 800w" type="image/webp"><source srcset="/blog/generated/assets/images/g++-makefile/header-600-44867ebff.jpg 600w, /blog/generated/assets/images/g++-makefile/header-800-44867ebff.jpg 800w" type="image/jpeg"><img src="/blog/generated/assets/images/g++-makefile/header-800-44867ebff.jpg"></picture>

      </div>
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/blog/g++-makefile/" rel="permalink">Creating a G++ Makefile
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          10 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">
C++ is one of the most dominant programming languages. Although there are many compilers available, GCC still ranks as one of the most popular choices for C...</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
          <li><a href="https://twitter.com/earthlytech" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
        
          <li><a href="https://github.com/earthly/earthly" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
      
    

    
      <li><a href="/blog/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2021 <a href="https://earthly.dev/">Earthly</a>. </div>

      </footer>
    </div>

    <script src="/blog/assets/js/vendor/jquery/jquery-3.5.1.js"></script>
<script src="/blog/assets/js/plugins/jquery.fitvids.js"></script>
<script src="/blog/assets/js/plugins/smooth-scroll.js"></script>
<script src="/blog/assets/js/plugins/gumshoe.js"></script>
<script src="/blog/assets/js/plugins/jquery.magnific-popup.js"></script>
<script src="/blog/assets/js/main.min.js"></script>

  <script> // minified version of https://earthly.dev/assets/js/analytics.js
    function setCookie(e,t,r){var i="";if(r){var o=new Date;o.setTime(o.getTime()+24*r*60*60*1e3),i="; expires="+o.toUTCString()}document.cookie=e+"="+(t||"")+i+"; path=/"}function getCookie(e){for(var t=e+"=",r=document.cookie.split(";"),i=0;i<r.length;i++){for(var o=r[i];" "==o.charAt(0);)o=o.substring(1,o.length);if(0==o.indexOf(t))return o.substring(t.length,o.length)}return null}function uuidv4(){return([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,e=>(e^crypto.getRandomValues(new Uint8Array(1))[0]&15>>e/4).toString(16))}function getAnalyticCookie(){cookieName="earthlyID";var e=getCookie(cookieName);return null==e&&(e=uuidv4()),setCookie(cookieName,e,36500),e}jQuery.ajax({type:"POST",url:"https://api.earthly.dev/analytics",data:JSON.stringify({key:"website",url:window.location.href,referrer:document.referrer,earthlyID:getAnalyticCookie()})});
</script>




  </body>
</html>
