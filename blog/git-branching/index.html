<!doctype html>
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">
<link rel="icon" type="image/png" href="/blog/assets/images/favicon.png">
<!-- begin _includes/seo.html -->





<title>Git Branching Strategies and The Greek Revival - Earthly Blog</title>
<meta name="description" content="Some modern development practices are easiest to understand from a historical perspective: things started a certain way, and then steps were added or removed as conditions changed. Git branching, for example, is like that.   I’m going to explain various git branching strategies with a story. We will start with something straightforward and add complexity as we go. Eventually, we will end up back simple again.   I hope that explaining things this way will give you a deeper understanding of when to use specific branching and merging strategies. So instead of telling you how to cherry-pick a bug fix into a hotfix branch using GitFlow work, I can describe the conditions that would lead to adopting that process. Once you understand the whys, the hows will be easier.   AshelySoft 2006   The year is 2006, and Ashley Protagonist starts a software business. She builds and sells an eCommerce solution she wrote in PHP. It’s just her building and selling it, but she uses a new source control solution called git to store her software. She starts with trunk-based development.   Trunk Based Development   Trunk-based development is working on the main, or trunk branch. Ashley commits her code right into the main branch on her local machine and, when she has complete a feature, she pushes her code to the source control server.   Customers pay for her software, and she emails them a link to the current version as an archive file using git archive. She is a PHP developer, so she whips up a simple PHP script that returns the git archive for the branch requested.      Simple Release Distribution   Her customers then install her software on their web servers, where they use it to run their eCommerce businesses.    MainLine Development   ℹ️ Fun Fact: Trunk VS. Main   If Ashley had chosen subversion or CVS, which were more prevalent in 2006, she would have called her branch trunk because every branch is branched off the trunk like a real-world tree. This is where the term trunk-based development comes from. However, Ashley uses main, so she may prefer the term mainline development. It’s the same thing, just a different name.    Release Branches   Ashley’s business succeeds. She acquires many more customers and hires more developers and a customer-support person. Support becomes problematic, though, as some customers are very slow to upgrade, and it’s unclear what version any given customer is on. Additionally, customers can’t keep up with the latest version when every commit is a new version, and there are no version numbers.   So she decides to batch up the changes into monthly releases and create a new release branch for each revision. Of course, she could use tags for these releases, but branches and tags are pretty similar, and she already has her release script in place.   Now her support people can ask customers what version they are on. If it’s more than two releases back, they ask them to upgrade. That is, AshelySoft only supports the current release and the two previous versions.    Cutting a Release   There was a time before modern source control when creating a release branch was an expensive process that had to be planned. “Cutting a Release” was the name for this process, which involved locking down the source and starting the lengthy process of ‘cutting a release branch off the trunk’. People still use the phrase today.    “Well, the performance was so bad that when they wanted to cut a branch, they would announce it ahead of time. They would schedule the branching because you didn’t want anybody else committing while you were branching, because that would totally screw things up. Right? And I said,”Okay, Friday at 2:00 pm., we’re going to cut the branch.&quot; Then all activity would stop, access to the server would be cut off.&quot;   And it would take 45 minutes to cut this branch. And then you’d say, “Okay, we’ve opened up the branch. Everybody can start working again.”   Jim Blandy creator of Subversion     Hot Fixes and the Multiverse   This is all working great. Ashley starts scaling the development team, and they start shipping more features. Unfortunately, while each monthly release now contains more cool new features, more regressions and bugs start slipping into the releases as well.   Some customers respond to this by not upgrading right away. If they are well-served by the current product, they can stay two releases back and get active support while giving the latest release time to stabilize. Bugs do show up in the old versions, though, and this is where things get interesting.   Up until now, time, as viewed by AshelySoft’s source control, moves forward in a single line. There is one main branch that represents one linear release timeline. But now, when bugs are found, they need to be addressed in multiple versions of the product. And you can’t simply ask people to upgrade because they are still on a supported version, and they are correctly worried about the quality of the latest release. They want the version they have plus the bug fixes, with no new development.   You are now in the hot fixing multiverse. AshelySoft has to fix bugs in the latest version and all other active versions. Each release is a separate timeline where active development ceased at the release date, but bugs continued to be fixed.   If you’ve seen any time travel movies, you probably realize that this can get complex. What if a bug fix to back release introduces a bug of its own? Thankfully AshelySoft is only supporting two active versions back and only supporting them for a couple of months. Suppose they were supporting back versions for several years. In that case, they might find themselves spending more and more time maintaining all these versions, and the various versions would slowly drift away from each other.   Nevertheless, release branches are an enormous help for AshelySoft. They help customers stay on a version that works for them, while AshelySoft can still push new features. However, it does increase the amount of effort that fixing bugs requires, and dealing with that will lead to AshelySoft’s next innovation.   The develop Branch   The cost of shipping bugs has now increased for AshelySoft. In the worse case, a bug isn’t discovered until it’s in all active versions of the software and the code between versions has changed enough that the fix is slightly different in each version, tripling the bug fix cost.   Fortunately, a solution for this does exist: Continuing with our time travel/multiverse analogy, we need to travel back in time and stop the bug before our releases branches off the main timeline. Unfortunately, AshelySoft does not have access to literal time travel machines, but Ashley has a more straightforward idea: Catch the bugs before they are released.   GitFlow to the Rescue   A popular branching method called GitFlow has excellent suggestions for achieving this: you create a develop branch. So now all new work goes into develop, and instead of 4 weeks of development in each release, you spend the last week stabilizing develop. You make sure develop has no bugs as best you can, and when it seems stable, you merge it into main and then cut a release branch off main.    “We consider origin/develop to be the main branch where the source code of HEAD always reflects a state with the latest delivered development changes for the next release. Some would call this the”integration branch“. This is where any automatic nightly builds are built from.”   “When the source code in the develop branch reaches a stable point and is ready to be released, all of the changes should be merged back into master somehow and then tagged with a release number.”   GitFlow Explanation    This whole process adds more overhead to the branching and release process, but it’s a fixed cost overhead, and it saves a lot of HotFixing bugs on release branches. AshelySoft, following the git-flow model, also adds a continuous integration service. When new code shows up in develop, automated tests are run.   This setup, git-flow and CI on develop branch, with release branches and hot fixing serves AshelySoft for several years. However, it is a complicated process. Thankfully, from here on out, AshelySoft’s process will only get simpler. The first thing that helps to simplify things is The Cloud™️.   The Cloud   AshelySoft customers want to run an eCommerce store. However, they don’t want to run a web server. After repeatedly getting this feedback, Ashley shifts the company to be a Software-As-A-Service (SAAS) company. It takes some extensive work, but AshelySoft eCommerce becomes a multi-tenant eCommerce platform. No more git archive releases. Now the release process is deploying the latest version of the main branch onto the production server.   There are downsides to this SAAS model. AshelySoft now owns the uptime of all their customers, and this is eCommerce, so real money is lost when things go down. But, the customers are willing to pay more for AshelySoft to worry about these problems. They no longer have to support multi releases at a time - no more hot fixing bugs back into old versions, no more multiverse of drifting branches to update, and no more release branches. To make this work, AshelySoft works off a simple rule: main must be releasable. Before anyone can merge develop into main they must make sure the continuous integration build is passing, and if they find problems that the CI process missed, they do their best to make sure CI will catch it in the future.   GitHub Flow   Around this time, GitHub private repositories appear, and AshelySoft moves from their own git hosting to GitHub and starts following a Pull Request process. Instead of pushing code straight into develop and then ensuring they didn’t break the build, developers now create pull-requests. Other team members review the pull-requests, and the continuous integration service runs its suite of tests right on the PR. As a result, the speed of getting code into develop has decreased, but with each PR being manually reviewed and automatically tested, the quality of code that makes it into the develop branch is way up.   Death to develop   With the quality of develop now increased, AshelySoft can increase its release velocity. They even adopt a continuous deployment model where a merge into main causes the software to be automatically deployed. From there, they move to a Canary deployment model where a new release is tested on a small portion of web traffic before it’s fully deployed. Once a PR is merged, Ashley just has to merge develop into main to perform a release.   But what is the point of having develop and merging it into main? It was introduced to prevent the release of bugs by giving the software time to ‘integrate’, but AshelySoft is doing all the integration as part of the PR process. So they drop the develop branch.   Ashley has come a long way but sometimes what is old is new again. She is now back to doing trunk-based or mainline development. Just like when she built the first version: features go into main, and the HEAD of main is constantly released.   Lessons Learned   There is a lot about git merging strategies, continuous integration, and deployment that doesn’t seem to make sense without going through a long journey like Ashely’s.   For instance, calling software that builds and tests code a continuous integration process only makes sense when you understand what non-continuous integration was. It was spending time manually testing the upcoming release for days or even weeks before feeling confident enough to release it.   Ashely’s story is fictional, and history didn’t necessarily unfold this way for all or even most software shops, but I think it’s helpful to understand where we are coming from and how cloud and SAAS workflows influence branching models.   Some software always had an extensive review process, and much software will never be cloud-based and will continue to deal with release branches and backporting fixes. But some software has moved to the cloud and yet hasn’t embraced the simplified workflows that cloud deployment can enable.   Appendix: Develop and The Greek Revival Style      The Parthenon was built in ancient Greece using columns of marble. These columns of marble held it up.      This is a greek-revival style house. These columns are not about function but form – they are unnecessary and were chosen for aesthetic purposes.   If you don’t need to maintain and support multiple versions of your software and it only runs on your servers, then you might have a purely decorative develop branch. You may be using a git branching model that is very effective for a software lifecycle that you yourself are not in fact practicing. Those might not be load-bearing functional columns – you might be copying the visual appearance of the ancients without understanding the purpose they had in mind.   The creator of GitFlow offers similar thoughts:    Web apps are typically continuously delivered, not rolled back, and you don’t have to support multiple versions of the software running in the wild.   If your team is doing continuous delivery of software, I would suggest to adopt a much simpler workflow (like GitHub flow) instead of trying to shoehorn git-flow into your team.   GitFlow Creator Vincent Driessen    The closer you can stay to trunk-based or mainline development, the less overhead you will have and the smaller the batches you’ll be able to release.">


  <meta name="author" content="Adam Gordon Bell">
  
  <meta property="article:author" content="Adam Gordon Bell">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Earthly Blog">
<meta property="og:title" content="Git Branching Strategies and The Greek Revival">
<meta property="og:url" content="https://earthly.dev/blog/git-branching/">


  <meta property="og:description" content="Some modern development practices are easiest to understand from a historical perspective: things started a certain way, and then steps were added or removed as conditions changed. Git branching, for example, is like that.   I’m going to explain various git branching strategies with a story. We will start with something straightforward and add complexity as we go. Eventually, we will end up back simple again.   I hope that explaining things this way will give you a deeper understanding of when to use specific branching and merging strategies. So instead of telling you how to cherry-pick a bug fix into a hotfix branch using GitFlow work, I can describe the conditions that would lead to adopting that process. Once you understand the whys, the hows will be easier.   AshelySoft 2006   The year is 2006, and Ashley Protagonist starts a software business. She builds and sells an eCommerce solution she wrote in PHP. It’s just her building and selling it, but she uses a new source control solution called git to store her software. She starts with trunk-based development.   Trunk Based Development   Trunk-based development is working on the main, or trunk branch. Ashley commits her code right into the main branch on her local machine and, when she has complete a feature, she pushes her code to the source control server.   Customers pay for her software, and she emails them a link to the current version as an archive file using git archive. She is a PHP developer, so she whips up a simple PHP script that returns the git archive for the branch requested.      Simple Release Distribution   Her customers then install her software on their web servers, where they use it to run their eCommerce businesses.    MainLine Development   ℹ️ Fun Fact: Trunk VS. Main   If Ashley had chosen subversion or CVS, which were more prevalent in 2006, she would have called her branch trunk because every branch is branched off the trunk like a real-world tree. This is where the term trunk-based development comes from. However, Ashley uses main, so she may prefer the term mainline development. It’s the same thing, just a different name.    Release Branches   Ashley’s business succeeds. She acquires many more customers and hires more developers and a customer-support person. Support becomes problematic, though, as some customers are very slow to upgrade, and it’s unclear what version any given customer is on. Additionally, customers can’t keep up with the latest version when every commit is a new version, and there are no version numbers.   So she decides to batch up the changes into monthly releases and create a new release branch for each revision. Of course, she could use tags for these releases, but branches and tags are pretty similar, and she already has her release script in place.   Now her support people can ask customers what version they are on. If it’s more than two releases back, they ask them to upgrade. That is, AshelySoft only supports the current release and the two previous versions.    Cutting a Release   There was a time before modern source control when creating a release branch was an expensive process that had to be planned. “Cutting a Release” was the name for this process, which involved locking down the source and starting the lengthy process of ‘cutting a release branch off the trunk’. People still use the phrase today.    “Well, the performance was so bad that when they wanted to cut a branch, they would announce it ahead of time. They would schedule the branching because you didn’t want anybody else committing while you were branching, because that would totally screw things up. Right? And I said,”Okay, Friday at 2:00 pm., we’re going to cut the branch.&quot; Then all activity would stop, access to the server would be cut off.&quot;   And it would take 45 minutes to cut this branch. And then you’d say, “Okay, we’ve opened up the branch. Everybody can start working again.”   Jim Blandy creator of Subversion     Hot Fixes and the Multiverse   This is all working great. Ashley starts scaling the development team, and they start shipping more features. Unfortunately, while each monthly release now contains more cool new features, more regressions and bugs start slipping into the releases as well.   Some customers respond to this by not upgrading right away. If they are well-served by the current product, they can stay two releases back and get active support while giving the latest release time to stabilize. Bugs do show up in the old versions, though, and this is where things get interesting.   Up until now, time, as viewed by AshelySoft’s source control, moves forward in a single line. There is one main branch that represents one linear release timeline. But now, when bugs are found, they need to be addressed in multiple versions of the product. And you can’t simply ask people to upgrade because they are still on a supported version, and they are correctly worried about the quality of the latest release. They want the version they have plus the bug fixes, with no new development.   You are now in the hot fixing multiverse. AshelySoft has to fix bugs in the latest version and all other active versions. Each release is a separate timeline where active development ceased at the release date, but bugs continued to be fixed.   If you’ve seen any time travel movies, you probably realize that this can get complex. What if a bug fix to back release introduces a bug of its own? Thankfully AshelySoft is only supporting two active versions back and only supporting them for a couple of months. Suppose they were supporting back versions for several years. In that case, they might find themselves spending more and more time maintaining all these versions, and the various versions would slowly drift away from each other.   Nevertheless, release branches are an enormous help for AshelySoft. They help customers stay on a version that works for them, while AshelySoft can still push new features. However, it does increase the amount of effort that fixing bugs requires, and dealing with that will lead to AshelySoft’s next innovation.   The develop Branch   The cost of shipping bugs has now increased for AshelySoft. In the worse case, a bug isn’t discovered until it’s in all active versions of the software and the code between versions has changed enough that the fix is slightly different in each version, tripling the bug fix cost.   Fortunately, a solution for this does exist: Continuing with our time travel/multiverse analogy, we need to travel back in time and stop the bug before our releases branches off the main timeline. Unfortunately, AshelySoft does not have access to literal time travel machines, but Ashley has a more straightforward idea: Catch the bugs before they are released.   GitFlow to the Rescue   A popular branching method called GitFlow has excellent suggestions for achieving this: you create a develop branch. So now all new work goes into develop, and instead of 4 weeks of development in each release, you spend the last week stabilizing develop. You make sure develop has no bugs as best you can, and when it seems stable, you merge it into main and then cut a release branch off main.    “We consider origin/develop to be the main branch where the source code of HEAD always reflects a state with the latest delivered development changes for the next release. Some would call this the”integration branch“. This is where any automatic nightly builds are built from.”   “When the source code in the develop branch reaches a stable point and is ready to be released, all of the changes should be merged back into master somehow and then tagged with a release number.”   GitFlow Explanation    This whole process adds more overhead to the branching and release process, but it’s a fixed cost overhead, and it saves a lot of HotFixing bugs on release branches. AshelySoft, following the git-flow model, also adds a continuous integration service. When new code shows up in develop, automated tests are run.   This setup, git-flow and CI on develop branch, with release branches and hot fixing serves AshelySoft for several years. However, it is a complicated process. Thankfully, from here on out, AshelySoft’s process will only get simpler. The first thing that helps to simplify things is The Cloud™️.   The Cloud   AshelySoft customers want to run an eCommerce store. However, they don’t want to run a web server. After repeatedly getting this feedback, Ashley shifts the company to be a Software-As-A-Service (SAAS) company. It takes some extensive work, but AshelySoft eCommerce becomes a multi-tenant eCommerce platform. No more git archive releases. Now the release process is deploying the latest version of the main branch onto the production server.   There are downsides to this SAAS model. AshelySoft now owns the uptime of all their customers, and this is eCommerce, so real money is lost when things go down. But, the customers are willing to pay more for AshelySoft to worry about these problems. They no longer have to support multi releases at a time - no more hot fixing bugs back into old versions, no more multiverse of drifting branches to update, and no more release branches. To make this work, AshelySoft works off a simple rule: main must be releasable. Before anyone can merge develop into main they must make sure the continuous integration build is passing, and if they find problems that the CI process missed, they do their best to make sure CI will catch it in the future.   GitHub Flow   Around this time, GitHub private repositories appear, and AshelySoft moves from their own git hosting to GitHub and starts following a Pull Request process. Instead of pushing code straight into develop and then ensuring they didn’t break the build, developers now create pull-requests. Other team members review the pull-requests, and the continuous integration service runs its suite of tests right on the PR. As a result, the speed of getting code into develop has decreased, but with each PR being manually reviewed and automatically tested, the quality of code that makes it into the develop branch is way up.   Death to develop   With the quality of develop now increased, AshelySoft can increase its release velocity. They even adopt a continuous deployment model where a merge into main causes the software to be automatically deployed. From there, they move to a Canary deployment model where a new release is tested on a small portion of web traffic before it’s fully deployed. Once a PR is merged, Ashley just has to merge develop into main to perform a release.   But what is the point of having develop and merging it into main? It was introduced to prevent the release of bugs by giving the software time to ‘integrate’, but AshelySoft is doing all the integration as part of the PR process. So they drop the develop branch.   Ashley has come a long way but sometimes what is old is new again. She is now back to doing trunk-based or mainline development. Just like when she built the first version: features go into main, and the HEAD of main is constantly released.   Lessons Learned   There is a lot about git merging strategies, continuous integration, and deployment that doesn’t seem to make sense without going through a long journey like Ashely’s.   For instance, calling software that builds and tests code a continuous integration process only makes sense when you understand what non-continuous integration was. It was spending time manually testing the upcoming release for days or even weeks before feeling confident enough to release it.   Ashely’s story is fictional, and history didn’t necessarily unfold this way for all or even most software shops, but I think it’s helpful to understand where we are coming from and how cloud and SAAS workflows influence branching models.   Some software always had an extensive review process, and much software will never be cloud-based and will continue to deal with release branches and backporting fixes. But some software has moved to the cloud and yet hasn’t embraced the simplified workflows that cloud deployment can enable.   Appendix: Develop and The Greek Revival Style      The Parthenon was built in ancient Greece using columns of marble. These columns of marble held it up.      This is a greek-revival style house. These columns are not about function but form – they are unnecessary and were chosen for aesthetic purposes.   If you don’t need to maintain and support multiple versions of your software and it only runs on your servers, then you might have a purely decorative develop branch. You may be using a git branching model that is very effective for a software lifecycle that you yourself are not in fact practicing. Those might not be load-bearing functional columns – you might be copying the visual appearance of the ancients without understanding the purpose they had in mind.   The creator of GitFlow offers similar thoughts:    Web apps are typically continuously delivered, not rolled back, and you don’t have to support multiple versions of the software running in the wild.   If your team is doing continuous delivery of software, I would suggest to adopt a much simpler workflow (like GitHub flow) instead of trying to shoehorn git-flow into your team.   GitFlow Creator Vincent Driessen    The closer you can stay to trunk-based or mainline development, the less overhead you will have and the smaller the batches you’ll be able to release.">



  <meta property="og:image" content="/blog/generated/assets/images/git-branching/header-800-e090739ca.jpg">



  <meta name="twitter:site" content="@EarthlyTech">
  <meta name="twitter:title" content="Git Branching Strategies and The Greek Revival">
  <meta name="twitter:description" content="Some modern development practices are easiest to understand from a historical perspective: things started a certain way, and then steps were added or removed as conditions changed. Git branching, for example, is like that.   I’m going to explain various git branching strategies with a story. We will start with something straightforward and add complexity as we go. Eventually, we will end up back simple again.   I hope that explaining things this way will give you a deeper understanding of when to use specific branching and merging strategies. So instead of telling you how to cherry-pick a bug fix into a hotfix branch using GitFlow work, I can describe the conditions that would lead to adopting that process. Once you understand the whys, the hows will be easier.   AshelySoft 2006   The year is 2006, and Ashley Protagonist starts a software business. She builds and sells an eCommerce solution she wrote in PHP. It’s just her building and selling it, but she uses a new source control solution called git to store her software. She starts with trunk-based development.   Trunk Based Development   Trunk-based development is working on the main, or trunk branch. Ashley commits her code right into the main branch on her local machine and, when she has complete a feature, she pushes her code to the source control server.   Customers pay for her software, and she emails them a link to the current version as an archive file using git archive. She is a PHP developer, so she whips up a simple PHP script that returns the git archive for the branch requested.      Simple Release Distribution   Her customers then install her software on their web servers, where they use it to run their eCommerce businesses.    MainLine Development   ℹ️ Fun Fact: Trunk VS. Main   If Ashley had chosen subversion or CVS, which were more prevalent in 2006, she would have called her branch trunk because every branch is branched off the trunk like a real-world tree. This is where the term trunk-based development comes from. However, Ashley uses main, so she may prefer the term mainline development. It’s the same thing, just a different name.    Release Branches   Ashley’s business succeeds. She acquires many more customers and hires more developers and a customer-support person. Support becomes problematic, though, as some customers are very slow to upgrade, and it’s unclear what version any given customer is on. Additionally, customers can’t keep up with the latest version when every commit is a new version, and there are no version numbers.   So she decides to batch up the changes into monthly releases and create a new release branch for each revision. Of course, she could use tags for these releases, but branches and tags are pretty similar, and she already has her release script in place.   Now her support people can ask customers what version they are on. If it’s more than two releases back, they ask them to upgrade. That is, AshelySoft only supports the current release and the two previous versions.    Cutting a Release   There was a time before modern source control when creating a release branch was an expensive process that had to be planned. “Cutting a Release” was the name for this process, which involved locking down the source and starting the lengthy process of ‘cutting a release branch off the trunk’. People still use the phrase today.    “Well, the performance was so bad that when they wanted to cut a branch, they would announce it ahead of time. They would schedule the branching because you didn’t want anybody else committing while you were branching, because that would totally screw things up. Right? And I said,”Okay, Friday at 2:00 pm., we’re going to cut the branch.&quot; Then all activity would stop, access to the server would be cut off.&quot;   And it would take 45 minutes to cut this branch. And then you’d say, “Okay, we’ve opened up the branch. Everybody can start working again.”   Jim Blandy creator of Subversion     Hot Fixes and the Multiverse   This is all working great. Ashley starts scaling the development team, and they start shipping more features. Unfortunately, while each monthly release now contains more cool new features, more regressions and bugs start slipping into the releases as well.   Some customers respond to this by not upgrading right away. If they are well-served by the current product, they can stay two releases back and get active support while giving the latest release time to stabilize. Bugs do show up in the old versions, though, and this is where things get interesting.   Up until now, time, as viewed by AshelySoft’s source control, moves forward in a single line. There is one main branch that represents one linear release timeline. But now, when bugs are found, they need to be addressed in multiple versions of the product. And you can’t simply ask people to upgrade because they are still on a supported version, and they are correctly worried about the quality of the latest release. They want the version they have plus the bug fixes, with no new development.   You are now in the hot fixing multiverse. AshelySoft has to fix bugs in the latest version and all other active versions. Each release is a separate timeline where active development ceased at the release date, but bugs continued to be fixed.   If you’ve seen any time travel movies, you probably realize that this can get complex. What if a bug fix to back release introduces a bug of its own? Thankfully AshelySoft is only supporting two active versions back and only supporting them for a couple of months. Suppose they were supporting back versions for several years. In that case, they might find themselves spending more and more time maintaining all these versions, and the various versions would slowly drift away from each other.   Nevertheless, release branches are an enormous help for AshelySoft. They help customers stay on a version that works for them, while AshelySoft can still push new features. However, it does increase the amount of effort that fixing bugs requires, and dealing with that will lead to AshelySoft’s next innovation.   The develop Branch   The cost of shipping bugs has now increased for AshelySoft. In the worse case, a bug isn’t discovered until it’s in all active versions of the software and the code between versions has changed enough that the fix is slightly different in each version, tripling the bug fix cost.   Fortunately, a solution for this does exist: Continuing with our time travel/multiverse analogy, we need to travel back in time and stop the bug before our releases branches off the main timeline. Unfortunately, AshelySoft does not have access to literal time travel machines, but Ashley has a more straightforward idea: Catch the bugs before they are released.   GitFlow to the Rescue   A popular branching method called GitFlow has excellent suggestions for achieving this: you create a develop branch. So now all new work goes into develop, and instead of 4 weeks of development in each release, you spend the last week stabilizing develop. You make sure develop has no bugs as best you can, and when it seems stable, you merge it into main and then cut a release branch off main.    “We consider origin/develop to be the main branch where the source code of HEAD always reflects a state with the latest delivered development changes for the next release. Some would call this the”integration branch“. This is where any automatic nightly builds are built from.”   “When the source code in the develop branch reaches a stable point and is ready to be released, all of the changes should be merged back into master somehow and then tagged with a release number.”   GitFlow Explanation    This whole process adds more overhead to the branching and release process, but it’s a fixed cost overhead, and it saves a lot of HotFixing bugs on release branches. AshelySoft, following the git-flow model, also adds a continuous integration service. When new code shows up in develop, automated tests are run.   This setup, git-flow and CI on develop branch, with release branches and hot fixing serves AshelySoft for several years. However, it is a complicated process. Thankfully, from here on out, AshelySoft’s process will only get simpler. The first thing that helps to simplify things is The Cloud™️.   The Cloud   AshelySoft customers want to run an eCommerce store. However, they don’t want to run a web server. After repeatedly getting this feedback, Ashley shifts the company to be a Software-As-A-Service (SAAS) company. It takes some extensive work, but AshelySoft eCommerce becomes a multi-tenant eCommerce platform. No more git archive releases. Now the release process is deploying the latest version of the main branch onto the production server.   There are downsides to this SAAS model. AshelySoft now owns the uptime of all their customers, and this is eCommerce, so real money is lost when things go down. But, the customers are willing to pay more for AshelySoft to worry about these problems. They no longer have to support multi releases at a time - no more hot fixing bugs back into old versions, no more multiverse of drifting branches to update, and no more release branches. To make this work, AshelySoft works off a simple rule: main must be releasable. Before anyone can merge develop into main they must make sure the continuous integration build is passing, and if they find problems that the CI process missed, they do their best to make sure CI will catch it in the future.   GitHub Flow   Around this time, GitHub private repositories appear, and AshelySoft moves from their own git hosting to GitHub and starts following a Pull Request process. Instead of pushing code straight into develop and then ensuring they didn’t break the build, developers now create pull-requests. Other team members review the pull-requests, and the continuous integration service runs its suite of tests right on the PR. As a result, the speed of getting code into develop has decreased, but with each PR being manually reviewed and automatically tested, the quality of code that makes it into the develop branch is way up.   Death to develop   With the quality of develop now increased, AshelySoft can increase its release velocity. They even adopt a continuous deployment model where a merge into main causes the software to be automatically deployed. From there, they move to a Canary deployment model where a new release is tested on a small portion of web traffic before it’s fully deployed. Once a PR is merged, Ashley just has to merge develop into main to perform a release.   But what is the point of having develop and merging it into main? It was introduced to prevent the release of bugs by giving the software time to ‘integrate’, but AshelySoft is doing all the integration as part of the PR process. So they drop the develop branch.   Ashley has come a long way but sometimes what is old is new again. She is now back to doing trunk-based or mainline development. Just like when she built the first version: features go into main, and the HEAD of main is constantly released.   Lessons Learned   There is a lot about git merging strategies, continuous integration, and deployment that doesn’t seem to make sense without going through a long journey like Ashely’s.   For instance, calling software that builds and tests code a continuous integration process only makes sense when you understand what non-continuous integration was. It was spending time manually testing the upcoming release for days or even weeks before feeling confident enough to release it.   Ashely’s story is fictional, and history didn’t necessarily unfold this way for all or even most software shops, but I think it’s helpful to understand where we are coming from and how cloud and SAAS workflows influence branching models.   Some software always had an extensive review process, and much software will never be cloud-based and will continue to deal with release branches and backporting fixes. But some software has moved to the cloud and yet hasn’t embraced the simplified workflows that cloud deployment can enable.   Appendix: Develop and The Greek Revival Style      The Parthenon was built in ancient Greece using columns of marble. These columns of marble held it up.      This is a greek-revival style house. These columns are not about function but form – they are unnecessary and were chosen for aesthetic purposes.   If you don’t need to maintain and support multiple versions of your software and it only runs on your servers, then you might have a purely decorative develop branch. You may be using a git branching model that is very effective for a software lifecycle that you yourself are not in fact practicing. Those might not be load-bearing functional columns – you might be copying the visual appearance of the ancients without understanding the purpose they had in mind.   The creator of GitFlow offers similar thoughts:    Web apps are typically continuously delivered, not rolled back, and you don’t have to support multiple versions of the software running in the wild.   If your team is doing continuous delivery of software, I would suggest to adopt a much simpler workflow (like GitHub flow) instead of trying to shoehorn git-flow into your team.   GitFlow Creator Vincent Driessen    The closer you can stay to trunk-based or mainline development, the less overhead you will have and the smaller the batches you’ll be able to release.">
  <meta name="twitter:url" content="https://earthly.dev/blog/git-branching/">

  
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://earthly.dev/blog/generated/assets/images/git-branching/header-800-e090739ca.jpg">
  

  



  <meta property="article:published_time" content="2021-06-16T00:00:00-04:00">





  

  


<link rel="canonical" href="https://earthly.dev/blog/git-branching/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Organization",
      "url": "https://earthly.dev/blog/",
      "logo": "/assets/images/logo-header.png"
    
  }
</script>






<!-- end _includes/seo.html -->



  <link href="/blog/feed.xml" type="application/atom+xml" rel="alternate" title="Earthly Blog Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/blog/assets/css/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->


  
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-161831101-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-161831101-5');
</script>
  <!-- Facebook Pixel Code -->
<script>
    !function(f,b,e,v,n,t,s)
    {if(f.fbq)return;n=f.fbq=function(){n.callMethod?
    n.callMethod.apply(n,arguments):n.queue.push(arguments)};
    if(!f._fbq)f._fbq=n;n.push=n;n.loaded=!0;n.version='2.0';
    n.queue=[];t=b.createElement(e);t.async=!0;
    t.src=v;s=b.getElementsByTagName(e)[0];
    s.parentNode.insertBefore(t,s)}(window, document,'script',
    'https://connect.facebook.net/en_US/fbevents.js');
    fbq('init', '259843109045285');
    fbq('track', 'PageView');
    </script>
    <noscript><img height="1" width="1" style="display:none"
    src="https://www.facebook.com/tr?id=259843109045285&ev=PageView&noscript=1"
    />
</noscript>
 <!-- End Facebook Pixel Code -->
  <!-- Twitter universal website tag code -->
<script>
  !function(e,t,n,s,u,a){e.twq||(s=e.twq=function(){s.exe?s.exe.apply(s,arguments):s.queue.push(arguments);
  },s.version='1.1',s.queue=[],u=t.createElement(n),u.async=!0,u.src='//static.ads-twitter.com/uwt.js',
  a=t.getElementsByTagName(n)[0],a.parentNode.insertBefore(u,a))}(window,document,'script');
  // Insert Twitter Pixel ID and Standard Event data below
  twq('init','o5s6p');
  twq('track','PageView');
  </script>
  <!-- End Twitter universal website tag code -->


  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/"><img src="/blog/assets/images/white-logo.png" alt="Earthly"></a>
        
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/blog/">Blog home</a>
            </li><li class="masthead__menu-item">
              <a href="/blog/categories/articles/">Articles</a>
            </li><li class="masthead__menu-item">
              <a href="/blog/categories/news/">News</a>
            </li><li class="masthead__menu-item">
              <a href="/blog/categories/tutorials/">Tutorials</a>
            </li><li class="masthead__menu-item">
              <a href="https://github.com/earthly/earthly">GitHub</a>
            </li></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      




  







<div class="page__hero"
  style=" background-image: url('');"
>
  
      <picture class="page__hero-image"><source srcset="/blog/generated/assets/images/git-branching/header-400-e7af3c76e.webp 400w, /blog/generated/assets/images/git-branching/header-600-e7af3c76e.webp 600w, /blog/generated/assets/images/git-branching/header-800-e7af3c76e.webp 800w, /blog/generated/assets/images/git-branching/header-1000-e7af3c76e.webp 1000w, /blog/generated/assets/images/git-branching/header-1200-e7af3c76e.webp 1200w" type="image/webp"><source srcset="/blog/generated/assets/images/git-branching/header-400-e7af3c76e.png 400w, /blog/generated/assets/images/git-branching/header-600-e7af3c76e.png 600w, /blog/generated/assets/images/git-branching/header-800-e7af3c76e.png 800w, /blog/generated/assets/images/git-branching/header-1000-e7af3c76e.png 1000w, /blog/generated/assets/images/git-branching/header-1200-e7af3c76e.png 1200w" type="image/png"><img src="/blog/generated/assets/images/git-branching/header-800-e7af3c76e.jpg" alt="Git Branching Strategies and The Greek Revival"></picture>

  
  
</div>





<div id="main" role="main">
  
  <div class="sidebar">
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Git Branching Strategies and The Greek Revival">
    <meta itemprop="description" content="Some modern development practices are easiest to understand from a historical perspective: things started a certain way, and then steps were added or removed as conditions changed. Git branching, for example, is like that.I’m going to explain various git branching strategies with a story. We will start with something straightforward and add complexity as we go. Eventually, we will end up back simple again.I hope that explaining things this way will give you a deeper understanding of when to use specific branching and merging strategies. So instead of telling you how to cherry-pick a bug fix into a hotfix branch using GitFlow work, I can describe the conditions that would lead to adopting that process. Once you understand the whys, the hows will be easier.AshelySoft 2006The year is 2006, and Ashley Protagonist starts a software business. She builds and sells an eCommerce solution she wrote in PHP. It’s just her building and selling it, but she uses a new source control solution called git to store her software. She starts with trunk-based development.Trunk Based DevelopmentTrunk-based development is working on the main, or trunk branch. Ashley commits her code right into the main branch on her local machine and, when she has complete a feature, she pushes her code to the source control server.Customers pay for her software, and she emails them a link to the current version as an archive file using git archive. She is a PHP developer, so she whips up a simple PHP script that returns the git archive for the branch requested.Simple Release DistributionHer customers then install her software on their web servers, where they use it to run their eCommerce businesses.MainLine Developmentℹ️ Fun Fact: Trunk VS. MainIf Ashley had chosen subversion or CVS, which were more prevalent in 2006, she would have called her branch trunk because every branch is branched off the trunk like a real-world tree. This is where the term trunk-based development comes from. However, Ashley uses main, so she may prefer the term mainline development. It’s the same thing, just a different name.Release BranchesAshley’s business succeeds. She acquires many more customers and hires more developers and a customer-support person. Support becomes problematic, though, as some customers are very slow to upgrade, and it’s unclear what version any given customer is on. Additionally, customers can’t keep up with the latest version when every commit is a new version, and there are no version numbers.So she decides to batch up the changes into monthly releases and create a new release branch for each revision. Of course, she could use tags for these releases, but branches and tags are pretty similar, and she already has her release script in place.Now her support people can ask customers what version they are on. If it’s more than two releases back, they ask them to upgrade. That is, AshelySoft only supports the current release and the two previous versions.Cutting a ReleaseThere was a time before modern source control when creating a release branch was an expensive process that had to be planned. “Cutting a Release” was the name for this process, which involved locking down the source and starting the lengthy process of ‘cutting a release branch off the trunk’. People still use the phrase today.“Well, the performance was so bad that when they wanted to cut a branch, they would announce it ahead of time. They would schedule the branching because you didn’t want anybody else committing while you were branching, because that would totally screw things up. Right? And I said,”Okay, Friday at 2:00 pm., we’re going to cut the branch.&quot; Then all activity would stop, access to the server would be cut off.&quot;And it would take 45 minutes to cut this branch. And then you’d say, “Okay, we’ve opened up the branch. Everybody can start working again.”Jim Blandy creator of SubversionHot Fixes and the MultiverseThis is all working great. Ashley starts scaling the development team, and they start shipping more features. Unfortunately, while each monthly release now contains more cool new features, more regressions and bugs start slipping into the releases as well.Some customers respond to this by not upgrading right away. If they are well-served by the current product, they can stay two releases back and get active support while giving the latest release time to stabilize. Bugs do show up in the old versions, though, and this is where things get interesting.Up until now, time, as viewed by AshelySoft’s source control, moves forward in a single line. There is one main branch that represents one linear release timeline. But now, when bugs are found, they need to be addressed in multiple versions of the product. And you can’t simply ask people to upgrade because they are still on a supported version, and they are correctly worried about the quality of the latest release. They want the version they have plus the bug fixes, with no new development.You are now in the hot fixing multiverse. AshelySoft has to fix bugs in the latest version and all other active versions. Each release is a separate timeline where active development ceased at the release date, but bugs continued to be fixed.If you’ve seen any time travel movies, you probably realize that this can get complex. What if a bug fix to back release introduces a bug of its own? Thankfully AshelySoft is only supporting two active versions back and only supporting them for a couple of months. Suppose they were supporting back versions for several years. In that case, they might find themselves spending more and more time maintaining all these versions, and the various versions would slowly drift away from each other.Nevertheless, release branches are an enormous help for AshelySoft. They help customers stay on a version that works for them, while AshelySoft can still push new features. However, it does increase the amount of effort that fixing bugs requires, and dealing with that will lead to AshelySoft’s next innovation.The develop BranchThe cost of shipping bugs has now increased for AshelySoft. In the worse case, a bug isn’t discovered until it’s in all active versions of the software and the code between versions has changed enough that the fix is slightly different in each version, tripling the bug fix cost.Fortunately, a solution for this does exist: Continuing with our time travel/multiverse analogy, we need to travel back in time and stop the bug before our releases branches off the main timeline. Unfortunately, AshelySoft does not have access to literal time travel machines, but Ashley has a more straightforward idea: Catch the bugs before they are released.GitFlow to the RescueA popular branching method called GitFlow has excellent suggestions for achieving this: you create a develop branch. So now all new work goes into develop, and instead of 4 weeks of development in each release, you spend the last week stabilizing develop. You make sure develop has no bugs as best you can, and when it seems stable, you merge it into main and then cut a release branch off main.“We consider origin/develop to be the main branch where the source code of HEAD always reflects a state with the latest delivered development changes for the next release. Some would call this the”integration branch“. This is where any automatic nightly builds are built from.”“When the source code in the develop branch reaches a stable point and is ready to be released, all of the changes should be merged back into master somehow and then tagged with a release number.”GitFlow ExplanationThis whole process adds more overhead to the branching and release process, but it’s a fixed cost overhead, and it saves a lot of HotFixing bugs on release branches. AshelySoft, following the git-flow model, also adds a continuous integration service. When new code shows up in develop, automated tests are run.This setup, git-flow and CI on develop branch, with release branches and hot fixing serves AshelySoft for several years. However, it is a complicated process. Thankfully, from here on out, AshelySoft’s process will only get simpler. The first thing that helps to simplify things is The Cloud™️.The CloudAshelySoft customers want to run an eCommerce store. However, they don’t want to run a web server. After repeatedly getting this feedback, Ashley shifts the company to be a Software-As-A-Service (SAAS) company. It takes some extensive work, but AshelySoft eCommerce becomes a multi-tenant eCommerce platform. No more git archive releases. Now the release process is deploying the latest version of the main branch onto the production server.There are downsides to this SAAS model. AshelySoft now owns the uptime of all their customers, and this is eCommerce, so real money is lost when things go down. But, the customers are willing to pay more for AshelySoft to worry about these problems. They no longer have to support multi releases at a time - no more hot fixing bugs back into old versions, no more multiverse of drifting branches to update, and no more release branches. To make this work, AshelySoft works off a simple rule: main must be releasable. Before anyone can merge develop into main they must make sure the continuous integration build is passing, and if they find problems that the CI process missed, they do their best to make sure CI will catch it in the future.GitHub FlowAround this time, GitHub private repositories appear, and AshelySoft moves from their own git hosting to GitHub and starts following a Pull Request process. Instead of pushing code straight into develop and then ensuring they didn’t break the build, developers now create pull-requests. Other team members review the pull-requests, and the continuous integration service runs its suite of tests right on the PR. As a result, the speed of getting code into develop has decreased, but with each PR being manually reviewed and automatically tested, the quality of code that makes it into the develop branch is way up.Death to developWith the quality of develop now increased, AshelySoft can increase its release velocity. They even adopt a continuous deployment model where a merge into main causes the software to be automatically deployed. From there, they move to a Canary deployment model where a new release is tested on a small portion of web traffic before it’s fully deployed. Once a PR is merged, Ashley just has to merge develop into main to perform a release.But what is the point of having develop and merging it into main? It was introduced to prevent the release of bugs by giving the software time to ‘integrate’, but AshelySoft is doing all the integration as part of the PR process. So they drop the develop branch.Ashley has come a long way but sometimes what is old is new again. She is now back to doing trunk-based or mainline development. Just like when she built the first version: features go into main, and the HEAD of main is constantly released.Lessons LearnedThere is a lot about git merging strategies, continuous integration, and deployment that doesn’t seem to make sense without going through a long journey like Ashely’s.For instance, calling software that builds and tests code a continuous integration process only makes sense when you understand what non-continuous integration was. It was spending time manually testing the upcoming release for days or even weeks before feeling confident enough to release it.Ashely’s story is fictional, and history didn’t necessarily unfold this way for all or even most software shops, but I think it’s helpful to understand where we are coming from and how cloud and SAAS workflows influence branching models.Some software always had an extensive review process, and much software will never be cloud-based and will continue to deal with release branches and backporting fixes. But some software has moved to the cloud and yet hasn’t embraced the simplified workflows that cloud deployment can enable.Appendix: Develop and The Greek Revival StyleThe Parthenon was built in ancient Greece using columns of marble. These columns of marble held it up.This is a greek-revival style house. These columns are not about function but form – they are unnecessary and were chosen for aesthetic purposes.If you don’t need to maintain and support multiple versions of your software and it only runs on your servers, then you might have a purely decorative develop branch. You may be using a git branching model that is very effective for a software lifecycle that you yourself are not in fact practicing. Those might not be load-bearing functional columns – you might be copying the visual appearance of the ancients without understanding the purpose they had in mind.The creator of GitFlow offers similar thoughts:Web apps are typically continuously delivered, not rolled back, and you don’t have to support multiple versions of the software running in the wild.If your team is doing continuous delivery of software, I would suggest to adopt a much simpler workflow (like GitHub flow) instead of trying to shoehorn git-flow into your team.GitFlow Creator Vincent DriessenThe closer you can stay to trunk-based or mainline development, the less overhead you will have and the smaller the batches you’ll be able to release.">
    <meta itemprop="datePublished" content="2021-06-16T00:00:00-04:00">
    

    <div class="page__inner-wrap">
      

      <section class="page__content" itemprop="text">
        
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">Git Branching Strategies and The Greek Revival
</h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          11 minute read
        
        
        &nbsp;	&nbsp;<i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2021-06-16T00:00:00-04:00">June 16, 2021</time>
        

      </span>
    
    <span>
      
      
      
      <div class="author__avatar_top">
          <picture class="image-author"><source srcset="/blog/generated/assets/images/authors/adamgordonbell-240-fc29677ee.webp 240w" type="image/webp"><source srcset="/blog/generated/assets/images/authors/adamgordonbell-240-ad4309f1a.png 240w" type="image/png"><img src="/blog/generated/assets/images/authors/adamgordonbell-240-ad4309f1a.png" alt="Adam Gordon Bell %"></picture>

          &nbsp;	&nbsp;
          Adam Gordon Bell
      </div>
      
    </span>
  </p>


        </header>
      
        
        <p>Some modern development practices are easiest to understand from a historical perspective: things started a certain way, and then steps were added or removed as conditions changed. Git branching, for example, is like that.</p>
<p>I’m going to explain various git branching strategies with a story. We will start with something straightforward and add complexity as we go. Eventually, we will end up back simple again.</p>
<p>I hope that explaining things this way will give you a deeper understanding of when to use specific branching and merging strategies. So instead of telling you how to cherry-pick a bug fix into a hotfix branch using GitFlow work, I can describe the conditions that would lead to adopting that process. Once you understand the whys, the hows will be easier.</p>
<h2 id="ashelysoft-2006">AshelySoft 2006</h2>
<p>The year is 2006, and Ashley Protagonist starts a software business. She builds and sells an eCommerce solution she wrote in PHP. It’s just her building and selling it, but she uses a new source control solution called git to store her software. She starts with trunk-based development.</p>
<h2 id="trunk-based-development">Trunk Based Development</h2>
<p>Trunk-based development is working on the main, or trunk branch. Ashley commits her code right into the main branch on her local machine and, when she has complete a feature, she pushes her code to the source control server.</p>
<p>Customers pay for her software, and she emails them a link to the current version as an archive file using <a href="https://git-scm.com/docs/git-archive">git archive</a>. She is a PHP developer, so she whips up a simple PHP script that returns the git archive for the branch requested.</p>
<p><picture><source srcset="/blog/generated/assets/images/git-branching/email2-800-c3cecc459.webp 800w" type="image/webp"><source srcset="/blog/generated/assets/images/git-branching/email2-800-2d6f208ff.png 800w" type="image/png"><img src="/blog/generated/assets/images/git-branching/email2-800-2d6f208ff.png"></picture></p>
<figcaption>
Simple Release Distribution
</figcaption>
<p>Her customers then install her software on their web servers, where they use it to run their eCommerce businesses.</p>
<section id="mainline-development" class="notice--info">
<h2>MainLine Development</h2>
<h3 id="ℹ️-fun-fact-trunk-vs.-main">ℹ️ Fun Fact: Trunk VS. Main</h3>
<p>If Ashley had chosen subversion or CVS, which were more prevalent in 2006, she would have called her branch <code>trunk</code> because every branch is branched off the trunk like a real-world tree. This is where the term trunk-based development comes from. However, Ashley uses <code>main</code>, so she may prefer the term mainline development. It’s the same thing, just a different name.</p>
</section>
<h2 id="release-branches">Release Branches</h2>
<p>Ashley’s business succeeds. She acquires many more customers and hires more developers and a customer-support person. Support becomes problematic, though, as some customers are very slow to upgrade, and it’s unclear what version any given customer is on. Additionally, customers can’t keep up with the latest version when every commit is a new version, and there are no version numbers.</p>
<p>So she decides to batch up the changes into monthly releases and create a new release branch for each revision. Of course, she could use tags for these releases, but branches and tags are pretty similar, and she already has her release script in place.</p>
<p>Now her support people can ask customers what version they are on. If it’s more than two releases back, they ask them to upgrade. That is, AshelySoft only supports the current release and the two previous versions.</p>
<section id="cutting-a-release" class="notice--info">
<h2>Cutting a Release</h2>
<p>There was a time before modern source control when creating a release branch was an expensive process that had to be planned. “Cutting a Release” was the name for this process, which involved locking down the source and starting the lengthy process of ‘cutting a release branch off the trunk’. People still use the phrase today.</p>
<blockquote>
<p>“Well, the performance was so bad that when they wanted to cut a branch, they would announce it ahead of time. They would schedule the branching because you didn’t want anybody else committing while you were branching, because that would totally screw things up. Right? And I said,”Okay, Friday at 2:00 pm., we’re going to cut the branch." Then all activity would stop, access to the server would be cut off."</p>
<p>And it would take 45 minutes to cut this branch. And then you’d say, “Okay, we’ve opened up the branch. Everybody can start working again.”</p>
<p><a href="https://corecursive.com/software-that-doesnt-suck-with-jim-blandy/">Jim Blandy</a> creator of Subversion</p>
</blockquote>
</section>
<h2 id="hot-fixes-and-the-multiverse">Hot Fixes and the Multiverse</h2>
<p>This is all working great. Ashley starts scaling the development team, and they start shipping more features. Unfortunately, while each monthly release now contains more cool new features, more regressions and bugs start slipping into the releases as well.</p>
<p>Some customers respond to this by not upgrading right away. If they are well-served by the current product, they can stay two releases back and get active support while giving the latest release time to stabilize. Bugs do show up in the old versions, though, and this is where things get interesting.</p>
<p>Up until now, time, as viewed by AshelySoft’s source control, moves forward in a single line. There is one <code>main</code> branch that represents one linear release timeline. But now, when bugs are found, they need to be addressed in multiple versions of the product. And you can’t simply ask people to upgrade because they are still on a supported version, and they are correctly worried about the quality of the latest release. They want the version they have plus the bug fixes, with no new development.</p>
<p>You are now in the hot fixing multiverse. AshelySoft has to fix bugs in the latest version and all other active versions. Each release is a separate timeline where active development ceased at the release date, but bugs continued to be fixed.</p>
<p>If you’ve seen any time travel movies, you probably realize that this can get complex. What if a bug fix to back release introduces a bug of its own? Thankfully AshelySoft is only supporting two active versions back and only supporting them for a couple of months. Suppose they were supporting back versions for several years. In that case, they might find themselves spending more and more time maintaining all these versions, and the various versions would slowly drift away from each other.</p>
<p>Nevertheless, release branches are an enormous help for AshelySoft. They help customers stay on a version that works for them, while AshelySoft can still push new features. However, it does increase the amount of effort that fixing bugs requires, and dealing with that will lead to AshelySoft’s next innovation.</p>
<h2 id="the-develop-branch">The <code>develop</code> Branch</h2>
<p>The cost of shipping bugs has now increased for AshelySoft. In the worse case, a bug isn’t discovered until it’s in all active versions of the software and the code between versions has changed enough that the fix is slightly different in each version, tripling the bug fix cost.</p>
<p>Fortunately, a solution for this does exist: Continuing with our time travel/multiverse analogy, we need to travel back in time and stop the bug before our releases branches off the main timeline. Unfortunately, AshelySoft does not have access to literal time travel machines, but Ashley has a more straightforward idea: Catch the bugs before they are released.</p>
<h2 id="gitflow-to-the-rescue">GitFlow to the Rescue</h2>
<p>A popular branching method called <a href="https://nvie.com/posts/a-successful-git-branching-model/">GitFlow</a> has excellent suggestions for achieving this: you create a <code>develop</code> branch. So now all new work goes into <code>develop,</code> and instead of 4 weeks of development in each release, you spend the last week stabilizing <code>develop</code>. You make sure <code>develop</code> has no bugs as best you can, and when it seems stable, you merge it into main and then cut a release branch off main.</p>
<blockquote>
<p>“We consider origin/develop to be the main branch where the source code of HEAD always reflects a state with the latest delivered development changes for the next release. Some would call this the”integration branch“. This is where any automatic nightly builds are built from.”</p>
<p>“When the source code in the develop branch reaches a stable point and is ready to be released, all of the changes should be merged back into master somehow and then tagged with a release number.”</p>
<p>GitFlow Explanation</p>
</blockquote>
<p>This whole process adds more overhead to the branching and release process, but it’s a fixed cost overhead, and it saves a lot of HotFixing bugs on release branches. AshelySoft, following the git-flow model, also adds a <a href="/blog/continuous-integration">continuous integration</a> service. When new code shows up in <code>develop</code>, <a href="/blog/unit-vs-integration">automated tests</a> are run.</p>
<p>This setup, git-flow and CI on develop branch, with release branches and hot fixing serves AshelySoft for several years. However, it is a complicated process. Thankfully, from here on out, AshelySoft’s process will only get simpler. The first thing that helps to simplify things is <code>The Cloud</code>™️.</p>
<h2 id="the-cloud">The Cloud</h2>
<p>AshelySoft customers want to run an eCommerce store. However, they don’t want to run a web server. After repeatedly getting this feedback, Ashley shifts the company to be a Software-As-A-Service (SAAS) company. It takes some extensive work, but AshelySoft eCommerce becomes a multi-tenant eCommerce platform. No more <code>git archive</code> releases. Now the release process is deploying the latest version of the main branch onto the production server.</p>
<p>There are downsides to this SAAS model. AshelySoft now owns the uptime of all their customers, and this is eCommerce, so real money is lost when things go down. But, the customers are willing to pay more for AshelySoft to worry about these problems. They no longer have to support multi releases at a time - no more hot fixing bugs back into old versions, no more multiverse of drifting branches to update, and no more release branches. To make this work, AshelySoft works off a simple rule: <code>main</code> must be releasable. Before anyone can merge <code>develop</code> into <code>main</code> they must make sure the continuous integration build is passing, and if they find problems that the CI process missed, they do their best to make sure CI will catch it in the future.</p>
<h2 id="github-flow">GitHub Flow</h2>
<p>Around this time, GitHub private repositories appear, and AshelySoft moves from their own git hosting to GitHub and starts following a Pull Request process. Instead of pushing code straight into <code>develop</code> and then ensuring they didn’t break the build, developers now create pull-requests. Other team members review the pull-requests, and the continuous integration service runs its suite of tests right on the PR. As a result, the speed of getting code into <code>develop</code> has decreased, but with each PR being manually reviewed and automatically tested, the quality of code that makes it into the <code>develop</code> branch is way up.</p>
<h2 id="death-to-develop">Death to <code>develop</code></h2>
<p>With the quality of <code>develop</code> now increased, AshelySoft can increase its release velocity. They even adopt a continuous deployment model where a merge into <code>main</code> causes the software to be automatically deployed. From there, they move to a <a href="/blog/deployment-strategies/#canary-deployment">Canary deployment model</a> where a new release is tested on a small portion of web traffic before it’s fully deployed. Once a PR is merged, Ashley just has to merge <code>develop</code> into <code>main</code> to perform a release.</p>
<p>But what is the point of having <code>develop</code> and merging it into <code>main</code>? It was introduced to prevent the release of bugs by giving the software time to ‘integrate’, but AshelySoft is doing all the integration as part of the PR process. So they drop the <code>develop</code> branch.</p>
<p>Ashley has come a long way but sometimes what is old is new again. She is now back to doing trunk-based or mainline development. Just like when she built the first version: features go into <code>main</code>, and the HEAD of <code>main</code> is constantly released.</p>
<h2 id="lessons-learned">Lessons Learned</h2>
<p>There is a lot about git merging strategies, continuous integration, and deployment that doesn’t seem to make sense without going through a long journey like Ashely’s.</p>
<p>For instance, calling software that builds and tests code a continuous integration process only makes sense when you understand what non-continuous integration was. It was spending time manually testing the upcoming release for days or even weeks before feeling confident enough to release it.</p>
<p>Ashely’s story is fictional, and history didn’t necessarily unfold this way for all or even most software shops, but I think it’s helpful to understand where we are coming from and how cloud and SAAS workflows influence branching models.</p>
<p>Some software always had an extensive review process, and much software will never be cloud-based and will continue to deal with release branches and backporting fixes. But some software has moved to the cloud and yet hasn’t embraced the simplified workflows that cloud deployment can enable.</p>
<h2 id="appendix-develop-and-the-greek-revival-style">Appendix: Develop and The Greek Revival Style</h2>
<p><picture><source srcset="/blog/generated/assets/images/git-branching/greek-columns-550-93c2aaf0b.webp 550w" type="image/webp"><source srcset="/blog/generated/assets/images/git-branching/greek-columns-550-9fd39c02f.jpg 550w" type="image/jpeg"><img src="/blog/generated/assets/images/git-branching/greek-columns-550-9fd39c02f.jpg"></picture></p>
<p>The Parthenon was built in ancient Greece using columns of marble. These columns of marble held it up.</p>
<p><picture><source srcset="/blog/generated/assets/images/git-branching/greek-revival-800-bc37602f4.webp 800w" type="image/webp"><source srcset="/blog/generated/assets/images/git-branching/greek-revival-800-ce1d10ab6.jpg 800w" type="image/jpeg"><img src="/blog/generated/assets/images/git-branching/greek-revival-800-ce1d10ab6.jpg"></picture></p>
<p>This is a greek-revival style house. These columns are not about function but form – they are unnecessary and were chosen for aesthetic purposes.</p>
<p>If you don’t need to maintain and support multiple versions of your software and it only runs on your servers, then you might have a purely decorative <code>develop</code> branch. You may be using a git branching model that is very effective for a software lifecycle that you yourself are not in fact practicing. Those might not be load-bearing functional columns – you might be copying the visual appearance of the ancients without understanding the purpose they had in mind.</p>
<p>The creator of GitFlow offers similar thoughts:</p>
<blockquote>
<p>Web apps are typically continuously delivered, not rolled back, and you don’t have to support multiple versions of the software running in the wild.</p>
<p>If your team is doing continuous delivery of software, I would suggest to adopt a much simpler workflow (like GitHub flow) instead of trying to shoehorn git-flow into your team.</p>
<p>GitFlow Creator Vincent Driessen</p>
</blockquote>
<p>The closer you can stay to trunk-based or mainline development, the less overhead you will have and the smaller the batches you’ll be able to release.</p>

        
      </section>

      


<div itemscope itemtype="https://schema.org/Person">
  
    <div class="author__avatar">
      
        <picture class="image-author"><source srcset="/blog/generated/assets/images/authors/adamgordonbell-240-fc29677ee.webp 240w" type="image/webp"><source srcset="/blog/generated/assets/images/authors/adamgordonbell-240-ad4309f1a.png 240w" type="image/png"><img src="/blog/generated/assets/images/authors/adamgordonbell-240-ad4309f1a.png" alt="Adam Gordon Bell %"></picture>

      
    </div>
  
  <div class="author__content">
    
      <h4 class="author__name" itemprop="name">
        Adam Gordon Bell
    
    
      
        
          <a href="https://twitter.com/adamgordonbell" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i><span class="label"></span></a>
        
      
        
          <a href="mailto:adam+website@earthly.dev" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i><span class="label"></span></a>
        
      
        
          <a href="https://corecursive.com" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-link" aria-hidden="true"></i><span class="label"></span></a>
        
      
    
    </h4>
    
      <div class="author__bio" itemprop="description">
        <p>Spreading the word about Earthly. Host of CoRecursive podcast. Physical Embodiment of Cunningham’s Law</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <!-- <button class="btn btn--inverse">Follow</button> -->
    <ul class="author__urls social-icons">
      

     

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

      <footer class="page__meta">
        
        



  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/blog/categories/tutorials" class="page__taxonomy-item" rel="tag">Tutorials</a>
    
    </span>
  </p>




<p class="page__taxonomy">
  <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i>Author:</strong>
  <span itemprop="keywords">
    <a href="/blog/authors/Adam/" class="page__taxonomy-item" rel="tag">Adam Gordon Bell</a>
  </span>
</p>



        
  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2021-06-16T00:00:00-04:00">June 16, 2021</time></p>


      </footer>

      

      
  <nav class="pagination">
    
      <a href="/blog/incident-management-metrics/" class="pagination--pager" title="Incident Management Metrics and Key Performance Indicators
">Previous</a>
    
    
      <a href="/blog/15-minute-project/" class="pagination--pager" title="The 15-Minute Project
">Next</a>
    
  </nav>

    </div>
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">You may also enjoy</h4>
      <div class="grid__wrapper">
        
          










<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
      <div class="archive__item-teaser">
        <picture><source srcset="/blog/generated/assets/images/command-line-tools/header-600-df2c8b780.webp 600w, /blog/generated/assets/images/command-line-tools/header-800-df2c8b780.webp 800w" type="image/webp"><source srcset="/blog/generated/assets/images/command-line-tools/header-600-7e54c1bed.jpg 600w, /blog/generated/assets/images/command-line-tools/header-800-7e54c1bed.jpg 800w" type="image/jpeg"><img src="/blog/generated/assets/images/command-line-tools/header-800-7e54c1bed.jpg"></picture>

      </div>
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/blog/command-line-tools/" rel="permalink">6 Command Line Tools for Productive Programmers
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          8 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">
Lately, I’ve been doing a lot more things at the command line. I’m not a hard-core terminal guy – I use VSCode more than Vim – but I’m always surprised at t...</p>
  </article>
</div>

        
          










<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
      <div class="archive__item-teaser">
        <picture><source srcset="/blog/generated/assets/images/python-matplotlib-docker/header-600-e56f7fb32.webp 600w, /blog/generated/assets/images/python-matplotlib-docker/header-800-e56f7fb32.webp 800w" type="image/webp"><source srcset="/blog/generated/assets/images/python-matplotlib-docker/header-600-976d74d44.jpg 600w, /blog/generated/assets/images/python-matplotlib-docker/header-800-976d74d44.jpg 800w" type="image/jpeg"><img src="/blog/generated/assets/images/python-matplotlib-docker/header-800-976d74d44.jpg"></picture>

      </div>
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/blog/python-matplotlib-docker/" rel="permalink">Install <code>matplotlib</code> In A Docker Container
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          2 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">
matplotlib is an excellent library for creating graphs and visualizations in Python. For example, I used it to generate the performance graphs in my merging...</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
          <li><a href="https://twitter.com/earthlytech" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
        
          <li><a href="https://github.com/earthly/earthly" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
      
    

    
      <li><a href="/blog/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2021 <a href="https://earthly.dev/">Earthly</a>. </div>

      </footer>
    </div>

    <script src="/blog/assets/js/vendor/jquery/jquery-3.5.1.js"></script>
<script src="/blog/assets/js/plugins/jquery.fitvids.js"></script>
<script src="/blog/assets/js/plugins/smooth-scroll.js"></script>
<script src="/blog/assets/js/plugins/gumshoe.js"></script>
<script src="/blog/assets/js/plugins/jquery.magnific-popup.js"></script>
<script src="/blog/assets/js/main.min.js"></script>

  <script> // minified version of https://earthly.dev/assets/js/analytics.js
    function setCookie(e,t,r){var i="";if(r){var o=new Date;o.setTime(o.getTime()+24*r*60*60*1e3),i="; expires="+o.toUTCString()}document.cookie=e+"="+(t||"")+i+"; path=/"}function getCookie(e){for(var t=e+"=",r=document.cookie.split(";"),i=0;i<r.length;i++){for(var o=r[i];" "==o.charAt(0);)o=o.substring(1,o.length);if(0==o.indexOf(t))return o.substring(t.length,o.length)}return null}function uuidv4(){return([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,e=>(e^crypto.getRandomValues(new Uint8Array(1))[0]&15>>e/4).toString(16))}function getAnalyticCookie(){cookieName="earthlyID";var e=getCookie(cookieName);return null==e&&(e=uuidv4()),setCookie(cookieName,e,36500),e}jQuery.ajax({type:"POST",url:"https://api.earthly.dev/analytics",data:JSON.stringify({key:"website",url:window.location.href,referrer:document.referrer,earthlyID:getAnalyticCookie()})});
</script>




  </body>
</html>
