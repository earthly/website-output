<!doctype html>
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">
<link rel="icon" type="image/png" href="/blog/assets/images/favicon.png">
<!-- begin _includes/seo.html -->





<title>Beating TimSort at Merging - Earthly Blog</title>
<meta name="description" content="Here is a problem. You are tasked with improving the hot loop of a Python program: maybe it is an in-memory sequential index of some sort. The slow...">


  <meta name="author" content="Adam Gordon Bell">
  
  <meta property="article:author" content="Adam Gordon Bell">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Earthly Blog">
<meta property="og:title" content="Beating TimSort at Merging">
<meta property="og:url" content="https://earthly.dev/blog/python-timsort-merge/">


  <meta property="og:description" content="Here is a problem. You are tasked with improving the hot loop of a Python program: maybe it is an in-memory sequential index of some sort. The slow...">



  <meta property="og:image" content="/blog/generated/assets/images/python-timsort-merge/header-800-8aefce833.jpg">



  <meta name="twitter:site" content="@EarthlyTech">
  <meta name="twitter:title" content="Beating TimSort at Merging">
  <meta name="twitter:description" content="Here is a problem. You are tasked with improving the hot loop of a Python program: maybe it is an in-memory sequential index of some sort. The slow...">
  <meta name="twitter:url" content="https://earthly.dev/blog/python-timsort-merge/">

  
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://earthly.dev/blog/generated/assets/images/python-timsort-merge/header-800-8aefce833.jpg">
  

  



  <meta property="article:published_time" content="2021-07-13T00:00:00-04:00">





  

  


<link rel="canonical" href="https://earthly.dev/blog/python-timsort-merge/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Organization",
      "url": "https://earthly.dev/blog/",
      "logo": "/assets/images/logo-header.png"
    
  }
</script>






<!-- end _includes/seo.html -->



  <link href="/blog/feed.xml" type="application/atom+xml" rel="alternate" title="Earthly Blog Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/blog/assets/css/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->


  
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-161831101-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-161831101-5');
</script>
  <!-- Facebook Pixel Code -->
<script>
    !function(f,b,e,v,n,t,s)
    {if(f.fbq)return;n=f.fbq=function(){n.callMethod?
    n.callMethod.apply(n,arguments):n.queue.push(arguments)};
    if(!f._fbq)f._fbq=n;n.push=n;n.loaded=!0;n.version='2.0';
    n.queue=[];t=b.createElement(e);t.async=!0;
    t.src=v;s=b.getElementsByTagName(e)[0];
    s.parentNode.insertBefore(t,s)}(window, document,'script',
    'https://connect.facebook.net/en_US/fbevents.js');
    fbq('init', '259843109045285');
    fbq('track', 'PageView');
    </script>
    <noscript><img height="1" width="1" style="display:none"
    src="https://www.facebook.com/tr?id=259843109045285&ev=PageView&noscript=1"
    />
</noscript>
 <!-- End Facebook Pixel Code -->
  <!-- Twitter universal website tag code -->
<script>
  !function(e,t,n,s,u,a){e.twq||(s=e.twq=function(){s.exe?s.exe.apply(s,arguments):s.queue.push(arguments);
  },s.version='1.1',s.queue=[],u=t.createElement(n),u.async=!0,u.src='//static.ads-twitter.com/uwt.js',
  a=t.getElementsByTagName(n)[0],a.parentNode.insertBefore(u,a))}(window,document,'script');
  // Insert Twitter Pixel ID and Standard Event data below
  twq('init','o5s6p');
  twq('track','PageView');
  </script>
  <!-- End Twitter universal website tag code -->


  </head>

  <body class="layout--single">
    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/"><img src="/blog/assets/images/white-logo.png" alt="Earthly"></a>
        
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/blog/">Blog home</a>
            </li><li class="masthead__menu-item">
              <a href="/blog/categories/articles/">Articles</a>
            </li><li class="masthead__menu-item">
              <a href="/blog/categories/news/">News</a>
            </li><li class="masthead__menu-item">
              <a href="/blog/categories/tutorials/">Tutorials</a>
            </li><li class="masthead__menu-item">
              <a href="https://github.com/earthly/earthly">GitHub</a>
            </li></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      




  







<div class="page__hero"
  style=" background-image: url('');"
>
  
      <picture class="page__hero-image"><source srcset="/blog/generated/assets/images/python-timsort-merge/header-400-75e74e4c2.webp 400w, /blog/generated/assets/images/python-timsort-merge/header-600-75e74e4c2.webp 600w, /blog/generated/assets/images/python-timsort-merge/header-800-75e74e4c2.webp 800w, /blog/generated/assets/images/python-timsort-merge/header-1000-75e74e4c2.webp 1000w, /blog/generated/assets/images/python-timsort-merge/header-1200-75e74e4c2.webp 1200w" type="image/webp"><source srcset="/blog/generated/assets/images/python-timsort-merge/header-400-75e74e4c2.png 400w, /blog/generated/assets/images/python-timsort-merge/header-600-75e74e4c2.png 600w, /blog/generated/assets/images/python-timsort-merge/header-800-75e74e4c2.png 800w, /blog/generated/assets/images/python-timsort-merge/header-1000-75e74e4c2.png 1000w, /blog/generated/assets/images/python-timsort-merge/header-1200-75e74e4c2.png 1200w" type="image/png"><img src="/blog/generated/assets/images/python-timsort-merge/header-800-75e74e4c2.jpg" alt="Beating TimSort at Merging"></picture>

  
  
</div>





<div id="main" role="main">
  
  <div class="sidebar">
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Beating TimSort at Merging">
    <meta itemprop="description" content="Here is a problem. You are tasked with improving the hot loop of a Python program: maybe it is an in-memory sequential index of some sort. The slow part is the updating, where you are adding a new sorted list of items to the already sorted index. You need to combine two sorted lists and keep the result sorted. How do you do that update?Yes, this sounds like a LeetCode problem, and maybe in the real-world you would reach for some existing sorted set data structure, but if you were working with python lists, you might do something like this1:def merge_sorted_lists(l1, l2):    sorted_list = []    while (l1 and l2):        if (l1[0] &lt;= l2[0]): # Compare both heads            item = l1.pop(0) # Pop from the head            sorted_list.append(item)        else:            item = l2.pop(0)            sorted_list.append(item)    # Add the remaining of the lists    sorted_list.extend(l1 if l1 else l2)    return sorted_listPython has a built-in method in heapq.merge that does this. It takes advantage of the fact that our lists are already sorted, so we can get a new sorted list linear time rather than the n*log(n) time it would take for combining and sorting two unsorted lists.Imagine my surprise then when I saw this performance graph from Stack Overflow:Python’s sort is beating merge at merging sorted lists!Sorting the list is faster than just merging the list in almost all cases! That doesn’t sound right, but I checked it, and it’s true. As Stack Overflow user JFS puts it:Long story short, unless len(l1 + l2) &gt;= 1,000,000 use sortThe reason sort beats merge in most cases is because of a man named Tim Peters.TimSortPython’s list.sort is the original implementation of a hybrid sorting algorithm called TimSort, named after its author, Tim Peters.[Here is] stable, natural merge sort, modestly called Timsort (hey, I earned it ). It has supernatural performance on many kinds of partially ordered arrays (less than lg(N!) comparisons needed, and as few as N-1), yet as fast as Python’s previous highly tuned sample sort hybrid on random arrays.Tim Peters explaining TimSortTimsort is designed to find runs of sequential numbers and merge them together:The main routine marches over the array once, left to right, alternately identifying the next run, then merging it into the previous runs “intelligently”. Everything else is complication for speed, and some hard-won measure of memory efficiency.This is why (x + y).sort() can be surprisingly fast: once it finds the sequential runs of numbers, it functions like our merge algorithm: combining the two sorted lists in linear time.Timsort does have to do extra work, though. It needs to do a pass over the data to find these sequential runs, and heapq.merge knows where the runs are ahead of time. Timsort overcomes this disadvantage by being written in C rather than Python. Or as ShawdowRanger on Stack Overflow explains it:CPython’s list.sort is implemented in C (avoiding interpreter overhead), while heapq.merge is mostly implemented in Python, and optimizes for the “many iterables” case in a way that slows the “two iterables” case.This means that if I drop down to C and write a C extension I should be able to beat Timsort. This turned out to be easier than I thought it would be2.The C ExtensionThe bulk of the C Extension, whose performance I’m going to cover in a minute, is just the pop the stack algorithm discussed before, but using an index to point to the head of the stack:  //New List  PyObject* mergedList = PyList_New( n1 + n2 );  for( i = 0;; ) {    elem1 = PyList_GetItem( listObj1, i1 );    elem2 = PyList_GetItem( listObj2, i2 );    result = PyObject_RichCompareBool(v, w, Py_LT);    switch( result ) {      // List1 has smallest, Pop from list 1      case 1:        PyList_SetItem( mergedList, i++, elem1 );        i1++;        break;      case 0:          // List2 has smallest, Pop from list 2        PyList_SetItem( mergedList, i++, elem2 );        i2++;        break;    }    if( i2 &gt;= n2 || i1 &gt;= n1 )) {    //One list is empty, add remainder of other list to result    ...    break;    } } return mergedList;C merge (full and final version on GitHub)The nice thing about C extensions in Python is that they are easy to use. Once compiled, I can just import merge and use my new merge method:import merge# create some sorted listsa = list(range(-100, 1700))b = list(range(1400, 1800))# merge themmerge.merge(a, b)Testing ItTesting my new merge with a list of integers and floats, we can see that we are beating Timsort, especially for long lists:import mergeimport timeita = list(range(-100, 1700)) b = [0.1] + list(range(1400, 1800))def merge_test():   m1 = merge.merge(a, b)def sort_test():   m2 = a + b   m2.sort()sort_time = timeit.timeit(&quot;sort_test()&quot;, setup=&quot;from __main__ import sort_test&quot;, number=100000)merge_time = timeit.timeit(&quot;merge_test()&quot;, setup=&quot;from __main__ import merge_test&quot;,number=100000)print(f&#39;timsort took {sort_time} seconds&#39;)print(f&#39;merge took {merge_time} seconds&#39;)timsort took 3.9523325259999997 secondsmerge took 3.0547665259999994 secondsGraphing the performance we get this:We are beating Timsort with our mergeBut if we switch to a list of only integers sort is beating us for small lists and even on big lists our performance improvement is thin at best:With lists of all int or all float we lose our advantage.What is going on here?Timsort’s Special ComparisonsIt turns out that Timsort has some extra tricks up its sleeves in the case of a list of integers. In that initial pass over the list, it checks the types of the elements, and if they are all uniform it tries to use a cheaper comparison operation.Specifically, if your list is all longs, floats, or Latin strings Timsort will save a lot of cycles on the comparison operations.Learning from Timsort we can bring in these comparison operations ourselves. We don’t want to do a full pass over the list, or we will lose our advantage, so we can just specialize our merge by offering separate calls for longs, floats, and Latin alphabet strings like so://Default comparisonPyObject* merge( PyObject*, PyObject* );//Compare assuming intsPyObject* merge_int( PyObject*, PyObject* );//Compare assuming floatsPyObject* merge_float( PyObject*, PyObject* );//Compare assuming latinPyObject* merge_latin( PyObject*, PyObject* )merge.hBeating TimSortDoing that, we now can finally beat Timsort at merging sorted lists, not just when the list is a heterogeneous mix of elements, but also when it’s all integers, or floating-point numbers, or one byte per char strings.merge vs TimSort for int.merge vs TimSort for float.merge vs TimSort for Latin alphabet strings.merge vs TimSort for everything without a specialized compare.The default merge beats Timsort for heterogeneous lists, and the specialized versions are there for when you have uniform types in your list, and you need to go fast.TimSort Is GoodThere, I have beat Timsort for merging sorting lists, although I had to pull in some code from TimSort itself to get here. I’m not sure how valuable this is: if you need to go fast, you might not choose Python, but it was a fun learning project.Also, I learned that dropping down to C isn’t as scary as it sounds. The build steps are a bit more involved, but with the included Earthfile, the build is a one-liner and works cross-platform. You can find the code on GitHub and an intro to Earthly on this very site, and with that example, you can build your own C extension reasonably quickly.The surprising thing, though, is how good Timsort still is. It wasn’t designed for merging sorted lists but for sorting real-world data. It turns out real-world data is often partially sorted, just like our use case.Timsort on partially sorted data shows us where Big O notation can misinform us. If your input always keeps you near the median or best-case performance, then the worst-case performance doesn’t matter much. It’s no wonder then that since its first creation, Timsort has spread from Python to JavaScript, Swift, and Rust. Thank you, Tim Peters!Practically, you might not want to use pop, but just track an index of where the head of the stack should be, like the C code shown later.↩︎It was easier because my teammate Alex has experience writing C extensions for Python, so by the time I had found the Python header files, Alex had already put together a prototype solution.↩︎">
    <meta itemprop="datePublished" content="2021-07-13T00:00:00-04:00">
    

    <div class="page__inner-wrap">
      

      <section class="page__content" itemprop="text">
        
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">Beating TimSort at Merging
</h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          7 minute read
        
        
        &nbsp;	&nbsp;<i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2021-07-13T00:00:00-04:00">July 13, 2021</time>
        

      </span>
    
    <span>
      
      
      
      <div class="author__avatar_top">
          <picture class="image-author"><source srcset="/blog/generated/assets/images/authors/adamgordonbell-240-fc29677ee.webp 240w" type="image/webp"><source srcset="/blog/generated/assets/images/authors/adamgordonbell-240-ad4309f1a.png 240w" type="image/png"><img src="/blog/generated/assets/images/authors/adamgordonbell-240-ad4309f1a.png" alt="Adam Gordon Bell %"></picture>

          &nbsp;	&nbsp;
          Adam Gordon Bell
      </div>
      
    </span>
  </p>


        </header>
      
        
        <div class="narrow-code">
<p>Here is a problem. You are tasked with improving the hot loop of a Python program: maybe it is an in-memory sequential index of some sort. The slow part is the updating, where you are adding a new sorted list of items to the already sorted index. You need to combine two sorted lists and keep the result sorted. How do you do that update?</p>
<p>Yes, this sounds like a LeetCode problem, and maybe in the real-world you would reach for some existing <a href="https://docs.oracle.com/javase/8/docs/api/java/util/SortedSet.html">sorted set</a> <a href="http://www.cplusplus.com/reference/set/set/">data structure</a>, but if you were working with python lists, you might do something like this<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> merge_sorted_lists(l1, l2):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    sorted_list <span class="op">=</span> []</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> (l1 <span class="kw">and</span> l2):</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (l1[<span class="dv">0</span>] <span class="op">&lt;=</span> l2[<span class="dv">0</span>]): <span class="co"># Compare both heads</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>            item <span class="op">=</span> l1.pop(<span class="dv">0</span>) <span class="co"># Pop from the head</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>            sorted_list.append(item)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>            item <span class="op">=</span> l2.pop(<span class="dv">0</span>)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>            sorted_list.append(item)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Add the remaining of the lists</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    sorted_list.extend(l1 <span class="cf">if</span> l1 <span class="cf">else</span> l2)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sorted_list</span></code></pre></div>
<p>Python has a built-in method in <a href="https://github.com/python/cpython/blob/3.7/Lib/heapq.py#L314"><code>heapq.merge</code></a> that does this. It takes advantage of the fact that our lists are already sorted, so we can get a new sorted list linear time rather than the <code>n*log(n)</code> time it would take for combining and sorting two unsorted lists.</p>
<p>Imagine my surprise then when I saw this performance graph from Stack Overflow:</p>
<div class="wide">
<p><picture><source srcset="/blog/generated/assets/images/python-timsort-merge/performance-sort1-800-629c946b4.webp 800w" type="image/webp"><source srcset="/blog/generated/assets/images/python-timsort-merge/performance-sort1-800-84f6208b2.png 800w" type="image/png"><img src="/blog/generated/assets/images/python-timsort-merge/performance-sort1-800-84f6208b2.png"></picture></p>
<figcaption>
Python’s sort is beating merge at merging sorted lists!
</figcaption>
</div>
<p>Sorting the list is faster than just merging the list in almost all cases! That doesn’t sound right, but I checked it, and it’s true. As Stack Overflow user <a href="https://stackoverflow.com/users/4279/jfs">JFS</a> puts it:</p>
<blockquote>
<p>Long story short, unless <code>len(l1 + l2)</code> &gt;= 1,000,000 use sort</p>
</blockquote>
<p>The reason sort beats merge in most cases is because of a man named Tim Peters.</p>
<h2 id="timsort">TimSort</h2>
<p>Python’s <code>list.sort</code> is the original implementation of a hybrid sorting algorithm called TimSort, named after its author, Tim Peters.</p>
<blockquote>
<p>[Here is] stable, natural merge sort, modestly called Timsort (hey, I earned it <wink>). It has supernatural performance on many kinds of partially ordered arrays (less than lg(N!) comparisons needed, and as few as N-1), yet as fast as Python’s previous highly tuned sample sort hybrid on random arrays.</p>
</blockquote>
<figcaption>
Tim Peters explaining <a href="https://github.com/python/cpython/commit/92f81f2e63b5eaa6d748d51a10e32108517bf3bf#diff-6d09fc0f0b57214c2e3a838d366425836c296fa931fe9dc430f604b7e3950c29">TimSort</a>
</figcaption>
<p>Timsort is designed to find runs of sequential numbers and merge them together:</p>
<blockquote>
<p>The main routine marches over the array once, left to right, alternately identifying the next run, then merging it into the previous runs “intelligently”. Everything else is complication for speed, and some hard-won measure of memory efficiency.</p>
</blockquote>
<p>This is why <code>(x + y).sort()</code> can be surprisingly fast: once it finds the sequential runs of numbers, it functions like our merge algorithm: combining the two sorted lists in linear time.</p>
<p>Timsort does have to do extra work, though. It needs to do a pass over the data to find these sequential runs, and <code>heapq.merge</code> knows where the runs are ahead of time. Timsort overcomes this disadvantage by being written in C rather than Python. Or as ShawdowRanger on Stack Overflow explains it:</p>
<blockquote>
<p>CPython’s <code>list.sort</code> is implemented in C (avoiding interpreter overhead), while <code>heapq.merge</code> is mostly implemented in Python, and optimizes for the “many iterables” case in a way that slows the “two iterables” case.</p>
</blockquote>
<p>This means that if I drop down to C and write a C extension I should be able to beat Timsort. This turned out to be easier than I thought it would be<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.</p>
<h2 id="the-c-extension">The C Extension</h2>
<p>The bulk of the C Extension, whose performance I’m going to cover in a minute, is just the pop the stack algorithm discussed before, but using an index to point to the head of the stack:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">//New List</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  PyObject<span class="op">*</span> mergedList <span class="op">=</span> PyList_New<span class="op">(</span> n1 <span class="op">+</span> n2 <span class="op">);</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span><span class="op">(</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;;</span> <span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    elem1 <span class="op">=</span> PyList_GetItem<span class="op">(</span> listObj1<span class="op">,</span> i1 <span class="op">);</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    elem2 <span class="op">=</span> PyList_GetItem<span class="op">(</span> listObj2<span class="op">,</span> i2 <span class="op">);</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> PyObject_RichCompareBool<span class="op">(</span>v<span class="op">,</span> w<span class="op">,</span> Py_LT<span class="op">);</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span><span class="op">(</span> result <span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>      <span class="co">// List1 has smallest, Pop from list 1</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>      <span class="cf">case</span> <span class="dv">1</span><span class="op">:</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        PyList_SetItem<span class="op">(</span> mergedList<span class="op">,</span> i<span class="op">++,</span> elem1 <span class="op">);</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        i1<span class="op">++;</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>      <span class="cf">case</span> <span class="dv">0</span><span class="op">:</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>          <span class="co">// List2 has smallest, Pop from list 2</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>        PyList_SetItem<span class="op">(</span> mergedList<span class="op">,</span> i<span class="op">++,</span> elem2 <span class="op">);</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>        i2<span class="op">++;</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span> i2 <span class="op">&gt;=</span> n2 <span class="op">||</span> i1 <span class="op">&gt;=</span> n1 <span class="op">))</span> <span class="op">{</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">//One list is empty, add remainder of other list to result</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">break</span><span class="op">;</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a> <span class="op">}</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a> <span class="cf">return</span> mergedList<span class="op">;</span></span></code></pre></div>
<figcaption>
C merge (<a href="https://github.com/earthly/pymerge/blob/main/merge.c">full and final version on GitHub</a>)
</figcaption>
<p>The nice thing about C extensions in Python is that they are easy to use. Once compiled, I can just <code>import merge</code> and use my new merge method:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> merge</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co"># create some sorted lists</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(<span class="op">-</span><span class="dv">100</span>, <span class="dv">1700</span>))</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(<span class="dv">1400</span>, <span class="dv">1800</span>))</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co"># merge them</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>merge.merge(a, b)</span></code></pre></div>
<h2 id="testing-it">Testing It</h2>
<p>Testing my new merge with a list of integers and floats, we can see that we are beating Timsort, especially for long lists:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> merge</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> timeit</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(<span class="op">-</span><span class="dv">100</span>, <span class="dv">1700</span>)) </span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> [<span class="fl">0.1</span>] <span class="op">+</span> <span class="bu">list</span>(<span class="bu">range</span>(<span class="dv">1400</span>, <span class="dv">1800</span>))</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> merge_test():</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>   m1 <span class="op">=</span> merge.merge(a, b)</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sort_test():</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>   m2 <span class="op">=</span> a <span class="op">+</span> b</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>   m2.sort()</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>sort_time <span class="op">=</span> timeit.timeit(<span class="st">&quot;sort_test()&quot;</span>, setup<span class="op">=</span><span class="st">&quot;from __main__ import sort_test&quot;</span>, number<span class="op">=</span><span class="dv">100000</span>)</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>merge_time <span class="op">=</span> timeit.timeit(<span class="st">&quot;merge_test()&quot;</span>, setup<span class="op">=</span><span class="st">&quot;from __main__ import merge_test&quot;</span>,number<span class="op">=</span><span class="dv">100000</span>)</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&#39;timsort took </span><span class="sc">{</span>sort_time<span class="sc">}</span><span class="ss"> seconds&#39;</span>)</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&#39;merge took </span><span class="sc">{</span>merge_time<span class="sc">}</span><span class="ss"> seconds&#39;</span>)</span></code></pre></div>
<div class="sourceCode" id="cb5"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ex">timsort</span> took 3.9523325259999997 seconds</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="ex">merge</span> took 3.0547665259999994 seconds</span></code></pre></div>
<p>Graphing the performance we get this:</p>
<div class="wide">
<p><img src="/blog/generated/assets/images/python-timsort-merge/beating-with-hetro1-800-f0ab30520.png" srcset="/blog/generated/assets/images/python-timsort-merge/beating-with-hetro1-400-f0ab30520.png 400w, /blog/generated/assets/images/python-timsort-merge/beating-with-hetro1-600-f0ab30520.png 600w, /blog/generated/assets/images/python-timsort-merge/beating-with-hetro1-800-f0ab30520.png 800w, /blog/generated/assets/images/python-timsort-merge/beating-with-hetro1-1000-f0ab30520.png 1000w"></p>
<figcaption>
We are beating Timsort with our merge
</figcaption>
</div>
<p>But if we switch to a list of only integers <code>sort</code> is beating us for small lists and even on big lists our performance improvement is thin at best:</p>
<div class="wide">
<p><img src="/blog/generated/assets/images/python-timsort-merge/losing-with-homo-800-f3e6b8fd6.png" srcset="/blog/generated/assets/images/python-timsort-merge/losing-with-homo-400-f3e6b8fd6.png 400w, /blog/generated/assets/images/python-timsort-merge/losing-with-homo-600-f3e6b8fd6.png 600w, /blog/generated/assets/images/python-timsort-merge/losing-with-homo-800-f3e6b8fd6.png 800w, /blog/generated/assets/images/python-timsort-merge/losing-with-homo-1000-f3e6b8fd6.png 1000w"></p>
<figcaption>
With lists of all <code>int</code> or all <code>float</code> we lose our advantage.
</figcaption>
</div>
<p>What is going on here?</p>
<h2 id="timsorts-special-comparisons">Timsort’s Special Comparisons</h2>
<p>It turns out that Timsort has some extra tricks up its sleeves in the case of a list of integers. In that initial pass over the list, it checks the types of the elements, and if they are all uniform it tries to use a cheaper comparison operation.</p>
<p>Specifically, if your list is all <a href="https://github.com/python/cpython/blob/main/Objects/listobject.c#L2085">longs</a>, <a href="https://github.com/python/cpython/blob/main/Objects/listobject.c#L2113">floats</a>, or <a href="https://github.com/python/cpython/blob/main/Objects/listobject.c#L2061">Latin strings</a> Timsort will save a lot of cycles on the comparison operations.</p>
<p>Learning from Timsort we can bring in these comparison operations ourselves. We don’t want to do a full pass over the list, or we will lose our advantage, so we can just specialize our merge by offering separate calls for longs, floats, and Latin alphabet strings like so:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">//Default comparison</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>PyObject<span class="op">*</span> merge<span class="op">(</span> PyObject<span class="op">*,</span> PyObject<span class="op">*</span> <span class="op">);</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co">//Compare assuming ints</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>PyObject<span class="op">*</span> merge_int<span class="op">(</span> PyObject<span class="op">*,</span> PyObject<span class="op">*</span> <span class="op">);</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="co">//Compare assuming floats</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>PyObject<span class="op">*</span> merge_float<span class="op">(</span> PyObject<span class="op">*,</span> PyObject<span class="op">*</span> <span class="op">);</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="co">//Compare assuming latin</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>PyObject<span class="op">*</span> merge_latin<span class="op">(</span> PyObject<span class="op">*,</span> PyObject<span class="op">*</span> <span class="op">)</span></span></code></pre></div>
<figcaption>
merge.h
</figcaption>
<h2 id="beating-timsort">Beating TimSort</h2>
<p>Doing that, we now can finally beat Timsort at merging sorted lists, not just when the list is a heterogeneous mix of elements, but also when it’s all integers, or floating-point numbers, or one byte per char strings.</p>
<div class="wide">
<p><img src="/blog/generated/assets/images/python-timsort-merge/summary1-int-800-b27eb2dbe.png" srcset="/blog/generated/assets/images/python-timsort-merge/summary1-int-400-b27eb2dbe.png 400w, /blog/generated/assets/images/python-timsort-merge/summary1-int-600-b27eb2dbe.png 600w, /blog/generated/assets/images/python-timsort-merge/summary1-int-800-b27eb2dbe.png 800w, /blog/generated/assets/images/python-timsort-merge/summary1-int-1000-b27eb2dbe.png 1000w"></p>
<figcaption>
merge vs TimSort for <code>int</code>.
</figcaption>
</div>
<div class="wide">
<p><img src="/blog/generated/assets/images/python-timsort-merge/summary2-float-800-28225b9ff.png" srcset="/blog/generated/assets/images/python-timsort-merge/summary2-float-400-28225b9ff.png 400w, /blog/generated/assets/images/python-timsort-merge/summary2-float-600-28225b9ff.png 600w, /blog/generated/assets/images/python-timsort-merge/summary2-float-800-28225b9ff.png 800w, /blog/generated/assets/images/python-timsort-merge/summary2-float-1000-28225b9ff.png 1000w"></p>
<figcaption>
merge vs TimSort for <code>float</code>.
</figcaption>
</div>
<div class="wide">
<p><img src="/blog/generated/assets/images/python-timsort-merge/summary3-latin-800-af4f97615.png" srcset="/blog/generated/assets/images/python-timsort-merge/summary3-latin-400-af4f97615.png 400w, /blog/generated/assets/images/python-timsort-merge/summary3-latin-600-af4f97615.png 600w, /blog/generated/assets/images/python-timsort-merge/summary3-latin-800-af4f97615.png 800w, /blog/generated/assets/images/python-timsort-merge/summary3-latin-1000-af4f97615.png 1000w"></p>
<figcaption>
merge vs TimSort for Latin alphabet strings.
</figcaption>
</div>
<div class="wide">
<p><img src="/blog/generated/assets/images/python-timsort-merge/summary4-else-800-34d33a495.png" srcset="/blog/generated/assets/images/python-timsort-merge/summary4-else-400-34d33a495.png 400w, /blog/generated/assets/images/python-timsort-merge/summary4-else-600-34d33a495.png 600w, /blog/generated/assets/images/python-timsort-merge/summary4-else-800-34d33a495.png 800w, /blog/generated/assets/images/python-timsort-merge/summary4-else-1000-34d33a495.png 1000w"></p>
<figcaption>
merge vs TimSort for everything without a specialized compare.
</figcaption>
</div>
<p>The default <code>merge</code> beats Timsort for heterogeneous lists, and the specialized versions are there for when you have uniform types in your list, and you need to go fast.</p>
<h2 id="timsort-is-good">TimSort Is Good</h2>
<p>There, I have beat Timsort for merging sorting lists, although I had to pull in some code from TimSort itself to get here. I’m not sure how valuable this is: if you need to go fast, you might not choose Python, but it was a fun learning project.</p>
<p>Also, I learned that dropping down to C isn’t as scary as it sounds. The build steps are a bit more involved, but with the included <a href="https://github.com/earthly/pymerge/blob/main/Earthfile">Earthfile</a>, the build is a one-liner and works cross-platform. You can find the code <a href="https://github.com/earthly/pymerge">on GitHub</a> and an intro to <a href="https://earthly.dev/">Earthly</a> on this very site, and with that example, you can build your own C extension reasonably quickly.</p>
<p>The surprising thing, though, is how good Timsort still is. It wasn’t designed for merging sorted lists but for sorting real-world data. It turns out real-world data is often partially sorted, just like our use case.</p>
<p>Timsort on partially sorted data shows us where Big O notation can misinform us. If your input always keeps you near the median or best-case performance, then the worst-case performance doesn’t matter much. It’s no wonder then that since its first creation, Timsort has spread from Python to JavaScript, Swift, and Rust. Thank you, Tim Peters!</p>
</div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Practically, you might not want to use pop, but just track an index of where the head of the stack should be, like the C code shown later.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>It was easier because my teammate Alex has experience writing C extensions for Python, so by the time I had found the Python header files, Alex had already put together a prototype solution.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

        
      </section>

      


<div itemscope itemtype="https://schema.org/Person">
  
    <div class="author__avatar">
      
        <picture class="image-author"><source srcset="/blog/generated/assets/images/authors/adamgordonbell-240-fc29677ee.webp 240w" type="image/webp"><source srcset="/blog/generated/assets/images/authors/adamgordonbell-240-ad4309f1a.png 240w" type="image/png"><img src="/blog/generated/assets/images/authors/adamgordonbell-240-ad4309f1a.png" alt="Adam Gordon Bell %"></picture>

      
    </div>
  
  <div class="author__content">
    
      <div class="author__name heading" itemprop="name">
        Adam Gordon Bell
    
    
      
        
          <a href="https://twitter.com/adamgordonbell" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i><span class="label"></span></a>
        
      
        
          <a href="mailto:adam+website@earthly.dev" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i><span class="label"></span></a>
        
      
        
          <a href="https://corecursive.com" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-link" aria-hidden="true"></i><span class="label"></span></a>
        
      
    
      </div>
    
      <div class="author__bio" itemprop="description">
        <p>Spreading the word about Earthly. Host of CoRecursive podcast. Physical Embodiment of Cunningham’s Law</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <!-- <button class="btn btn--inverse">Follow</button> -->
    <ul class="author__urls social-icons">
      

     

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

      <footer class="page__meta">
        
        



  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/blog/categories/tutorials" class="page__taxonomy-item" rel="tag">Tutorials</a>
    
    </span>
  </p>




<p class="page__taxonomy">
  <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i>Author:</strong>
  <span itemprop="keywords">
    <a href="/blog/authors/Adam/" class="page__taxonomy-item" rel="tag">Adam Gordon Bell</a>
  </span>
</p>



        
  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2021-07-13T00:00:00-04:00">July 13, 2021</time></p>


      </footer>

      

      
  <nav class="pagination">
    
      <a href="/blog/python-makefile/" class="pagination--pager" title="Creating a Python Makefile
">Previous</a>
    
    
      <a href="/blog/golang-makefile/" class="pagination--pager" title="Creating a Golang Makefile
">Next</a>
    
  </nav>

    </div>
  </article>

  
  
    <div class="page__related">
      <div class="page__related-title heading">You may also enjoy</div>
      <div class="grid__wrapper">
        
          










<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
      <div class="archive__item-teaser">
        <picture><source srcset="/blog/generated/assets/images/idiots-and-maniacs/header-600-161d4ea73.webp 600w, /blog/generated/assets/images/idiots-and-maniacs/header-800-161d4ea73.webp 800w" type="image/webp"><source srcset="/blog/generated/assets/images/idiots-and-maniacs/header-600-00dc94dde.jpg 600w, /blog/generated/assets/images/idiots-and-maniacs/header-800-00dc94dde.jpg 800w" type="image/jpeg"><img src="/blog/generated/assets/images/idiots-and-maniacs/header-800-00dc94dde.jpg"></picture>

      </div>
    
    
    <div class="archive__item-title no_toc heading" itemprop="headline">
    
      
      
        <a href="/blog/idiots-and-maniacs/" rel="permalink">Idiots And Maniacs
</a>
      
    
    </div>
    
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          4 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">
Observability


If you do software-as-a-service development and you have paying customers, you at some point learn about the need for operational monitoring...</p>
  </article>
</div>

        
          










<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
      <div class="archive__item-teaser">
        <picture><source srcset="/blog/generated/assets/images/vscode-make/header-600-cc5a5db17.webp 600w, /blog/generated/assets/images/vscode-make/header-800-cc5a5db17.webp 800w" type="image/webp"><source srcset="/blog/generated/assets/images/vscode-make/header-600-91e861b7e.jpg 600w, /blog/generated/assets/images/vscode-make/header-800-91e861b7e.jpg 800w" type="image/jpeg"><img src="/blog/generated/assets/images/vscode-make/header-800-91e861b7e.jpg"></picture>

      </div>
    
    
    <div class="archive__item-title no_toc heading" itemprop="headline">
    
      
      
        <a href="/blog/vscode-make/" rel="permalink">Building in Visual Studio Code with a Makefile
</a>
      
    
    </div>
    
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          5 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">
Microsoft announced recently a new Visual Studio Code extension to handle Makefiles. This extension provides a set of commands to the editor that will facil...</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
          <li><a href="https://twitter.com/earthlytech" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
        
          <li><a href="https://github.com/earthly/earthly" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
      
    

    
      <li><a href="/blog/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2021 <a href="https://earthly.dev/">Earthly</a>. </div>

      </footer>
    </div>

    <script src="/blog/assets/js/vendor/jquery/jquery-3.5.1.js"></script>
<script src="/blog/assets/js/plugins/jquery.fitvids.js"></script>
<script src="/blog/assets/js/plugins/smooth-scroll.js"></script>
<script src="/blog/assets/js/plugins/gumshoe.js"></script>
<script src="/blog/assets/js/plugins/jquery.magnific-popup.js"></script>
<script src="/blog/assets/js/main.min.js"></script>

  <script> // minified version of https://earthly.dev/assets/js/analytics.js
    function setCookie(e,t,r){var i="";if(r){var o=new Date;o.setTime(o.getTime()+24*r*60*60*1e3),i="; expires="+o.toUTCString()}document.cookie=e+"="+(t||"")+i+"; path=/"}function getCookie(e){for(var t=e+"=",r=document.cookie.split(";"),i=0;i<r.length;i++){for(var o=r[i];" "==o.charAt(0);)o=o.substring(1,o.length);if(0==o.indexOf(t))return o.substring(t.length,o.length)}return null}function uuidv4(){return([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,e=>(e^crypto.getRandomValues(new Uint8Array(1))[0]&15>>e/4).toString(16))}function getAnalyticCookie(){cookieName="earthlyID";var e=getCookie(cookieName);return null==e&&(e=uuidv4()),setCookie(cookieName,e,36500),e}jQuery.ajax({type:"POST",url:"https://api.earthly.dev/analytics",data:JSON.stringify({key:"website",url:window.location.href,referrer:document.referrer,earthlyID:getAnalyticCookie()})});
</script>




  </body>
</html>
