<!doctype html>
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">
<link rel="icon" type="image/png" href="/blog/assets/images/favicon.png">
<!-- begin _includes/seo.html -->


<title>Compiling Containers - Dockerfiles, LLVM, and BuildKit - Earthly Blog</title>
<meta name="description" content="How are containers made? Usually, from a series of statements like RUN, FROM, and COPY, which are put into a Dockerfile and built. But how are those commands turned into a container image and then a running container?">


  <meta name="author" content="Adam Gordon Bell">
  
  <meta property="article:author" content="Adam Gordon Bell">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Earthly Blog">
<meta property="og:title" content="Compiling Containers - Dockerfiles, LLVM, and BuildKit">
<meta property="og:url" content="https://earthly.dev/blog/compiling-containers-dockerfiles-llvm-and-buildkit/">


  <meta property="og:description" content="How are containers made? Usually, from a series of statements like RUN, FROM, and COPY, which are put into a Dockerfile and built. But how are those commands turned into a container image and then a running container?">



  <meta property="og:image" content="/blog/generated/assets/images/compiling-containers-dockerfiles-llvm-and-buildkit/header-800-14fae6a07.jpg">



  <meta name="twitter:site" content="@EarthlyTech">
  <meta name="twitter:title" content="Compiling Containers - Dockerfiles, LLVM, and BuildKit">
  <meta name="twitter:description" content="How are containers made? Usually, from a series of statements like RUN, FROM, and COPY, which are put into a Dockerfile and built. But how are those commands turned into a container image and then a running container?">
  <meta name="twitter:url" content="https://earthly.dev/blog/compiling-containers-dockerfiles-llvm-and-buildkit/">

  
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://earthly.dev/blog/generated/assets/images/compiling-containers-dockerfiles-llvm-and-buildkit/header-800-14fae6a07.jpg">
  

  



  <meta property="article:published_time" content="2021-03-17T00:00:00-04:00">





  

  


<link rel="canonical" href="https://earthly.dev/blog/compiling-containers-dockerfiles-llvm-and-buildkit/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Organization",
      "url": "https://earthly.dev/blog/",
      "logo": "/assets/images/logo.png"
    
  }
</script>






<!-- end _includes/seo.html -->



  <link href="/blog/feed.xml" type="application/atom+xml" rel="alternate" title="Earthly Blog Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/blog/assets/css/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->


  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-161831101-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-161831101-5');
</script>
  <!-- Facebook Pixel Code -->
<script>
    !function(f,b,e,v,n,t,s)
    {if(f.fbq)return;n=f.fbq=function(){n.callMethod?
    n.callMethod.apply(n,arguments):n.queue.push(arguments)};
    if(!f._fbq)f._fbq=n;n.push=n;n.loaded=!0;n.version='2.0';
    n.queue=[];t=b.createElement(e);t.async=!0;
    t.src=v;s=b.getElementsByTagName(e)[0];
    s.parentNode.insertBefore(t,s)}(window, document,'script',
    'https://connect.facebook.net/en_US/fbevents.js');
    fbq('init', '259843109045285');
    fbq('track', 'PageView');
    </script>
    <noscript><img height="1" width="1" style="display:none"
    src="https://www.facebook.com/tr?id=259843109045285&ev=PageView&noscript=1"
    />
</noscript>
 <!-- End Facebook Pixel Code -->
  <!-- Twitter universal website tag code -->
<script>
  !function(e,t,n,s,u,a){e.twq||(s=e.twq=function(){s.exe?s.exe.apply(s,arguments):s.queue.push(arguments);
  },s.version='1.1',s.queue=[],u=t.createElement(n),u.async=!0,u.src='//static.ads-twitter.com/uwt.js',
  a=t.getElementsByTagName(n)[0],a.parentNode.insertBefore(u,a))}(window,document,'script');
  // Insert Twitter Pixel ID and Standard Event data below
  twq('init','o5s6p');
  twq('track','PageView');
  </script>
  <!-- End Twitter universal website tag code -->


  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/"><img src="/blog/assets/images/white-logo.png" alt="Earthly"></a>
        
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/blog/">Blog home</a>
            </li><li class="masthead__menu-item">
              <a href="/blog/categories/articles/">Articles</a>
            </li><li class="masthead__menu-item">
              <a href="/blog/categories/news/">News</a>
            </li><li class="masthead__menu-item">
              <a href="/blog/categories/tutorials/">Tutorials</a>
            </li><li class="masthead__menu-item">
              <a href="https://github.com/earthly/earthly">GitHub</a>
            </li></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      




  







<div class="page__hero"
  style=" background-image: url('');"
>
  
      <picture class="page__hero-image"><source srcset="/blog/generated/assets/images/compiling-containers-dockerfiles-llvm-and-buildkit/header-400-a96fb4f1e.webp 400w, /blog/generated/assets/images/compiling-containers-dockerfiles-llvm-and-buildkit/header-600-a96fb4f1e.webp 600w, /blog/generated/assets/images/compiling-containers-dockerfiles-llvm-and-buildkit/header-800-a96fb4f1e.webp 800w, /blog/generated/assets/images/compiling-containers-dockerfiles-llvm-and-buildkit/header-1000-a96fb4f1e.webp 1000w, /blog/generated/assets/images/compiling-containers-dockerfiles-llvm-and-buildkit/header-1200-a96fb4f1e.webp 1200w" type="image/webp"><source srcset="/blog/generated/assets/images/compiling-containers-dockerfiles-llvm-and-buildkit/header-400-a96fb4f1e.png 400w, /blog/generated/assets/images/compiling-containers-dockerfiles-llvm-and-buildkit/header-600-a96fb4f1e.png 600w, /blog/generated/assets/images/compiling-containers-dockerfiles-llvm-and-buildkit/header-800-a96fb4f1e.png 800w, /blog/generated/assets/images/compiling-containers-dockerfiles-llvm-and-buildkit/header-1000-a96fb4f1e.png 1000w, /blog/generated/assets/images/compiling-containers-dockerfiles-llvm-and-buildkit/header-1200-a96fb4f1e.png 1200w" type="image/png"><img src="/blog/generated/assets/images/compiling-containers-dockerfiles-llvm-and-buildkit/header-800-a96fb4f1e.jpg" alt="Compiling Containers - Dockerfiles, LLVM, and BuildKit"></picture>

  
  
</div>





<div id="main" role="main">
  
  <div class="sidebar">
  
    
      
      
      
      
    
    
      

<nav class="nav__list">
  
  <input id="ac-toc" name="accordion-toc" type="checkbox" />
  <label for="ac-toc">Toggle menu</label>
  <ul class="nav__items">
    
      <li>
        
          <span class="nav__sub-title">Container Tutorials</span>
        

        
        <ul>
          
            <li><a href="/blog/understanding-docker-logging-and-log-files/">Docker Logging</a></li>
          
            <li><a href="/blog/docker-networking/">Docker Networking</a></li>
          
            <li><a href="/blog/how-to-setup-and-use-amazons-elastic-container-registry/">AWS ECR</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Best Practices</span>
        

        
        <ul>
          
            <li><a href="/blog/youre-using-docker-compose-wrong/">Docker Compose</a></li>
          
            <li><a href="/blog/what-is-buildkit-and-what-can-i-do-with-it/">What Is BuildKit?</a></li>
          
            <li><a href="/blog/compiling-containers-dockerfiles-llvm-and-buildkit/" class="active">Compiling Containers</a></li>
          
        </ul>
        
      </li>
    
  </ul>
</nav>

    
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Compiling Containers - Dockerfiles, LLVM, and BuildKit">
    <meta itemprop="description" content="How are containers made? Usually, from a series of statements like RUN, FROM, and COPY, which are put into a Dockerfile and built. But how are those commands turned into a container image and then a running container?">
    <meta itemprop="datePublished" content="2021-03-17T00:00:00-04:00">
    

    <div class="page__inner-wrap">
      

      <section class="page__content" itemprop="text">
        
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">Compiling Containers - Dockerfiles, LLVM, and BuildKit
</h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          13 minute read
        
        
        &nbsp;	&nbsp;<i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2021-03-17T00:00:00-04:00">March 17, 2021</time>
        

      </span>
    
    <span>
      
      
      
      <div class="author__avatar_top">
          <img src="/blog/assets/images/authors/adamgordonbell.png" alt="Adam Gordon Bell" itemprop="image">&nbsp;	&nbsp;
          Adam Gordon Bell
      </div>
      
    </span>
  </p>


        </header>
      
        
          <aside class="sidebar__right ">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#introduction">Introduction</a><ul><li><a href="#game-plan">Game Plan</a></li></ul></li><li><a href="#on-docker-build">On Docker Build</a></li><li><a href="#background">Background</a></li><li><a href="#how-do-compilers-work">How Do Compilers Work?</a></li><li><a href="#there-is-a-catch">There Is a Catch</a></li><li><a href="#intermediate-representations">Intermediate Representations</a></li><li><a href="#buidkit">BuidKit</a></li><li><a href="#programmatically-making-an-image">Programmatically Making An Image</a><ul><li><a href="#building-our-llb">Building Our LLB</a></li></ul></li><li><a href="#a-true-frontend-for-buildkit">A True Frontend for BuildKit</a></li><li><a href="#building-our-own-example-frontend-for-docker-build">Building Our Own Example Frontend for Docker build</a></li><li><a href="#conclusion">Conclusion</a></li></ul>

            </nav>
          </aside>
        
        <h2 id="introduction">Introduction</h2>
<p>How are containers made? Usually, from a series of statements like <code>RUN</code>, <code>FROM</code>, and <code>COPY</code>, which are put into a Dockerfile and built. But how are those commands turned into a container image and then a running container? We can build up an intuition for how this works by understanding the phases involved and creating a container image ourselves. We will create an image programmatically and then develop a trivial syntactic frontend and use it to build an image.</p>
<h3 id="game-plan">Game Plan</h3>
<ul>
<li>☑️ Intro</li>
<li>☐️ Background</li>
<li><input type="checkbox" disabled="" />
Understanding Compiler Stages and BuildKit</li>
<li><input type="checkbox" disabled="" />
Programmatically Creating an Image</li>
<li><input type="checkbox" disabled="" />
Building a Frontend for BuildKit</li>
</ul>
<h2 id="on-docker-build">On <code>Docker Build</code></h2>
<p>We can create container images in several ways. We can use Buildpacks, we can use build tools like Bazel or sbt, but by far, the most common way images are built is using <code>docker build</code> with a Dockerfile. The familiar base images Alpine, Ubuntu, and Debian are all created this way.</p>
<p>Here is an example Dockerfile:</p>
<div class="sourceCode" id="cb1" data-startFrom="100"><pre class="sourceCode numberSource dockerfile numberLines"><code class="sourceCode dockerfile" style="counter-reset: source-line 99;"><span id="cb1-100"><a href="#cb1-100"></a><span class="kw">FROM</span> alpine</span>
<span id="cb1-101"><a href="#cb1-101"></a><span class="kw">COPY</span> README.md README.md</span>
<span id="cb1-102"><a href="#cb1-102"></a><span class="kw">RUN</span> echo <span class="st">&quot;standard docker build&quot;</span> &gt; /built.txt<span class="st">&quot;</span></span></code></pre></div>
<p>We will be using variations on this Dockerfile throughout this tutorial.</p>
<p>We can build it like this:</p>
<pre><code>docker build . -t test</code></pre>
<p>But what is happening when you call <code>docker build</code>? To understand that, we will need a little background.</p>
<h2 id="background">Background</h2>
<p>A docker image is made up of layers. Those layers form an immutable filesystem. A container image also has some descriptive data, such as the start-up command, the ports to expose, and volumes to mount. When you <code>docker run</code> an image, it starts up inside a container runtime.</p>
<p>I like to think about images and containers by analogy. If an image is like an executable, then a container is like a process. You can run multiple containers from one image, and a running image isn’t an image at all but a container.</p>
<div class="wide">
<img src="/blog/assets/images/compiling-containers-dockerfiles-llvm-and-buildkit/1-2.png" title="fig:" alt="An image is like an executable" />
</div>
<p>Continuing our analogy, <a href="https://github.com/moby/buildkit">BuildKit</a> is a compiler, just like <a href="https://en.wikipedia.org/wiki/LLVM">LLVM</a>. But whereas a compiler takes source code and libraries and produces an executable, BuildKit takes a Dockerfile and a file path and creates a container image.</p>
<div class="wide">
<figure>
<img src="/blog/assets/images/compiling-containers-dockerfiles-llvm-and-buildkit/099.png" alt="BuildKit is like a compiler for Docker images" /><figcaption aria-hidden="true">BuildKit is like a compiler for Docker images</figcaption>
</figure>
</div>
<p>Docker build uses BuildKit, to turn a Dockerfile into a docker image, OCI image, or another image format. In this walk-through, we will primarily use BuildKit directly.</p>
<div class="wide">
<figure>
<img src="/blog/assets/images/compiling-containers-dockerfiles-llvm-and-buildkit/buildctl-2.png" alt="Docker Daemon with BuildKit Daemon inside it" /><figcaption aria-hidden="true">Docker Daemon with BuildKit Daemon inside it</figcaption>
</figure>
</div>
<p>This <a href="https://earthly.dev/blog/what-is-buildkit-and-what-can-i-do-with-it/">primer on using buildkit</a> supplies some helpful background on using BuildKit, <code>buildkitd</code>, and <code>buildctl</code> via the command-line. However, the only prerequisite for today is running <code>brew install buildkit</code> or the appropriate OS <a href="https://github.com/moby/buildkit#quick-start">equivalent</a> steps.</p>
<h2 id="how-do-compilers-work">How Do Compilers Work?</h2>
<p>A traditional compiler takes code in a high-level language and lowers it to a lower-level language. In most conventional ahead-of-time compilers, the final target is machine code. Machine code is a low-level programming language that your CPU understands<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p>
<div class="notice--info">
<p><strong>ℹ️ Fun Fact: Machine Code VS. Assembly</strong></p>
<p>Machine code is written in binary. This makes it hard for a human to understand. Assembly code is a plain-text representation of machine code that is designed to be somewhat human-readable. There is generally a 1-1 mapping between instructions the machine understands (in machine code) and the OpCodes in Assembly</p>
</div>
<p>Compiling the classic c “Hello, World” into x86 assembly code using the CLANG frontend for LLVM looks like this:</p>
<div class="wide">
<figure>
<img src="/blog/assets/images/compiling-containers-dockerfiles-llvm-and-buildkit/compilingc.png" alt="Compiling Hello World to X86 assembly" /><figcaption aria-hidden="true">Compiling Hello World to X86 assembly</figcaption>
</figure>
</div>
<p>Creating an image from a dockerfile works a similar way:</p>
<div class="wide">
<figure>
<img src="/blog/assets/images/compiling-containers-dockerfiles-llvm-and-buildkit/build-an-image.png" alt="Compiling Docker Image" /><figcaption aria-hidden="true">Compiling Docker Image</figcaption>
</figure>
</div>
<p>BuildKit is passed the Dockerfile and the build context, which is the present working directory in the above diagram. In simplified terms, each line in the dockerfile is turned into a layer in the resulting image. One significant way image building differs from compiling is this build context. A compiler’s input is limited to source code, whereas <code>docker build</code> takes a reference to the host filesystem as an input and uses it to perform actions such as <code>COPY</code>.</p>
<h2 id="there-is-a-catch">There Is a Catch</h2>
<p>The earlier diagram of compiling “Hello, World” in a single step missed a vital detail. Computer hardware is not a singular thing. If every compiler were a hand-coded mapping from a high-level language to x86 machine code, then moving to the Apple M1 processor would be quite challenging because it has a different instruction set.</p>
<p>Compiler authors have overcome this challenge by splitting compilation into phases. The traditional phases are the frontend, the backend, and the middle. The middle phase is sometimes called the optimizer, and it deals primarily with an internal representation (IR).</p>
<div class="wide">
<figure>
<img src="/blog/assets/images/compiling-containers-dockerfiles-llvm-and-buildkit/3stagebuild.png" alt="Three stage build process" /><figcaption aria-hidden="true">Three stage build process</figcaption>
</figure>
</div>
<p>This staged approach means you don’t need a new compiler for each new machine architecture. Instead, you just need a new backend. Here is an example of what that looks like in <a href="https://llvm.org/">LLVM</a>:</p>
<div class="wide">
<figure>
<img src="/blog/assets/images/compiling-containers-dockerfiles-llvm-and-buildkit/backends.png" alt="Backends of LLVM" /><figcaption aria-hidden="true">Backends of LLVM</figcaption>
</figure>
</div>
<h2 id="intermediate-representations">Intermediate Representations</h2>
<p>This multiple backend approach allows LLVM to target ARM, X86, and many other machine architectures using LLVM Intermediate Representation (IR) as a standard protocol. LLVM IR is a human-readable programming language that backends need to be able to take as input. To create a new backend, you need to write a translator from LLVM IR to your target machine code. That translation is the primary job of each backend.</p>
<p>Once you have this IR, you have a protocol that various phases of the compiler can use as an interface, and you can build not just many backends but many frontends as well. LLVM has frontends for numerous languages, including C++, Julia, Objective-C, Rust, and Swift.</p>
<div class="wide">
<figure>
<img src="/blog/assets/images/compiling-containers-dockerfiles-llvm-and-buildkit/frontends-2.png" alt="One compiler, with many frontend and backends" /><figcaption aria-hidden="true">One compiler, with many frontend and backends</figcaption>
</figure>
</div>
<p>If you can write a translation from your language to LLVM IR, LLVM can translate that IR into machine code for all the backends it supports. This translation function is the primary job of a compiler frontend.</p>
<p>In practice, there is much more to it than that. Frontends need to tokenize and parse input files, and they need to return pleasant errors. Backends often have target-specific optimizations to perform and heuristics to apply. But for this tutorial, the critical point is that having a standard representation ends up being a bridge that connects many front ends with many backends. This shared interface removes the need to create a compiler for every combination of language and machine architecture. It is a simple but very empowering trick!</p>
<h2 id="buidkit">BuidKit</h2>
<p>Images, unlike executables, have their own isolated filesystem. Nevertheless, the task of building an image looks very similar to compiling an executable. They can have varying syntax (dockerfile1.0, dockerfile1.2), and the result must target several machine architectures (arm64 vs. x86_64).</p>
<blockquote>
<p>“LLB is to Dockerfile what LLVM IR is to C” - <a href="https://github.com/moby/buildkit/blob/master/README.md">BuildKit Readme</a></p>
</blockquote>
<p>This similarity was not lost on the BuildKit creators. BuildKit has its own intermediate representation, LLB. And where LLVM IR has things like function calls and garbage-collection strategies, LLB has mounting filesystems and executing statements.</p>
<div class="wide">
<figure>
<img src="/blog/assets/images/compiling-containers-dockerfiles-llvm-and-buildkit/LLBIR-fixed.png" alt="LLVM IR VS. LLB" /><figcaption aria-hidden="true">LLVM IR VS. LLB</figcaption>
</figure>
</div>
<p><a href="https://github.com/moby/buildkit/blob/ebd98bcbe600c662a72ce9725417540f277be4d6/solver/pb/ops.proto">LLB</a> is defined as a protocol buffer, and this means that BuildKit frontends can make GRPC requests against buildkitd to build a container directly.</p>
<div class="wide">
<figure>
<img src="/blog/assets/images/compiling-containers-dockerfiles-llvm-and-buildkit/Send-LLB.png" alt="LLVM IR VS. LLB" /><figcaption aria-hidden="true">LLVM IR VS. LLB</figcaption>
</figure>
</div>
<h2 id="programmatically-making-an-image">Programmatically Making An Image</h2>
Alright, enough background. Let’s programmatically generate the LLB for an image and then build an image.<br />

<div class="notice--info">
<p>ℹ️ Using Go</p>
<p>In this example, we will be using Go which lets us leverage existing BuildKit libraries, but it’s possible to accomplish this in any language with Protocol Buffer support.</p>
</div>
<p>Import LLB defintions:</p>
<pre><code>import (
    &quot;github.com/moby/buildkit/client/llb&quot;
)</code></pre>
<p>Create LLB for an Alpine image:</p>
<pre><code>func createLLBState() llb.State {
    return llb.Image(&quot;docker.io/library/alpine&quot;).
        File(llb.Copy(llb.Local(&quot;context&quot;), &quot;README.md&quot;, &quot;README.md&quot;)).
        Run(llb.Args([]string{&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;echo \&quot;programmatically built\&quot; &gt; /built.txt&quot;})).
    Root()
}
</code></pre>
<p>We are accomplishing the equivalent of a <code>FROM</code> by using <code>llb.Image</code>. Then, we copy a file from the local file system into the image using <code>File</code> and <code>Copy</code>. Finally, we <code>RUN</code> a command to echo some text to a file. LLB has many more operations, but you can recreate many standard images with these three building blocks.</p>
<p>The final thing we need to do is turn this into protocol-buffer and emit it to standard out:</p>
<pre><code>func main() {

    dt, err := createLLBState().Marshal(context.TODO(), llb.LinuxAmd64)
    if err != nil {
        panic(err)
    }
    llb.WriteTo(dt, os.Stdout)
}</code></pre>
<p>Let’s look at the what this generates using the <code>dump-llb</code> option of buildctl:</p>
<pre><code> go run ./writellb/writellb.go | \
 buildctl debug dump-llb | \
 jq .
</code></pre>
<p>We get this JSON formatted LLB:</p>
<pre><code>{
  &quot;Op&quot;: {
    &quot;Op&quot;: {
      &quot;source&quot;: {
        &quot;identifier&quot;: &quot;local://context&quot;,
        &quot;attrs&quot;: {
          &quot;local.unique&quot;: &quot;s43w96rwjsm9tf1zlxvn6nezg&quot;
        }
      }
    },
    &quot;constraints&quot;: {}
  },
  &quot;Digest&quot;: &quot;sha256:c3ca71edeaa161bafed7f3dbdeeab9a5ab34587f569fd71c0a89b4d1e40d77f6&quot;,
  &quot;OpMetadata&quot;: {
    &quot;caps&quot;: {
      &quot;source.local&quot;: true,
      &quot;source.local.unique&quot;: true
    }
  }
}
{
  &quot;Op&quot;: {
    &quot;Op&quot;: {
      &quot;source&quot;: {
        &quot;identifier&quot;: &quot;docker-image://docker.io/library/alpine:latest&quot;
      }
    },
    &quot;platform&quot;: {
      &quot;Architecture&quot;: &quot;amd64&quot;,
      &quot;OS&quot;: &quot;linux&quot;
    },
    &quot;constraints&quot;: {}
  },
  &quot;Digest&quot;: &quot;sha256:665ba8b2cdc0cb0200e2a42a6b3c0f8f684089f4cd1b81494fbb9805879120f7&quot;,
  &quot;OpMetadata&quot;: {
    &quot;caps&quot;: {
      &quot;source.image&quot;: true
    }
  }
}
{
  &quot;Op&quot;: {
    &quot;inputs&quot;: [
      {
        &quot;digest&quot;: &quot;sha256:665ba8b2cdc0cb0200e2a42a6b3c0f8f684089f4cd1b81494fbb9805879120f7&quot;,
        &quot;index&quot;: 0
      },
      {
        &quot;digest&quot;: &quot;sha256:c3ca71edeaa161bafed7f3dbdeeab9a5ab34587f569fd71c0a89b4d1e40d77f6&quot;,
        &quot;index&quot;: 0
      }
    ],
    &quot;Op&quot;: {
      &quot;file&quot;: {
        &quot;actions&quot;: [
          {
            &quot;input&quot;: 0,
            &quot;secondaryInput&quot;: 1,
            &quot;output&quot;: 0,
            &quot;Action&quot;: {
              &quot;copy&quot;: {
                &quot;src&quot;: &quot;/README.md&quot;,
                &quot;dest&quot;: &quot;/README.md&quot;,
                &quot;mode&quot;: -1,
                &quot;timestamp&quot;: -1
              }
            }
          }
        ]
      }
    },
    &quot;platform&quot;: {
      &quot;Architecture&quot;: &quot;amd64&quot;,
      &quot;OS&quot;: &quot;linux&quot;
    },
    &quot;constraints&quot;: {}
  },
  &quot;Digest&quot;: &quot;sha256:ba425dda86f06cf10ee66d85beda9d500adcce2336b047e072c1f0d403334cf6&quot;,
  &quot;OpMetadata&quot;: {
    &quot;caps&quot;: {
      &quot;file.base&quot;: true
    }
  }
}
{
  &quot;Op&quot;: {
    &quot;inputs&quot;: [
      {
        &quot;digest&quot;: &quot;sha256:ba425dda86f06cf10ee66d85beda9d500adcce2336b047e072c1f0d403334cf6&quot;,
        &quot;index&quot;: 0
      }
    ],
    &quot;Op&quot;: {
      &quot;exec&quot;: {
        &quot;meta&quot;: {
          &quot;args&quot;: [
            &quot;/bin/sh&quot;,
            &quot;-c&quot;,
            &quot;echo \&quot;programmatically built\&quot; &gt; /built.txt&quot;
          ],
          &quot;cwd&quot;: &quot;/&quot;
        },
        &quot;mounts&quot;: [
          {
            &quot;input&quot;: 0,
            &quot;dest&quot;: &quot;/&quot;,
            &quot;output&quot;: 0
          }
        ]
      }
    },
    &quot;platform&quot;: {
      &quot;Architecture&quot;: &quot;amd64&quot;,
      &quot;OS&quot;: &quot;linux&quot;
    },
    &quot;constraints&quot;: {}
  },
  &quot;Digest&quot;: &quot;sha256:d2d18486652288fdb3516460bd6d1c2a90103d93d507a9b63ddd4a846a0fca2b&quot;,
  &quot;OpMetadata&quot;: {
    &quot;caps&quot;: {
      &quot;exec.meta.base&quot;: true,
      &quot;exec.mount.bind&quot;: true
    }
  }
}
{
  &quot;Op&quot;: {
    &quot;inputs&quot;: [
      {
        &quot;digest&quot;: &quot;sha256:d2d18486652288fdb3516460bd6d1c2a90103d93d507a9b63ddd4a846a0fca2b&quot;,
        &quot;index&quot;: 0
      }
    ],
    &quot;Op&quot;: null
  },
  &quot;Digest&quot;: &quot;sha256:fda9d405d3c557e2bd79413628a435da0000e75b9305e52789dd71001a91c704&quot;,
  &quot;OpMetadata&quot;: {
    &quot;caps&quot;: {
      &quot;constraints&quot;: true,
      &quot;platform&quot;: true
    }
  }
}</code></pre>
<p>Looking through the output, we can see how our code maps to LLB.</p>
<p>Here is our <code>Copy</code> as part of a FileOp:</p>
<pre><code>    &quot;Action&quot;: {
              &quot;copy&quot;: {
                &quot;src&quot;: &quot;/README.md&quot;,
                &quot;dest&quot;: &quot;/README.md&quot;,
                &quot;mode&quot;: -1,
                &quot;timestamp&quot;: -1
              }</code></pre>
<p>Here is mapping our build context for use in our <code>COPY</code> command:</p>
<pre><code>  &quot;Op&quot;: {
      &quot;source&quot;: {
        &quot;identifier&quot;: &quot;local://context&quot;,
        &quot;attrs&quot;: {
          &quot;local.unique&quot;: &quot;s43w96rwjsm9tf1zlxvn6nezg&quot;
        }
      }</code></pre>
<p>Similarly, the output contains LLB that corresponds to our <code>RUN</code> and <code>FROM</code> commands.</p>
<h3 id="building-our-llb">Building Our LLB</h3>
<p>To build our image, we must first start <code>buildkitd</code>:</p>
<pre><code>docker run --rm --privileged -d --name buildkit moby/buildkit
export BUILDKIT_HOST=docker-container://buildkit</code></pre>
<p>We can then build our image like this:</p>
<pre><code>go run ./writellb/writellb.go | \
buildctl build \
--local context=. \
--output type=image,name=docker.io/agbell/test,push=true</code></pre>
<p>The output flag lets us specify what backend we want BuildKit to use. We will ask it to build an OCI image and push it to docker.io.</p>
<div class="notice--info">
<p>ℹ️ Real-World Usage</p>
<p>In the real-world tool, we might want to programmatically make sure <code>buildkitd</code> is running and send the RPC request directly to it, as well as provide friendly error messages. For tutorial purposes, we will skip all that.</p>
</div>
<p>We can run it like this:</p>
<pre><code>&gt; docker run -it --pull always agbell/test:latest /bin/sh
</code></pre>
<p>And we can then see the results of our programmatic <code>COPY</code> and <code>RUN</code> commands:</p>
<pre><code>/ # cat built.txt 
programmatically built
/ # ls README.md
README.md</code></pre>
<p>There we go! The <a href="https://github.com/agbell/compiling-containers/blob/main/writellb/writellb.go">full code example</a> can be a great starting place for your own programmatic docker image building.</p>
<h2 id="a-true-frontend-for-buildkit">A True Frontend for BuildKit</h2>
<p>A true compiler front end does more than just emit hardcoded IR. A proper frontend takes in files, tokenizes them, parses them, generates a syntax tree, and then lowers that syntax tree into the internal representation. <a href="https://matt-rickard.com/building-a-new-dockerfile-frontend/">Mockerfiles</a> are an example of such a frontend:</p>
<pre><code>#syntax=r2d4/mocker
apiVersion: v1alpha1
images:
- name: demo
  from: ubuntu:16.04
  package:
    install:
    - curl
    - git
    - gcc</code></pre>
<p>And because Docker build supports the <code>#syntax</code> command we can even build a Mockerfiles directly with <code>docker build</code>.</p>
<pre><code>docker build -f mockerfile.yaml</code></pre>
<p>To support the #syntax command, all that is needed is to put the frontend in a docker image that accepts a GRPC request in the correct format, publish that image somewhere. At that point, anyone can use your frontend <code>docker build</code> by just using <code>#syntax=yourimagename</code>.</p>
<h2 id="building-our-own-example-frontend-for-docker-build">Building Our Own Example Frontend for <code>Docker build</code></h2>
<p>Building a tokenizer and a parser as a GRPC service is beyond the scope of this article. But we can get our feet wet by extracting and modifying an existing frontend. The standard <a href="https://github.com/moby/buildkit/tree/master/frontend/dockerfile">dockerfile frontend</a> is easy to disentangle from the moby project. I’ve pulled the relevant parts out into a <a href="https://github.com/agbell/compiling-containers/tree/main/ickfile">stand-alone repo</a>. Let’s make some trivial modifications to it and test it out.</p>
<p>So far, we’ve only used the docker commands <code>FROM</code>, <code>RUN</code> and <code>COPY</code>. At a surface level, with its capitalized commands, Dockerfile syntax looks a lot like the programming language <a href="https://earthly.dev/blog/intercal-yaml-and-other-horrible-programming-languages/">INTERCAL</a>. Let change these commands to their INTERCAL equivalent and develop our own Ickfile format <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.</p>
<table>
<thead>
<tr class="header">
<th>Dockerfile</th>
<th style="text-align: center;">Ickfile</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>FROM</td>
<td style="text-align: center;">COME FROM</td>
</tr>
<tr class="even">
<td>RUN</td>
<td style="text-align: center;">PLEASE</td>
</tr>
<tr class="odd">
<td>COPY</td>
<td style="text-align: center;">STASH</td>
</tr>
</tbody>
</table>
<p>The modules in the dockerfile frontend split the parsing of the input file into several discreet steps, with execution flowing this way:</p>
<div class="wide">
<figure>
<img src="/blog/assets/images/compiling-containers-dockerfiles-llvm-and-buildkit/controlflow.png" alt="ControlFlow from main.go to Dockerfile2LLB to Parser to Command.go" /><figcaption aria-hidden="true">ControlFlow from main.go to Dockerfile2LLB to Parser to Command.go</figcaption>
</figure>
</div>
<p>For this tutorial, we are only going to make trivial changes to the frontend. We will leave all the stages intact and focus on customizing the existing commands to our tastes. To do this, all we need to do is change <code>command.go</code>:</p>
<pre><code>package command

// Define constants for the command strings
const (
    Copy        = &quot;stash&quot;
    Run         = &quot;please&quot;
    From        = &quot;come_from&quot;
    ...
)</code></pre>
<p>Then we build our image:</p>
<pre><code>docker build . -t agbell/ick</code></pre>
<p>And we can use this image as a BuildKit frontend and build images with it like this:</p>
<pre><code>#syntax=agbell/ick
COME_FROM alpine
STASH README.md README.md
PLEASE echo &quot;custom frontend built&quot; &gt; /built.txt&quot;
</code></pre>
<pre><code>DOCKER_BUILDKIT=1 docker build . -f ./Ickfile -t ick </code></pre>
<p>And we can run it just like any other image:</p>
<pre><code>&gt; docker run -it ick /bin/sh</code></pre>
<p>And we can then see results of our <code>STASH</code> and <code>PLEASE</code> commands:</p>
<pre><code>/ # cat built.txt 
custom frontend built
/ # ls README.md
README.md</code></pre>
<p>I’ve pushed this image to dockerhub. Anyone can start building images using our <code>ickfile</code> format by adding <code>#syntax=agbell/ick</code> to an existing Dockerfile. No manual installation is required!</p>
<div class="notice--info">
<p>ℹ️ Enabling BuildKit</p>
<p>BuildKit is included but not enabled by default in the current version of Docker (<code>version 20.10.2</code>). To instruct <code>docker build</code> to use BuildKit set the following environment variable <code>DOCKER_BUILDKIT=1</code>. This will not be necessary once BuildKit reaches general availability.</p>
</div>
<h2 id="conclusion">Conclusion</h2>
<p>We have learned that a three-phased structure borrowed from compilers powers building images, that an intermediate representation called LLB is the key to that structure. Empowered by the knowledge, we have produced two frontends for building images.</p>
<p>This deep dive on frontends still leaves much to explore. If you want to learn more, I suggest looking into BuildKit workers. Workers do the actual building and are the secret behind <code>docker buildx</code>, and <a href="https://docs.docker.com/buildx/working-with-buildx/">multi-archtecture builds</a>. <code>docker build</code> also has support for remote workers and cache mounts, both of which can lead to faster builds.</p>
<p><a href="https://earthly.dev/">Earthly</a> uses BuildKit internally for its repeatable build syntax. Without it, our containerized Makefile-like syntax would not be possible. If you want a saner CI process, then <a href="https://earthly.dev/">you should check it out</a>.</p>
<p>There is also much more to explore about how modern compilers work. Modern compilers often have many stages and more than one intermediate representation, and they are often able to do very sophisticated optimizations.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<p>The difference between the two is murky, but I like to think of a transpiler as something that translates from one human-readable text-based programming language to another. The java compiler translates Java code to java byte code, which is a binary format. Meanwhile, PureScript, which translates to JavaScript, is regarded as a transpiler because JavaScript is text-based.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Fun Fact: You may have heard the term transpiler or transcompiler in the past. Transpilers are compilers that transform one programming language into another. If all compilers translate from one language to another, then what makes something a transpiler?<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>Ick is the name of the INTERCAL compiler. Therefore Ickfile can be its Dockerfile equivalent.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>If you want to learn more about optimizing compilers, Matt Godbolt’s article on <a href="https://queue.acm.org/detail.cfm?id=3372264">C++ Optimizations</a> is a great place to start. The book <a href="https://www.amazon.com/Building-Optimizing-Compiler-Bob-Morgan/dp/155558179X">Building an Optimizing Compiler</a> is also often recommended online.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

        
      </section>

      


<div itemscope itemtype="https://schema.org/Person">
  <!-- <h5>About The Author</h5> -->

  
    <div class="author__avatar">
      
        <img src="/blog/assets/images/authors/adamgordonbell.png" alt="Adam Gordon Bell" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h4 class="author__name" itemprop="name">Adam Gordon Bell</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>Spreading the word about open source builds at Earthly. Host of CoRecursive podcast.</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <!-- <button class="btn btn--inverse">Follow</button> -->
    <ul class="author__urls social-icons">
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

      <footer class="page__meta">
        
        



  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/blog/categories/tutorials" class="page__taxonomy-item" rel="tag">Tutorials</a>
    
    </span>
  </p>



        
  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2021-03-17T00:00:00-04:00">March 17, 2021</time></p>


      </footer>

      

      
  <nav class="pagination">
    
      <a href="/blog/on-yaml-discussions/" class="pagination--pager" title="On YAML Discussions
">Previous</a>
    
    
      <a href="/blog/understanding-bash/" class="pagination--pager" title="Understanding Bash
">Next</a>
    
  </nav>

    </div>
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">You may also enjoy</h4>
      <div class="grid__wrapper">
        
          










<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
      <div class="archive__item-teaser">
        <picture><source srcset="/blog/generated/assets/images/example/teaser-600-caed32f5a.webp 600w" type="image/webp"><source srcset="/blog/generated/assets/images/example/teaser-600-3624c03a8.jpg 600w" type="image/jpeg"><img src="/blog/generated/assets/images/example/teaser-600-3624c03a8.jpg"></picture>

      </div>
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/blog/example/" rel="permalink">Example Post
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          4 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">
This post is in the future, and won’t show up in the published site

</p>
  </article>
</div>

        
          










<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
      <div class="archive__item-teaser">
        <picture><source srcset="/blog/generated/assets/images/default-teaser-600-aae60f084.webp 600w, /blog/generated/assets/images/default-teaser-800-aae60f084.webp 800w" type="image/webp"><source srcset="/blog/generated/assets/images/default-teaser-600-495449b49.jpg 600w, /blog/generated/assets/images/default-teaser-800-495449b49.jpg 800w" type="image/jpeg"><img src="/blog/generated/assets/images/default-teaser-800-495449b49.jpg"></picture>

      </div>
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/blog/example-plot/" rel="permalink">Example Graphs
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          1 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">
You can embedded graphs into the markdown like this:

</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
          <li><a href="https://twitter.com/earthlytech" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
        
          <li><a href="https://github.com/earthly/earthly" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
      
    

    
      <li><a href="/blog/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2021 <a href="https://earthly.dev/">Earthly</a>. </div>

      </footer>
    </div>

    <script src="/blog/assets/js/main.min.js"></script>

  <script> // minified version of https://earthly.dev/assets/js/analytics.js
    function setCookie(e,t,r){var i="";if(r){var o=new Date;o.setTime(o.getTime()+24*r*60*60*1e3),i="; expires="+o.toUTCString()}document.cookie=e+"="+(t||"")+i+"; path=/"}function getCookie(e){for(var t=e+"=",r=document.cookie.split(";"),i=0;i<r.length;i++){for(var o=r[i];" "==o.charAt(0);)o=o.substring(1,o.length);if(0==o.indexOf(t))return o.substring(t.length,o.length)}return null}function uuidv4(){return([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,e=>(e^crypto.getRandomValues(new Uint8Array(1))[0]&15>>e/4).toString(16))}function getAnalyticCookie(){cookieName="earthlyID";var e=getCookie(cookieName);return null==e&&(e=uuidv4()),setCookie(cookieName,e,36500),e}jQuery.ajax({type:"POST",url:"https://api.earthly.dev/analytics",data:JSON.stringify({key:"website",url:window.location.href,referrer:document.referrer,earthlyID:getAnalyticCookie()})});
</script>




  </body>
</html>
