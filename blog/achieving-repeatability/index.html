<!doctype html>
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">
<link rel="icon" type="image/png" href="/blog/assets/images/favicon.png">
<!-- begin _includes/seo.html -->





<title>Achieving Repeatability in Continuous Integration - Earthly Blog</title>
<meta name="description" content="In software engineering, continuous integration is the practice of merging all developers’ working copies to a shared mainline several times a day. Grady Booch first proposed the term CI in his 1991 method, although he did not advocate integrating several times a day. —Wikipedia    Continuous Integration (CI) and continuous delivery (CD) are some of the best practices that any DevOps team can implement. You could argue that they’re necessary for teams looking to ship quality products fast and with confidence.   CI and CD are two pieces of a whole, the former dealing with the task to automate the process of building, testing, and integrating new features and code changes into the codebase mainline; and the latter dealing with automating the process of delivering the changes to the defined environments.   The implementation of both methodologies is often referred to as a CI/CD pipeline; it is worth noting that both for CI and CD, the operating principles and coding philosophy are equally as important as the technical aspect of the implementation.   CI’s technical goal is to provide consistent and automated results to build, package, and test applications. This repeatable flow and process allows teams to commit and merge changes more frequently, thus reducing the risk of conflicts or getting stuck in Integration Hell.    Integration Hell refers to the point in production when members on a delivery team integrate their individual code. In traditional software development environments, this integration process is rarely smooth and seamless, instead resulting in hours or perhaps days of fixing the code so that it can finally integrate. Continuous Integration (CI) aims to avoid this completely by enabling and encouraging team members to integrate frequently (e.g., hourly, or at least daily). —SolutionsIQ    This article focuses on the concepts, tools, and best practices that will allow you to achieve a high degree of repeatability and consistency on your CI/CD pipeline.   CI Repeatability Principles   One of the critical aspects of a successful and healthy CI pipeline is having repeatable builds, which guarantee consistent and reliable results. Four fundamental principles are essential to observe to achieve repeatability:    Reliability   Reproducibility   Reusability   Speed    Reliability   Reliability in continuous integration comes from knowing that the systems involved in testing the application are both available and capable of performing the complete set of tests that we need. This also means that the system has to produce consistent builds.   Reliability gives the confidence to deliver shippable working code at any time during the application lifetime.   Reproducibility   CI infrastructure and pipelines can be—and more often than not, are—software assets on their own. The work done to create and implement CI runners and pipelines for our software projects can also be built, tested, and packaged just like any other software build.   Examples of this are containerizing the environments used to run your test suites, including dependencies such as a database or ancillary applications for the end-to-end test suites.   Treating the CI pipelines as another software project also allows the development team to reproduce the same results from the CI pipeline locally and shorten the feedback loop.   Reusability   With reproducible builds, we can achieve reusability, meaning that the same tools and process can be used in more than one project. Having a system in which we are not building a special custom CI pipeline for each project allows us to find patterns that we can apply to many projects.   The type of reusable resources greatly varies depending on the type of applications and tests on each organization, from simple reusable scripts to containerized environments.   Speed   One of the primary benefits of a good and effective CI process is the feedback loop it provides to the developers working on a project. Feedback loops start losing their value and detract from developer effectiveness as they get slower.   We need to consider several factors when building a support CI pipeline, from the underlying hardware and test runners to the structure of the unit tests themselves as a larger unit. Integration tests do add to the overall testing time, and it’s important to keep that time short to make the value of the tests high.   Best Practices   Now that we understand why reusability, reproducibility, reliability, and speed are important for building repeatable and effective continuous integration pipelines, let’s talk about specific practices and processes that can help achieve them.   Test Automation and Coverage   To leverage the full value of continuous integration, you will need to automate all your tests and make sure they run for every change made to the repository. It’s also advisable to leverage the following:    Unit tests to verify the behavior of small methods and functions   Integration tests to make sure multiple components work together   Acceptance tests to cover behavior required on the business specifications   End-to-end tests to validate the behavior of the application as a whole from the user perspective    Adopting Continuous Integration   While automation and observability of our pipelines are important, the cultural aspects of working with continuous integration and ensuring that the team adopts the continuous integration principles are equally as important.   Integrate Early and Often   A crucial cultural aspect of continuous integration is building the habit and cadence of the team committing their code every day and multiple times per day. By pushing their code frequently, developers can quickly find conflicts between two changes and also become aware of other work.   Additionally, pushing their commits often allows developers to get feedback from the full CI pipeline running and allow them to identify defects in the code much sooner.   The rule of thumb is that developers should commit their code every day, whether it is to the mainline branch on a feature branch. The more frequently you commit, the less opportunity there will be for conflict, errors, or broken tests, significantly increasing the team’s speed.   Fail Early and Fail Fast   The whole point of continuous integration is providing rapid feedback. Nothing is more frustrating than a build that takes hours to complete, only to fail because of errors in some of the initial test suites.   It is possible that due to the size of the application, the complete set of tests (unit, integration, end-to-end) might take a while to run. To help things go smoothly, you should consider the following processes:    Breaking tests into groups (per module, per domain, and so forth) and running them in parallel   Run critical path tests first (core or fundamental logic)   Fail and stop the entire build if critical tests fail   Integrate with notifications systems (Slack, email) to let developers know as soon things fail    Make It Visible   A core tenet of continuous integration is communication, so you want to ensure that everyone can easily see the state of the system and the changes that have been made to it.   Information such as the states of integration branches and the state of the mainline build become a priority. Back in the day, engineering teams would go as far as hooking up physical traffic lights to signal the state of the mainline branch.     Semaphore CI    Nowadays, with cloud solutions being more prevalent and deeply integrated with source control systems, it’s much easier to give all developers a high degree of visibility. A perfect example is CI pipelines with GitHub Actions, which provides feedback directly on pull requests and allows you to visualize the state of a pipeline at every given step.     GitHub Actions CI    Fix Broken Builds Immediately   A crucial part of implementing continuous integrations is that if the mainline build fails, it needs to be fixed right away. One of the key points of working with CI is having a trusted, stable code base to develop against.   The mainline build breaking is not necessarily a bad thing on its own. Still, it might highlight gaps in how the team works, like people not being careful enough about updating and building locally before committing.   The fastest way to fix a broken build is to roll back to the last known good commit and review what happened. By all means, we should avoid debugging on the broken mainline; this becomes especially true when multiple teams are working on the same code base.   Conclusion   Continuous integration reduces risk by eliminating long integration efforts and reducing the feedback loops. To recap, there are many advantages to implementing continuous integration in your teams:    Allows identifying bugs and software defects faster   Reduces the feedback loop for engineers   Removes blind spots that can occur with deferred integration   Improves communication and velocity of the engineering teams    To achieve repeatability in a CI/CD pipeline, it’s essential to keep in mind the following principles:    Reliable continuous integration environments help us avoid slowing down the feedback loops for the developers and maintain speed of development.   Reproducible builds give our developers confidence to keep momentum and keep building with confidence.   Reusability allows us to leverage the tools, patterns, and environments for continuous integration across projects.   Speed reduces the feedback cycle for developers, allowing them to ship more features in a shorter time.    Finally, having continuous integration and continuous delivery removes one of the biggest barriers to implementing continuous deployment. Continuous deployment extends this flow and enables fully automated deployments into production.   The combination of continuous integration, continuous delivery, and continuous deployment allows teams to ship features faster and get them in front of customers faster, shortening the feedback loop and increasing value generation.   For anyone looking to learn more about continuous integration, I highly recommend Martin Fowler’s book Continuous Integration.">


  <meta name="author" content="Allan MacGregor">
  
  <meta property="article:author" content="Allan MacGregor">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Earthly Blog">
<meta property="og:title" content="Achieving Repeatability in Continuous Integration">
<meta property="og:url" content="https://earthly.dev/blog/achieving-repeatability/">


  <meta property="og:description" content="In software engineering, continuous integration is the practice of merging all developers’ working copies to a shared mainline several times a day. Grady Booch first proposed the term CI in his 1991 method, although he did not advocate integrating several times a day. —Wikipedia    Continuous Integration (CI) and continuous delivery (CD) are some of the best practices that any DevOps team can implement. You could argue that they’re necessary for teams looking to ship quality products fast and with confidence.   CI and CD are two pieces of a whole, the former dealing with the task to automate the process of building, testing, and integrating new features and code changes into the codebase mainline; and the latter dealing with automating the process of delivering the changes to the defined environments.   The implementation of both methodologies is often referred to as a CI/CD pipeline; it is worth noting that both for CI and CD, the operating principles and coding philosophy are equally as important as the technical aspect of the implementation.   CI’s technical goal is to provide consistent and automated results to build, package, and test applications. This repeatable flow and process allows teams to commit and merge changes more frequently, thus reducing the risk of conflicts or getting stuck in Integration Hell.    Integration Hell refers to the point in production when members on a delivery team integrate their individual code. In traditional software development environments, this integration process is rarely smooth and seamless, instead resulting in hours or perhaps days of fixing the code so that it can finally integrate. Continuous Integration (CI) aims to avoid this completely by enabling and encouraging team members to integrate frequently (e.g., hourly, or at least daily). —SolutionsIQ    This article focuses on the concepts, tools, and best practices that will allow you to achieve a high degree of repeatability and consistency on your CI/CD pipeline.   CI Repeatability Principles   One of the critical aspects of a successful and healthy CI pipeline is having repeatable builds, which guarantee consistent and reliable results. Four fundamental principles are essential to observe to achieve repeatability:    Reliability   Reproducibility   Reusability   Speed    Reliability   Reliability in continuous integration comes from knowing that the systems involved in testing the application are both available and capable of performing the complete set of tests that we need. This also means that the system has to produce consistent builds.   Reliability gives the confidence to deliver shippable working code at any time during the application lifetime.   Reproducibility   CI infrastructure and pipelines can be—and more often than not, are—software assets on their own. The work done to create and implement CI runners and pipelines for our software projects can also be built, tested, and packaged just like any other software build.   Examples of this are containerizing the environments used to run your test suites, including dependencies such as a database or ancillary applications for the end-to-end test suites.   Treating the CI pipelines as another software project also allows the development team to reproduce the same results from the CI pipeline locally and shorten the feedback loop.   Reusability   With reproducible builds, we can achieve reusability, meaning that the same tools and process can be used in more than one project. Having a system in which we are not building a special custom CI pipeline for each project allows us to find patterns that we can apply to many projects.   The type of reusable resources greatly varies depending on the type of applications and tests on each organization, from simple reusable scripts to containerized environments.   Speed   One of the primary benefits of a good and effective CI process is the feedback loop it provides to the developers working on a project. Feedback loops start losing their value and detract from developer effectiveness as they get slower.   We need to consider several factors when building a support CI pipeline, from the underlying hardware and test runners to the structure of the unit tests themselves as a larger unit. Integration tests do add to the overall testing time, and it’s important to keep that time short to make the value of the tests high.   Best Practices   Now that we understand why reusability, reproducibility, reliability, and speed are important for building repeatable and effective continuous integration pipelines, let’s talk about specific practices and processes that can help achieve them.   Test Automation and Coverage   To leverage the full value of continuous integration, you will need to automate all your tests and make sure they run for every change made to the repository. It’s also advisable to leverage the following:    Unit tests to verify the behavior of small methods and functions   Integration tests to make sure multiple components work together   Acceptance tests to cover behavior required on the business specifications   End-to-end tests to validate the behavior of the application as a whole from the user perspective    Adopting Continuous Integration   While automation and observability of our pipelines are important, the cultural aspects of working with continuous integration and ensuring that the team adopts the continuous integration principles are equally as important.   Integrate Early and Often   A crucial cultural aspect of continuous integration is building the habit and cadence of the team committing their code every day and multiple times per day. By pushing their code frequently, developers can quickly find conflicts between two changes and also become aware of other work.   Additionally, pushing their commits often allows developers to get feedback from the full CI pipeline running and allow them to identify defects in the code much sooner.   The rule of thumb is that developers should commit their code every day, whether it is to the mainline branch on a feature branch. The more frequently you commit, the less opportunity there will be for conflict, errors, or broken tests, significantly increasing the team’s speed.   Fail Early and Fail Fast   The whole point of continuous integration is providing rapid feedback. Nothing is more frustrating than a build that takes hours to complete, only to fail because of errors in some of the initial test suites.   It is possible that due to the size of the application, the complete set of tests (unit, integration, end-to-end) might take a while to run. To help things go smoothly, you should consider the following processes:    Breaking tests into groups (per module, per domain, and so forth) and running them in parallel   Run critical path tests first (core or fundamental logic)   Fail and stop the entire build if critical tests fail   Integrate with notifications systems (Slack, email) to let developers know as soon things fail    Make It Visible   A core tenet of continuous integration is communication, so you want to ensure that everyone can easily see the state of the system and the changes that have been made to it.   Information such as the states of integration branches and the state of the mainline build become a priority. Back in the day, engineering teams would go as far as hooking up physical traffic lights to signal the state of the mainline branch.     Semaphore CI    Nowadays, with cloud solutions being more prevalent and deeply integrated with source control systems, it’s much easier to give all developers a high degree of visibility. A perfect example is CI pipelines with GitHub Actions, which provides feedback directly on pull requests and allows you to visualize the state of a pipeline at every given step.     GitHub Actions CI    Fix Broken Builds Immediately   A crucial part of implementing continuous integrations is that if the mainline build fails, it needs to be fixed right away. One of the key points of working with CI is having a trusted, stable code base to develop against.   The mainline build breaking is not necessarily a bad thing on its own. Still, it might highlight gaps in how the team works, like people not being careful enough about updating and building locally before committing.   The fastest way to fix a broken build is to roll back to the last known good commit and review what happened. By all means, we should avoid debugging on the broken mainline; this becomes especially true when multiple teams are working on the same code base.   Conclusion   Continuous integration reduces risk by eliminating long integration efforts and reducing the feedback loops. To recap, there are many advantages to implementing continuous integration in your teams:    Allows identifying bugs and software defects faster   Reduces the feedback loop for engineers   Removes blind spots that can occur with deferred integration   Improves communication and velocity of the engineering teams    To achieve repeatability in a CI/CD pipeline, it’s essential to keep in mind the following principles:    Reliable continuous integration environments help us avoid slowing down the feedback loops for the developers and maintain speed of development.   Reproducible builds give our developers confidence to keep momentum and keep building with confidence.   Reusability allows us to leverage the tools, patterns, and environments for continuous integration across projects.   Speed reduces the feedback cycle for developers, allowing them to ship more features in a shorter time.    Finally, having continuous integration and continuous delivery removes one of the biggest barriers to implementing continuous deployment. Continuous deployment extends this flow and enables fully automated deployments into production.   The combination of continuous integration, continuous delivery, and continuous deployment allows teams to ship features faster and get them in front of customers faster, shortening the feedback loop and increasing value generation.   For anyone looking to learn more about continuous integration, I highly recommend Martin Fowler’s book Continuous Integration.">



  <meta property="og:image" content="/blog/generated/assets/images/achieving-repeatability/header-800-6c73ec10a.jpg">



  <meta name="twitter:site" content="@EarthlyTech">
  <meta name="twitter:title" content="Achieving Repeatability in Continuous Integration">
  <meta name="twitter:description" content="In software engineering, continuous integration is the practice of merging all developers’ working copies to a shared mainline several times a day. Grady Booch first proposed the term CI in his 1991 method, although he did not advocate integrating several times a day. —Wikipedia    Continuous Integration (CI) and continuous delivery (CD) are some of the best practices that any DevOps team can implement. You could argue that they’re necessary for teams looking to ship quality products fast and with confidence.   CI and CD are two pieces of a whole, the former dealing with the task to automate the process of building, testing, and integrating new features and code changes into the codebase mainline; and the latter dealing with automating the process of delivering the changes to the defined environments.   The implementation of both methodologies is often referred to as a CI/CD pipeline; it is worth noting that both for CI and CD, the operating principles and coding philosophy are equally as important as the technical aspect of the implementation.   CI’s technical goal is to provide consistent and automated results to build, package, and test applications. This repeatable flow and process allows teams to commit and merge changes more frequently, thus reducing the risk of conflicts or getting stuck in Integration Hell.    Integration Hell refers to the point in production when members on a delivery team integrate their individual code. In traditional software development environments, this integration process is rarely smooth and seamless, instead resulting in hours or perhaps days of fixing the code so that it can finally integrate. Continuous Integration (CI) aims to avoid this completely by enabling and encouraging team members to integrate frequently (e.g., hourly, or at least daily). —SolutionsIQ    This article focuses on the concepts, tools, and best practices that will allow you to achieve a high degree of repeatability and consistency on your CI/CD pipeline.   CI Repeatability Principles   One of the critical aspects of a successful and healthy CI pipeline is having repeatable builds, which guarantee consistent and reliable results. Four fundamental principles are essential to observe to achieve repeatability:    Reliability   Reproducibility   Reusability   Speed    Reliability   Reliability in continuous integration comes from knowing that the systems involved in testing the application are both available and capable of performing the complete set of tests that we need. This also means that the system has to produce consistent builds.   Reliability gives the confidence to deliver shippable working code at any time during the application lifetime.   Reproducibility   CI infrastructure and pipelines can be—and more often than not, are—software assets on their own. The work done to create and implement CI runners and pipelines for our software projects can also be built, tested, and packaged just like any other software build.   Examples of this are containerizing the environments used to run your test suites, including dependencies such as a database or ancillary applications for the end-to-end test suites.   Treating the CI pipelines as another software project also allows the development team to reproduce the same results from the CI pipeline locally and shorten the feedback loop.   Reusability   With reproducible builds, we can achieve reusability, meaning that the same tools and process can be used in more than one project. Having a system in which we are not building a special custom CI pipeline for each project allows us to find patterns that we can apply to many projects.   The type of reusable resources greatly varies depending on the type of applications and tests on each organization, from simple reusable scripts to containerized environments.   Speed   One of the primary benefits of a good and effective CI process is the feedback loop it provides to the developers working on a project. Feedback loops start losing their value and detract from developer effectiveness as they get slower.   We need to consider several factors when building a support CI pipeline, from the underlying hardware and test runners to the structure of the unit tests themselves as a larger unit. Integration tests do add to the overall testing time, and it’s important to keep that time short to make the value of the tests high.   Best Practices   Now that we understand why reusability, reproducibility, reliability, and speed are important for building repeatable and effective continuous integration pipelines, let’s talk about specific practices and processes that can help achieve them.   Test Automation and Coverage   To leverage the full value of continuous integration, you will need to automate all your tests and make sure they run for every change made to the repository. It’s also advisable to leverage the following:    Unit tests to verify the behavior of small methods and functions   Integration tests to make sure multiple components work together   Acceptance tests to cover behavior required on the business specifications   End-to-end tests to validate the behavior of the application as a whole from the user perspective    Adopting Continuous Integration   While automation and observability of our pipelines are important, the cultural aspects of working with continuous integration and ensuring that the team adopts the continuous integration principles are equally as important.   Integrate Early and Often   A crucial cultural aspect of continuous integration is building the habit and cadence of the team committing their code every day and multiple times per day. By pushing their code frequently, developers can quickly find conflicts between two changes and also become aware of other work.   Additionally, pushing their commits often allows developers to get feedback from the full CI pipeline running and allow them to identify defects in the code much sooner.   The rule of thumb is that developers should commit their code every day, whether it is to the mainline branch on a feature branch. The more frequently you commit, the less opportunity there will be for conflict, errors, or broken tests, significantly increasing the team’s speed.   Fail Early and Fail Fast   The whole point of continuous integration is providing rapid feedback. Nothing is more frustrating than a build that takes hours to complete, only to fail because of errors in some of the initial test suites.   It is possible that due to the size of the application, the complete set of tests (unit, integration, end-to-end) might take a while to run. To help things go smoothly, you should consider the following processes:    Breaking tests into groups (per module, per domain, and so forth) and running them in parallel   Run critical path tests first (core or fundamental logic)   Fail and stop the entire build if critical tests fail   Integrate with notifications systems (Slack, email) to let developers know as soon things fail    Make It Visible   A core tenet of continuous integration is communication, so you want to ensure that everyone can easily see the state of the system and the changes that have been made to it.   Information such as the states of integration branches and the state of the mainline build become a priority. Back in the day, engineering teams would go as far as hooking up physical traffic lights to signal the state of the mainline branch.     Semaphore CI    Nowadays, with cloud solutions being more prevalent and deeply integrated with source control systems, it’s much easier to give all developers a high degree of visibility. A perfect example is CI pipelines with GitHub Actions, which provides feedback directly on pull requests and allows you to visualize the state of a pipeline at every given step.     GitHub Actions CI    Fix Broken Builds Immediately   A crucial part of implementing continuous integrations is that if the mainline build fails, it needs to be fixed right away. One of the key points of working with CI is having a trusted, stable code base to develop against.   The mainline build breaking is not necessarily a bad thing on its own. Still, it might highlight gaps in how the team works, like people not being careful enough about updating and building locally before committing.   The fastest way to fix a broken build is to roll back to the last known good commit and review what happened. By all means, we should avoid debugging on the broken mainline; this becomes especially true when multiple teams are working on the same code base.   Conclusion   Continuous integration reduces risk by eliminating long integration efforts and reducing the feedback loops. To recap, there are many advantages to implementing continuous integration in your teams:    Allows identifying bugs and software defects faster   Reduces the feedback loop for engineers   Removes blind spots that can occur with deferred integration   Improves communication and velocity of the engineering teams    To achieve repeatability in a CI/CD pipeline, it’s essential to keep in mind the following principles:    Reliable continuous integration environments help us avoid slowing down the feedback loops for the developers and maintain speed of development.   Reproducible builds give our developers confidence to keep momentum and keep building with confidence.   Reusability allows us to leverage the tools, patterns, and environments for continuous integration across projects.   Speed reduces the feedback cycle for developers, allowing them to ship more features in a shorter time.    Finally, having continuous integration and continuous delivery removes one of the biggest barriers to implementing continuous deployment. Continuous deployment extends this flow and enables fully automated deployments into production.   The combination of continuous integration, continuous delivery, and continuous deployment allows teams to ship features faster and get them in front of customers faster, shortening the feedback loop and increasing value generation.   For anyone looking to learn more about continuous integration, I highly recommend Martin Fowler’s book Continuous Integration.">
  <meta name="twitter:url" content="https://earthly.dev/blog/achieving-repeatability/">

  
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://earthly.dev/blog/generated/assets/images/achieving-repeatability/header-800-6c73ec10a.jpg">
  

  



  <meta property="article:published_time" content="2021-06-01T00:00:00-04:00">





  

  


<link rel="canonical" href="https://earthly.dev/blog/achieving-repeatability/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Organization",
      "url": "https://earthly.dev/blog/",
      "logo": "/assets/images/logo-header.png"
    
  }
</script>






<!-- end _includes/seo.html -->



  <link href="/blog/feed.xml" type="application/atom+xml" rel="alternate" title="Earthly Blog Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/blog/assets/css/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->


  
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-161831101-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-161831101-5');
</script>
  <!-- Facebook Pixel Code -->
<script>
    !function(f,b,e,v,n,t,s)
    {if(f.fbq)return;n=f.fbq=function(){n.callMethod?
    n.callMethod.apply(n,arguments):n.queue.push(arguments)};
    if(!f._fbq)f._fbq=n;n.push=n;n.loaded=!0;n.version='2.0';
    n.queue=[];t=b.createElement(e);t.async=!0;
    t.src=v;s=b.getElementsByTagName(e)[0];
    s.parentNode.insertBefore(t,s)}(window, document,'script',
    'https://connect.facebook.net/en_US/fbevents.js');
    fbq('init', '259843109045285');
    fbq('track', 'PageView');
    </script>
    <noscript><img height="1" width="1" style="display:none"
    src="https://www.facebook.com/tr?id=259843109045285&ev=PageView&noscript=1"
    />
</noscript>
 <!-- End Facebook Pixel Code -->
  <!-- Twitter universal website tag code -->
<script>
  !function(e,t,n,s,u,a){e.twq||(s=e.twq=function(){s.exe?s.exe.apply(s,arguments):s.queue.push(arguments);
  },s.version='1.1',s.queue=[],u=t.createElement(n),u.async=!0,u.src='//static.ads-twitter.com/uwt.js',
  a=t.getElementsByTagName(n)[0],a.parentNode.insertBefore(u,a))}(window,document,'script');
  // Insert Twitter Pixel ID and Standard Event data below
  twq('init','o5s6p');
  twq('track','PageView');
  </script>
  <!-- End Twitter universal website tag code -->


  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/"><img src="/blog/assets/images/white-logo.png" alt="Earthly"></a>
        
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/blog/">Blog home</a>
            </li><li class="masthead__menu-item">
              <a href="/blog/categories/articles/">Articles</a>
            </li><li class="masthead__menu-item">
              <a href="/blog/categories/news/">News</a>
            </li><li class="masthead__menu-item">
              <a href="/blog/categories/tutorials/">Tutorials</a>
            </li><li class="masthead__menu-item">
              <a href="https://github.com/earthly/earthly">GitHub</a>
            </li></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      




  







<div class="page__hero"
  style=" background-image: url('');"
>
  
      <picture class="page__hero-image"><source srcset="/blog/generated/assets/images/achieving-repeatability/header-400-52a45bc2d.webp 400w, /blog/generated/assets/images/achieving-repeatability/header-600-52a45bc2d.webp 600w, /blog/generated/assets/images/achieving-repeatability/header-800-52a45bc2d.webp 800w, /blog/generated/assets/images/achieving-repeatability/header-1000-52a45bc2d.webp 1000w, /blog/generated/assets/images/achieving-repeatability/header-1200-52a45bc2d.webp 1200w" type="image/webp"><source srcset="/blog/generated/assets/images/achieving-repeatability/header-400-52a45bc2d.png 400w, /blog/generated/assets/images/achieving-repeatability/header-600-52a45bc2d.png 600w, /blog/generated/assets/images/achieving-repeatability/header-800-52a45bc2d.png 800w, /blog/generated/assets/images/achieving-repeatability/header-1000-52a45bc2d.png 1000w, /blog/generated/assets/images/achieving-repeatability/header-1200-52a45bc2d.png 1200w" type="image/png"><img src="/blog/generated/assets/images/achieving-repeatability/header-800-52a45bc2d.jpg" alt="Achieving Repeatability in Continuous Integration"></picture>

  
  
</div>





<div id="main" role="main">
  
  <div class="sidebar">
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Achieving Repeatability in Continuous Integration">
    <meta itemprop="description" content="In software engineering, continuous integration is the practice of merging all developers’ working copies to a shared mainline several times a day. Grady Booch first proposed the term CI in his 1991 method, although he did not advocate integrating several times a day. —WikipediaContinuous Integration (CI) and continuous delivery (CD) are some of the best practices that any DevOps team can implement. You could argue that they’re necessary for teams looking to ship quality products fast and with confidence.CI and CD are two pieces of a whole, the former dealing with the task to automate the process of building, testing, and integrating new features and code changes into the codebase mainline; and the latter dealing with automating the process of delivering the changes to the defined environments.The implementation of both methodologies is often referred to as a CI/CD pipeline; it is worth noting that both for CI and CD, the operating principles and coding philosophy are equally as important as the technical aspect of the implementation.CI’s technical goal is to provide consistent and automated results to build, package, and test applications. This repeatable flow and process allows teams to commit and merge changes more frequently, thus reducing the risk of conflicts or getting stuck in Integration Hell.Integration Hell refers to the point in production when members on a delivery team integrate their individual code. In traditional software development environments, this integration process is rarely smooth and seamless, instead resulting in hours or perhaps days of fixing the code so that it can finally integrate. Continuous Integration (CI) aims to avoid this completely by enabling and encouraging team members to integrate frequently (e.g., hourly, or at least daily). —SolutionsIQThis article focuses on the concepts, tools, and best practices that will allow you to achieve a high degree of repeatability and consistency on your CI/CD pipeline.CI Repeatability PrinciplesOne of the critical aspects of a successful and healthy CI pipeline is having repeatable builds, which guarantee consistent and reliable results. Four fundamental principles are essential to observe to achieve repeatability:ReliabilityReproducibilityReusabilitySpeedReliabilityReliability in continuous integration comes from knowing that the systems involved in testing the application are both available and capable of performing the complete set of tests that we need. This also means that the system has to produce consistent builds.Reliability gives the confidence to deliver shippable working code at any time during the application lifetime.ReproducibilityCI infrastructure and pipelines can be—and more often than not, are—software assets on their own. The work done to create and implement CI runners and pipelines for our software projects can also be built, tested, and packaged just like any other software build.Examples of this are containerizing the environments used to run your test suites, including dependencies such as a database or ancillary applications for the end-to-end test suites.Treating the CI pipelines as another software project also allows the development team to reproduce the same results from the CI pipeline locally and shorten the feedback loop.ReusabilityWith reproducible builds, we can achieve reusability, meaning that the same tools and process can be used in more than one project. Having a system in which we are not building a special custom CI pipeline for each project allows us to find patterns that we can apply to many projects.The type of reusable resources greatly varies depending on the type of applications and tests on each organization, from simple reusable scripts to containerized environments.SpeedOne of the primary benefits of a good and effective CI process is the feedback loop it provides to the developers working on a project. Feedback loops start losing their value and detract from developer effectiveness as they get slower.We need to consider several factors when building a support CI pipeline, from the underlying hardware and test runners to the structure of the unit tests themselves as a larger unit. Integration tests do add to the overall testing time, and it’s important to keep that time short to make the value of the tests high.Best PracticesNow that we understand why reusability, reproducibility, reliability, and speed are important for building repeatable and effective continuous integration pipelines, let’s talk about specific practices and processes that can help achieve them.Test Automation and CoverageTo leverage the full value of continuous integration, you will need to automate all your tests and make sure they run for every change made to the repository. It’s also advisable to leverage the following:Unit tests to verify the behavior of small methods and functionsIntegration tests to make sure multiple components work togetherAcceptance tests to cover behavior required on the business specificationsEnd-to-end tests to validate the behavior of the application as a whole from the user perspectiveAdopting Continuous IntegrationWhile automation and observability of our pipelines are important, the cultural aspects of working with continuous integration and ensuring that the team adopts the continuous integration principles are equally as important.Integrate Early and OftenA crucial cultural aspect of continuous integration is building the habit and cadence of the team committing their code every day and multiple times per day. By pushing their code frequently, developers can quickly find conflicts between two changes and also become aware of other work.Additionally, pushing their commits often allows developers to get feedback from the full CI pipeline running and allow them to identify defects in the code much sooner.The rule of thumb is that developers should commit their code every day, whether it is to the mainline branch on a feature branch. The more frequently you commit, the less opportunity there will be for conflict, errors, or broken tests, significantly increasing the team’s speed.Fail Early and Fail FastThe whole point of continuous integration is providing rapid feedback. Nothing is more frustrating than a build that takes hours to complete, only to fail because of errors in some of the initial test suites.It is possible that due to the size of the application, the complete set of tests (unit, integration, end-to-end) might take a while to run. To help things go smoothly, you should consider the following processes:Breaking tests into groups (per module, per domain, and so forth) and running them in parallelRun critical path tests first (core or fundamental logic)Fail and stop the entire build if critical tests failIntegrate with notifications systems (Slack, email) to let developers know as soon things failMake It VisibleA core tenet of continuous integration is communication, so you want to ensure that everyone can easily see the state of the system and the changes that have been made to it.Information such as the states of integration branches and the state of the mainline build become a priority. Back in the day, engineering teams would go as far as hooking up physical traffic lights to signal the state of the mainline branch.Semaphore CINowadays, with cloud solutions being more prevalent and deeply integrated with source control systems, it’s much easier to give all developers a high degree of visibility. A perfect example is CI pipelines with GitHub Actions, which provides feedback directly on pull requests and allows you to visualize the state of a pipeline at every given step.GitHub Actions CIFix Broken Builds ImmediatelyA crucial part of implementing continuous integrations is that if the mainline build fails, it needs to be fixed right away. One of the key points of working with CI is having a trusted, stable code base to develop against.The mainline build breaking is not necessarily a bad thing on its own. Still, it might highlight gaps in how the team works, like people not being careful enough about updating and building locally before committing.The fastest way to fix a broken build is to roll back to the last known good commit and review what happened. By all means, we should avoid debugging on the broken mainline; this becomes especially true when multiple teams are working on the same code base.ConclusionContinuous integration reduces risk by eliminating long integration efforts and reducing the feedback loops. To recap, there are many advantages to implementing continuous integration in your teams:Allows identifying bugs and software defects fasterReduces the feedback loop for engineersRemoves blind spots that can occur with deferred integrationImproves communication and velocity of the engineering teamsTo achieve repeatability in a CI/CD pipeline, it’s essential to keep in mind the following principles:Reliable continuous integration environments help us avoid slowing down the feedback loops for the developers and maintain speed of development.Reproducible builds give our developers confidence to keep momentum and keep building with confidence.Reusability allows us to leverage the tools, patterns, and environments for continuous integration across projects.Speed reduces the feedback cycle for developers, allowing them to ship more features in a shorter time.Finally, having continuous integration and continuous delivery removes one of the biggest barriers to implementing continuous deployment. Continuous deployment extends this flow and enables fully automated deployments into production.The combination of continuous integration, continuous delivery, and continuous deployment allows teams to ship features faster and get them in front of customers faster, shortening the feedback loop and increasing value generation.For anyone looking to learn more about continuous integration, I highly recommend Martin Fowler’s book Continuous Integration.">
    <meta itemprop="datePublished" content="2021-06-01T00:00:00-04:00">
    

    <div class="page__inner-wrap">
      

      <section class="page__content" itemprop="text">
        
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">Achieving Repeatability in Continuous Integration
</h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          7 minute read
        
        
        &nbsp;	&nbsp;<i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2021-06-01T00:00:00-04:00">June 1, 2021</time>
        

      </span>
    
    <span>
      
      
      
      <div class="author__avatar_top">
          <picture class="image-author"><source srcset="/blog/generated/assets/images/authors/allanmcgregor-240-8f818bdd2.webp 240w" type="image/webp"><source srcset="/blog/generated/assets/images/authors/allanmcgregor-240-0ae731b45.jpg 240w" type="image/jpeg"><img src="/blog/generated/assets/images/authors/allanmcgregor-240-0ae731b45.jpg" alt="Allan MacGregor %"></picture>

          &nbsp;	&nbsp;
          Allan MacGregor
      </div>
      
    </span>
  </p>


        </header>
      
        
          <aside class="sidebar__right ">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#ci-repeatability-principles">CI Repeatability Principles</a><ul><li><a href="#reliability">Reliability</a></li><li><a href="#reproducibility">Reproducibility</a></li><li><a href="#reusability">Reusability</a></li><li><a href="#speed">Speed</a></li></ul></li><li><a href="#best-practices">Best Practices</a><ul><li><a href="#test-automation-and-coverage">Test Automation and Coverage</a></li><li><a href="#adopting-continuous-integration">Adopting Continuous Integration</a><ul><li><a href="#integrate-early-and-often">Integrate Early and Often</a></li><li><a href="#fail-early-and-fail-fast">Fail Early and Fail Fast</a></li><li><a href="#make-it-visible">Make It Visible</a></li><li><a href="#fix-broken-builds-immediately">Fix Broken Builds Immediately</a></li></ul></li></ul></li><li><a href="#conclusion">Conclusion</a></li></ul>

            </nav>
          </aside>
        
        <blockquote>
<p>In software engineering, continuous integration is the practice of merging all developers’ working copies to a shared mainline several times a day. Grady Booch first proposed the term CI in his 1991 method, although he did not advocate integrating several times a day. —<a href="https://en.wikipedia.org/wiki/Continuous_integration" title="Wikipedia article on continuous integration">Wikipedia</a></p>
</blockquote>
<p>Continuous Integration (CI) and continuous delivery (CD) are some of the best practices that any DevOps team can implement. You could argue that they’re necessary for teams looking to ship quality products fast and with confidence.</p>
<p>CI and CD are two pieces of a whole, the former dealing with the task to automate the process of building, testing, and integrating new features and code changes into the codebase mainline; and the latter dealing with automating the process of delivering the changes to the defined environments.</p>
<p>The implementation of both methodologies is often referred to as a <strong>CI/CD pipeline</strong>; it is worth noting that both for CI and CD, the operating principles and coding philosophy are equally as important as the technical aspect of the implementation.</p>
<p>CI’s technical goal is to provide consistent and automated results to build, package, and test applications. This repeatable flow and process allows teams to commit and merge changes more frequently, thus reducing the risk of conflicts or getting stuck in <strong>Integration Hell</strong>.</p>
<blockquote>
<p>Integration Hell refers to the point in production when members on a delivery team integrate their individual code. In traditional software development environments, this integration process is rarely smooth and seamless, instead resulting in hours or perhaps days of fixing the code so that it can finally integrate. Continuous Integration (CI) aims to avoid this completely by enabling and encouraging team members to integrate frequently (e.g., hourly, or at least daily). —<a href="https://www.solutionsiq.com/agile-glossary/integration-hell/" title="Accenture | SolutionsIQ&#39;s definition of Integration Hell">SolutionsIQ</a></p>
</blockquote>
<p>This article focuses on the concepts, tools, and best practices that will allow you to achieve a high degree of repeatability and consistency on your CI/CD pipeline.</p>
<h2 id="ci-repeatability-principles">CI Repeatability Principles</h2>
<p>One of the critical aspects of a successful and healthy CI pipeline is having repeatable builds, which guarantee consistent and reliable results. Four fundamental principles are essential to observe to achieve repeatability:</p>
<ul>
<li>Reliability</li>
<li>Reproducibility</li>
<li>Reusability</li>
<li>Speed</li>
</ul>
<h3 id="reliability">Reliability</h3>
<p>Reliability in continuous integration comes from knowing that the systems involved in testing the application are both available and capable of performing the complete set of tests that we need. This also means that the system has to produce consistent builds.</p>
<p>Reliability gives the confidence to deliver shippable working code at any time during the application lifetime.</p>
<h3 id="reproducibility">Reproducibility</h3>
<p>CI infrastructure and pipelines can be—and more often than not, are—software assets on their own. The work done to create and implement CI runners and pipelines for our software projects can also be built, tested, and packaged just like any other software build.</p>
<p>Examples of this are containerizing the environments used to run your test suites, including dependencies such as a database or ancillary applications for the end-to-end test suites.</p>
<p>Treating the CI pipelines as another software project also allows the development team to reproduce the same results from the CI pipeline locally and shorten the feedback loop.</p>
<h3 id="reusability">Reusability</h3>
<p>With reproducible builds, we can achieve reusability, meaning that the same tools and process can be used in more than one project. Having a system in which we are not building a special custom CI pipeline for each project allows us to find patterns that we can apply to many projects.</p>
<p>The type of reusable resources greatly varies depending on the type of applications and tests on each organization, from simple reusable scripts to containerized environments.</p>
<h3 id="speed">Speed</h3>
<p>One of the primary benefits of a good and effective CI process is the feedback loop it provides to the developers working on a project. Feedback loops start losing their value and <a href="https://martinfowler.com/articles/developer-effectiveness.html" title="Tim Cochran&#39;s article on maximizing developer effectiveness at MartinFowler.com">detract from developer effectiveness as they get slower</a>.</p>
<p>We need to consider several factors when building a support CI pipeline, from the underlying hardware and test runners to the structure of the unit tests themselves as a larger unit. Integration tests do add to the overall testing time, and it’s important to keep that time short to make the value of the tests high.</p>
<h2 id="best-practices">Best Practices</h2>
<p>Now that we understand why <strong>reusability</strong>, <strong>reproducibility</strong>, <strong>reliability</strong>, and <strong>speed</strong> are important for building repeatable and effective continuous integration pipelines, let’s talk about specific practices and processes that can help achieve them.</p>
<h3 id="test-automation-and-coverage">Test Automation and Coverage</h3>
<p>To leverage the full value of continuous integration, you will need to automate all your tests and make sure they run for every change made to the repository. It’s also advisable to leverage the following:</p>
<ul>
<li><strong>Unit tests</strong> to verify the behavior of small methods and functions</li>
<li><strong>Integration tests</strong> to make sure multiple components work together</li>
<li><strong>Acceptance tests</strong> to cover behavior required on the business specifications</li>
<li><strong>End-to-end tests</strong> to validate the behavior of the application as a whole from the user perspective</li>
</ul>
<h3 id="adopting-continuous-integration">Adopting Continuous Integration</h3>
<p>While automation and observability of our pipelines are important, the cultural aspects of working with continuous integration and ensuring that the team adopts the continuous integration principles are equally as important.</p>
<h4 id="integrate-early-and-often">Integrate Early and Often</h4>
<p>A crucial cultural aspect of continuous integration is building the habit and cadence of the team committing their code every day and multiple times per day. By pushing their code frequently, developers can quickly find conflicts between two changes and also become aware of other work.</p>
<p>Additionally, pushing their commits often allows developers to get feedback from the full CI pipeline running and allow them to identify defects in the code much sooner.</p>
<p>The rule of thumb is that developers should commit their code every day, whether it is to the mainline branch on a feature branch. The more frequently you commit, the less opportunity there will be for conflict, errors, or broken tests, significantly increasing the team’s speed.</p>
<h4 id="fail-early-and-fail-fast">Fail Early and Fail Fast</h4>
<p>The whole point of continuous integration is providing rapid feedback. Nothing is more frustrating than a build that takes hours to complete, only to fail because of errors in some of the initial test suites.</p>
<p>It is possible that due to the size of the application, the complete set of tests (unit, integration, end-to-end) might take a while to run. To help things go smoothly, you should consider the following processes:</p>
<ul>
<li>Breaking tests into groups (per module, per domain, and so forth) and running them in parallel</li>
<li>Run critical path tests first (core or fundamental logic)</li>
<li>Fail and stop the entire build if critical tests fail</li>
<li>Integrate with notifications systems (Slack, email) to let developers know as soon things fail</li>
</ul>
<h4 id="make-it-visible">Make It Visible</h4>
<p>A core tenet of continuous integration is communication, so you want to ensure that everyone can easily see the state of the system and the changes that have been made to it.</p>
<p>Information such as the states of integration branches and the state of the mainline build become a priority. Back in the day, engineering teams would go as far as hooking up physical traffic lights to signal the state of the mainline branch.</p>
<figure>
<img src="/blog/assets/images/achieving-repeatability/anBo2up.png" alt="Semaphore CI" /><figcaption aria-hidden="true">Semaphore CI</figcaption>
</figure>
<p>Nowadays, with cloud solutions being more prevalent and deeply integrated with source control systems, it’s much easier to give all developers a high degree of visibility. A perfect example is CI pipelines with <a href="https://github.com/features/actions" title="GitHub Actions workflow automation">GitHub Actions</a>, which provides feedback directly on pull requests and allows you to visualize the state of a pipeline at every given step.</p>
<figure>
<img src="/blog/assets/images/achieving-repeatability/twM26E6.png" alt="GitHub Actions CI" /><figcaption aria-hidden="true">GitHub Actions CI</figcaption>
</figure>
<h4 id="fix-broken-builds-immediately">Fix Broken Builds Immediately</h4>
<p>A crucial part of implementing continuous integrations is that if the mainline build fails, it needs to be fixed right away. One of the key points of working with CI is having a trusted, stable code base to develop against.</p>
<p>The mainline build breaking is not necessarily a bad thing on its own. Still, it might highlight gaps in how the team works, like people not being careful enough about updating and building locally before committing.</p>
<p>The fastest way to fix a broken build is to roll back to the last known good commit and review what happened. By all means, we should avoid debugging on the broken mainline; this becomes especially true when multiple teams are working on the same code base.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Continuous integration reduces risk by eliminating long integration efforts and reducing the feedback loops. To recap, there are many advantages to implementing continuous integration in your teams:</p>
<ul>
<li>Allows identifying bugs and software defects faster</li>
<li>Reduces the feedback loop for engineers</li>
<li>Removes blind spots that can occur with deferred integration</li>
<li>Improves communication and velocity of the engineering teams</li>
</ul>
<p>To achieve repeatability in a CI/CD pipeline, it’s essential to keep in mind the following principles:</p>
<ul>
<li><strong>Reliable</strong> continuous integration environments help us avoid slowing down the feedback loops for the developers and maintain <strong>speed</strong> of development.</li>
<li><strong>Reproducible</strong> builds give our developers confidence to keep momentum and keep building with confidence.</li>
<li><strong>Reusability</strong> allows us to leverage the tools, patterns, and environments for continuous integration across projects.</li>
<li><strong>Speed</strong> reduces the feedback cycle for developers, allowing them to ship more features in a shorter time.</li>
</ul>
<p>Finally, having continuous integration and continuous delivery removes one of the biggest barriers to implementing <strong>continuous deployment</strong>. Continuous deployment extends this flow and enables fully automated deployments into production.</p>
<p>The combination of continuous integration, continuous delivery, and continuous deployment allows teams to ship features faster and get them in front of customers faster, shortening the feedback loop and increasing value generation.</p>
<p>For anyone looking to learn more about continuous integration, I highly recommend <a href="https://martinfowler.com/">Martin Fowler’s</a> book <a href="https://www.martinfowler.com/books/duvall.html" title="Continuous Integration by Martin Fowler">Continuous Integration</a>.</p>

        
      </section>

      


<div itemscope itemtype="https://schema.org/Person">
  <!-- <h5>About The Author</h5> -->

  
    <div class="author__avatar">
      
        <picture class="image-author"><source srcset="/blog/generated/assets/images/authors/allanmcgregor-240-8f818bdd2.webp 240w" type="image/webp"><source srcset="/blog/generated/assets/images/authors/allanmcgregor-240-0ae731b45.jpg 240w" type="image/jpeg"><img src="/blog/generated/assets/images/authors/allanmcgregor-240-0ae731b45.jpg" alt="Allan MacGregor %"></picture>

      
    </div>
  

  <div class="author__content">
    
      <h4 class="author__name" itemprop="name">
        Allan MacGregor
    
    
    </h4>
    
      <div class="author__bio" itemprop="description">
        <p>Allan MacGregor is a software engineer and entrepreneur based in Toronto, with experience in building projects and developing innovative solutions.</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <!-- <button class="btn btn--inverse">Follow</button> -->
    <ul class="author__urls social-icons">
      

     

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

      <footer class="page__meta">
        
        



  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/blog/categories/tutorials" class="page__taxonomy-item" rel="tag">Tutorials</a>
    
    </span>
  </p>



        
  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2021-06-01T00:00:00-04:00">June 1, 2021</time></p>


      </footer>

      

      
  <nav class="pagination">
    
      <a href="/blog/jruby/" class="pagination--pager" title="Why is JRuby Slow?
">Previous</a>
    
    
      <a href="/blog/creating-and-hosting-your-own-deb-packages-and-apt-repo/" class="pagination--pager" title="Creating and hosting your own deb packages and apt repo
">Next</a>
    
  </nav>

    </div>
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">You may also enjoy</h4>
      <div class="grid__wrapper">
        
          










<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
      <div class="archive__item-teaser">
        <picture><source srcset="/blog/generated/assets/images/example/teaser-600-fc9eab451.webp 600w, /blog/generated/assets/images/example/teaser-800-fc9eab451.webp 800w" type="image/webp"><source srcset="/blog/generated/assets/images/example/teaser-600-b449882ef.jpg 600w, /blog/generated/assets/images/example/teaser-800-b449882ef.jpg 800w" type="image/jpeg"><img src="/blog/generated/assets/images/example/teaser-800-b449882ef.jpg"></picture>

      </div>
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/blog/example/" rel="permalink">Example Post
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          4 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">

This post is in the future, and won’t show up in the published site


Image without figure


An image with the alt text hidden.





An image with alt text...</p>
  </article>
</div>

        
          










<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
      <div class="archive__item-teaser">
        <picture><source srcset="/blog/generated/assets/images/golang-makefile/header-600-c2a6f06af.webp 600w, /blog/generated/assets/images/golang-makefile/header-800-c2a6f06af.webp 800w" type="image/webp"><source srcset="/blog/generated/assets/images/golang-makefile/header-600-a3886f2c1.jpg 600w, /blog/generated/assets/images/golang-makefile/header-800-a3886f2c1.jpg 800w" type="image/jpeg"><img src="/blog/generated/assets/images/golang-makefile/header-800-a3886f2c1.jpg"></picture>

      </div>
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/blog/golang-makefile/" rel="permalink">Creating a Golang Makefile
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          6 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">

Building and testing any large codebase is time-consuming, error-prone, and repetitive. Golang supports multi-platform builds, which is excellent, but it n...</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
          <li><a href="https://twitter.com/earthlytech" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
        
          <li><a href="https://github.com/earthly/earthly" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
      
    

    
      <li><a href="/blog/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2021 <a href="https://earthly.dev/">Earthly</a>. </div>

      </footer>
    </div>

    <script src="/blog/assets/js/vendor/jquery/jquery-3.5.1.js"></script>
<script src="/blog/assets/js/plugins/jquery.fitvids.js"></script>
<script src="/blog/assets/js/plugins/smooth-scroll.js"></script>
<script src="/blog/assets/js/plugins/gumshoe.js"></script>
<script src="/blog/assets/js/plugins/jquery.magnific-popup.js"></script>
<script src="/blog/assets/js/main.min.js"></script>

  <script> // minified version of https://earthly.dev/assets/js/analytics.js
    function setCookie(e,t,r){var i="";if(r){var o=new Date;o.setTime(o.getTime()+24*r*60*60*1e3),i="; expires="+o.toUTCString()}document.cookie=e+"="+(t||"")+i+"; path=/"}function getCookie(e){for(var t=e+"=",r=document.cookie.split(";"),i=0;i<r.length;i++){for(var o=r[i];" "==o.charAt(0);)o=o.substring(1,o.length);if(0==o.indexOf(t))return o.substring(t.length,o.length)}return null}function uuidv4(){return([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,e=>(e^crypto.getRandomValues(new Uint8Array(1))[0]&15>>e/4).toString(16))}function getAnalyticCookie(){cookieName="earthlyID";var e=getCookie(cookieName);return null==e&&(e=uuidv4()),setCookie(cookieName,e,36500),e}jQuery.ajax({type:"POST",url:"https://api.earthly.dev/analytics",data:JSON.stringify({key:"website",url:window.location.href,referrer:document.referrer,earthlyID:getAnalyticCookie()})});
</script>




  </body>
</html>
