<!doctype html>
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">
<link rel="icon" type="image/png" href="/blog/assets/images/favicon.png">
<!-- begin _includes/seo.html -->





<title>What Is Continuous Integration? - Earthly Blog</title>
<meta name="description" content="Continuous integration has become prevalent in software development, but it’s still a complex and wide-ranging topic. In this post, we’ll cover the basics of continuous integration, the differences between CI and CD, and common CI tools. You’ll also find some tips for the best way to set up CI in your environment.   What Is Continuous Integration?   Continuous integration (CI) is a set of operating principles and practices in the DevOps process that helps software development teams release faster and more reliable application updates. With the advancement of modern tooling, most CI processes center around automated tests, static analysis, and building releasable software. This process is helpful for teams that want to ensure each update to their software is working, stable, and ready to deploy before they integrate it into their production environment.   For example, if a team member makes a change to a project, they might make updates on a new branch (assuming they’re using git for version control). When complete, they push these changes to a shared repository where a continuous integration workflow will automatically install dependencies, run tests, and check for linting errors before merging the changes into the main branch.   The Relationship Between Continuous Integration and Continuous Delivery/Deployment   Continuous integration is the first part of the CI/CD process. The CD stands for either continuous delivery or continuous deployment. Although these terms are sometimes used interchangeably, they are not quite the same.   In both cases, code is released in short cycles. However, with continuous delivery, code changes are automatically deployed through the development and testing stages, but must be manually reviewed and approved before being batched and released to production.   With continuous deployment, code changes that successfully pass through all stages of the development process are automatically released to production without human intervention. A failed test along the pipeline is the only event that will prevent a change from reaching production.   Why CI Is Important to Software Development    “Continuous integration doesn’t get rid of bugs, but it does make them dramatically easier to find and remove.” – Martin Fowler, Chief Scientist, ThoughtWorks    Before continuous integration became an industry standard, developers’ changes were tested less frequently, often only when it was time to release a new version of the software. This meant the team had to spend unnecessary hours fixing bugs that could have been caught earlier in the process with a robust continuous integration process.   CI helps developers avoid such problems while increasing productivity. Because code changes are automatically and continuously tested, verified, and built, developers should not have to manually check for integration issues. Because testing in CI is frequent and automated, developers can find and address bugs faster and earlier in the software development life cycle. This promotes a culture that delivers faster, higher-quality releases into production.   How CI Works   CI validates changes upon check-in using an automated build process that also runs validation and integration tests. The continuous integration process aims to detect bugs and errors faster and eliminate the integration issues that occur when developers work in isolation, resulting in higher quality software releases and faster delivery times.   A Typical CI Build Process     Earthly integration diagram    In a typical CI build process, developers push code changes from a branch to a central repository such as GitHub. CI automation servers such as Jenkins and CircleCI continuously monitor the repository to check for code updates.   Once it detects a change, the automation server triggers the build process to compile and build the code, then run validation and integration tests. CI automation servers interface with compilation tools such as Docker, Bash, and Makefile to create deployable artifacts such as binaries, packages, or Docker images. When continuous deployment is employed, the built application is then deployed and run on subsequent testing or production environments. Other developers can also pull down the resulting image and test locally.   If the build fails, the development team will typically receive an alert, allowing them to fix any errors that occur.   How Has CI Changed in the Past Few Years?   CI became popular as an integral part of agile software development but has since developed into one of the pillars of the DevOps process. Guided by key principles such as revision control, software integration, and build automation, it is now an industry standard in software development.   As DevOps practices continue to evolve, we see trends moving toward self-service and a more cloud-centric model to give developers more autonomy. Because of COVID-19, CIOs and other IT leaders have recognized the need to adjust and adapt to support more cloud-based workflows and applications. Moving forward, cloud-native approaches, including multi-cloud solutions, will become the standard for hosting, pipelines, storage, and load balancing.   As part of the self-service trend, developers will no longer have to wait for a separate operations team to dispatch new applications or updates, but will instead be able to build DevOps infrastructure that allows them to deploy updates themselves. Self-service capabilities are already available today for several DevOps processes, including development environments, CI/CD workflows, and audit logging.   Common Tools for CI   Your choice of CI tools will largely depend on your business requirements, the tech stack you already have or plan to implement, and your daily workflow. There are many CI tools and solutions to choose from. Let’s look at four of them.   Jenkins   Jenkins is the most well-known continuous integration tool and has a reputation for reliability. Written in Java, it’s an open-source cross-platform tool with a large community following that contributes to its development.   Jenkins works as a standalone CI server or a continuous delivery platform and offers several features to support the entire software development life cycle, including automated builds and testing, code debugging and analysis, and project deployment.   It can run on any operating system including Windows, OS X, and Unix, and you can easily configure it via a web GUI interface or console commands. Jenkins is highly extensible; thanks to its robust ecosystem of almost 1400 plugins, you can add several features for user interface, platform integration, source code management and builds, and administrative tasks.    Where is it hosted? Self-hosted; cloud   What platform does it run? Containers; virtual machines   What is its pricing model? Open source      Jenkins CI/CD Tool    CircleCI   CircleCI is an excellent platform for build automation and testing along with a branch-focused deployment process. It integrates seamlessly with several version control systems, container systems, and delivery mechanisms, including GitHub and Bitbucket as well as build tools such as Gradle and Apache Maven. You can host CircleCI on premise or integrate it with AWS, Google Cloud, and other cloud services. It’s highly customizable and performance-optimized for quick builds, and it also provides analytics to measure build performance.    Where is it hosted? Self-hosted; cloud   What platform does it run? Containers; virtual machine   What is its pricing model? Free entry-level version; Premium starts at $30      Circle CI CI/CD tool    GitHub Actions   Introduced in 2018, GitHub Actions is one of the newer tools in the CI/CD tech stack. It is fully integrated within GitHub, making it manageable from a single place.   Integration with GitHub means you can build, test, and deploy code directly from your GitHub repository. GitHub manages the execution and provides feedback and security for the entire CI process.   GitHub Actions offers a wide range of automation tasks and actions that allow you to create, share, reuse, and branch software development workflows directly in your GitHub repository. It also supports Docker for multi-container testing and offers several CI templates.    Where is it hosted? Self-hosted; cloud   What platform does it run? Container; virtual machine   What is its pricing model? Free for public repositories and self-hosted runners. For private repositories, build minutes/month depend on account type and spending limits      GitHub Actions CI/CD tool    Azure DevOps   Azure DevOps by Microsoft is a platform for creating a CI/CD pipeline to Azure. It provides several advanced features and services that support the software development cycle from planning to deployment. Azure DevOps integrates with both Team Foundation Version Control and Git for version control, code repository management, and build automation.   Azure DevOps also integrates with major languages and platforms, allowing you to build, test and deploy in Java, .Net, Android, or iOS. It also runs parallel on Linux, macOS, and Windows and on both virtual machines and containers.   One standout feature of Azure DevOps is that it supports automated load testing, which can simulate thousands of users using your app at the same time. This helps your developers uncover bottlenecks and improve throughput before an application is released.    Where is it hosted? Self-hosted; cloud   What platform does it run? Container; virtual machine   What is its pricing model? Free up to a specific number of builds, but build servers can be reserved at a cost for higher volumes      Azure DevOps CI/CD Tool    Continuous Integration Best Practices   To get the most out of your CI process, you’ll need to set it up with the following best practices: consistency between environments, disciplined use of the CI/CD pipeline (no sidestepping it for special cases), prioritizing tests by speed, and the “Build Once” practice.   Strive for Consistency Between Environments   We’ve all had it happen: code that works perfectly in your development environment throws a hissy fit in production.   Your CI environment should either match production exactly or be customized in a way that mitigates any bugs that might happen due to the difference in the two environments. The wider the difference between your development or staging and production environments, the less accurate your tests will be in showing how the code will perform in the real world.   A few ways to make sure that your environments are consistent are as follows:    Using blue-green deployments. This release strategy involves running two parallel versions of the production environment and involves using a load balancer to swap production traffic between two environments alternately designated as production (green) and staging (blue).   Deploy a scaled-down version of your production environment to your development or staging environment. If you’re using this method, ensure that the code is consistent and that differences between the two environments are well-documented.   Use a clone of the production environment to make sure that your CI environment is an exact match.    All Deployments Must Go Through CI   CI acts as a watchman to enforce best practices in the development process and ensure that changes are in line with your company’s standards and procedures. A failure during integration is flagged immediately and prevents the affected code from moving forward into other parts of the development process. This protects subsequent environments like production from untrusted or error-prone code.   For CI to be successful, you’ll need to make sure that the CI/CD pipeline is the only mechanism through which code enters your production environment. This could be via continuous delivery with manual approval processes and batched releases or through automated continuous deployment practices.   Development teams may feel pressured to make exceptions and circumvent the CI process when problems arise. It’s tempting to bypass the system to mitigate excessive downtime and fix other issues as soon as possible, but adhering to the CI/CD pipeline helps ensure that the changes being made won’t worsen the current problem or introduce new ones.   Sending all changes through the CI/CD pipeline helps to protect the integrity of your deployments and prevents ad hoc fixes from being erased by subsequent updates.   Run Your Fastest Tests/Checks First   The general goal of the CI/CD process is to provide rapid feedback to developers and promote rapid software delivery to users. You want to keep the entire pipeline fast, but the reality is that some parts will be faster than others. If developers have to wait too long to get feedback from testing, they might look for ways around the process.   Because you want to discover failures as early as possible, prioritize and run the tests that complete quickest first and leave longer running tests until later.   This usually means running your unit tests first, as those are faster, make up most of your tests, and can give you immediate feedback on bugs and errors introduced by the latest update. After unit testing is complete, run integration tests next to see how different parts of your code interact. Then follow up with system-wide tests such as GUI, performance, load and security tests, and manual acceptance tests.   Build Only Once and Promote the Result Through the Pipeline   One aim of CI/CD is to ensure that your end product is robust and won’t produce unexpected results. This is why it’s important to perform your build step only once and then advance resulting binaries through the entire pipeline. Software builds that occur separately at each new stage of the pipeline can introduce inconsistencies, and tests completed in earlier environments become invalid because they may not be targeting the same software that is eventually deployed.   In the “Build Once” best practice, the build process always occurs as the first step in the pipeline, and the resulting artifact is versioned and uploaded to the central repository where it can be pulled and used in the later stages. This ensures that the build does not change as it moves through the pipeline.   What’s Next?   Continuous integration speeds up the software development process and helps development teams avoid common pitfalls such as broken application builds, and chaotic release cycles. Rather than catching issues just before (or even after) they’re released, continuous integration allows you to mitigate errors while you’re working on a feature.   Earthly is a free and open-source build automation tool that works with your existing build systems to create repeatable, containerized, language-agnostic builds. It acts as a layer between language-specific tools such as Gradle and Apache Maven and the CI buildspec and allows for faster iteration on build scripts and easier debugging. You can discuss automation and other topics in the Earthly Community on Slack.   To find out more about how Earthly can help you simplify your CI systems, check us out on GitHub. With CI automation in place, developers can push changes more frequently, get faster feedback, and ensure that every change is integrated, tested, and verified.">


  <meta name="author" content="Deborah Ruck">
  
  <meta property="article:author" content="Deborah Ruck">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Earthly Blog">
<meta property="og:title" content="What Is Continuous Integration?">
<meta property="og:url" content="https://earthly.dev/blog/continuous-integration/">


  <meta property="og:description" content="Continuous integration has become prevalent in software development, but it’s still a complex and wide-ranging topic. In this post, we’ll cover the basics of continuous integration, the differences between CI and CD, and common CI tools. You’ll also find some tips for the best way to set up CI in your environment.   What Is Continuous Integration?   Continuous integration (CI) is a set of operating principles and practices in the DevOps process that helps software development teams release faster and more reliable application updates. With the advancement of modern tooling, most CI processes center around automated tests, static analysis, and building releasable software. This process is helpful for teams that want to ensure each update to their software is working, stable, and ready to deploy before they integrate it into their production environment.   For example, if a team member makes a change to a project, they might make updates on a new branch (assuming they’re using git for version control). When complete, they push these changes to a shared repository where a continuous integration workflow will automatically install dependencies, run tests, and check for linting errors before merging the changes into the main branch.   The Relationship Between Continuous Integration and Continuous Delivery/Deployment   Continuous integration is the first part of the CI/CD process. The CD stands for either continuous delivery or continuous deployment. Although these terms are sometimes used interchangeably, they are not quite the same.   In both cases, code is released in short cycles. However, with continuous delivery, code changes are automatically deployed through the development and testing stages, but must be manually reviewed and approved before being batched and released to production.   With continuous deployment, code changes that successfully pass through all stages of the development process are automatically released to production without human intervention. A failed test along the pipeline is the only event that will prevent a change from reaching production.   Why CI Is Important to Software Development    “Continuous integration doesn’t get rid of bugs, but it does make them dramatically easier to find and remove.” – Martin Fowler, Chief Scientist, ThoughtWorks    Before continuous integration became an industry standard, developers’ changes were tested less frequently, often only when it was time to release a new version of the software. This meant the team had to spend unnecessary hours fixing bugs that could have been caught earlier in the process with a robust continuous integration process.   CI helps developers avoid such problems while increasing productivity. Because code changes are automatically and continuously tested, verified, and built, developers should not have to manually check for integration issues. Because testing in CI is frequent and automated, developers can find and address bugs faster and earlier in the software development life cycle. This promotes a culture that delivers faster, higher-quality releases into production.   How CI Works   CI validates changes upon check-in using an automated build process that also runs validation and integration tests. The continuous integration process aims to detect bugs and errors faster and eliminate the integration issues that occur when developers work in isolation, resulting in higher quality software releases and faster delivery times.   A Typical CI Build Process     Earthly integration diagram    In a typical CI build process, developers push code changes from a branch to a central repository such as GitHub. CI automation servers such as Jenkins and CircleCI continuously monitor the repository to check for code updates.   Once it detects a change, the automation server triggers the build process to compile and build the code, then run validation and integration tests. CI automation servers interface with compilation tools such as Docker, Bash, and Makefile to create deployable artifacts such as binaries, packages, or Docker images. When continuous deployment is employed, the built application is then deployed and run on subsequent testing or production environments. Other developers can also pull down the resulting image and test locally.   If the build fails, the development team will typically receive an alert, allowing them to fix any errors that occur.   How Has CI Changed in the Past Few Years?   CI became popular as an integral part of agile software development but has since developed into one of the pillars of the DevOps process. Guided by key principles such as revision control, software integration, and build automation, it is now an industry standard in software development.   As DevOps practices continue to evolve, we see trends moving toward self-service and a more cloud-centric model to give developers more autonomy. Because of COVID-19, CIOs and other IT leaders have recognized the need to adjust and adapt to support more cloud-based workflows and applications. Moving forward, cloud-native approaches, including multi-cloud solutions, will become the standard for hosting, pipelines, storage, and load balancing.   As part of the self-service trend, developers will no longer have to wait for a separate operations team to dispatch new applications or updates, but will instead be able to build DevOps infrastructure that allows them to deploy updates themselves. Self-service capabilities are already available today for several DevOps processes, including development environments, CI/CD workflows, and audit logging.   Common Tools for CI   Your choice of CI tools will largely depend on your business requirements, the tech stack you already have or plan to implement, and your daily workflow. There are many CI tools and solutions to choose from. Let’s look at four of them.   Jenkins   Jenkins is the most well-known continuous integration tool and has a reputation for reliability. Written in Java, it’s an open-source cross-platform tool with a large community following that contributes to its development.   Jenkins works as a standalone CI server or a continuous delivery platform and offers several features to support the entire software development life cycle, including automated builds and testing, code debugging and analysis, and project deployment.   It can run on any operating system including Windows, OS X, and Unix, and you can easily configure it via a web GUI interface or console commands. Jenkins is highly extensible; thanks to its robust ecosystem of almost 1400 plugins, you can add several features for user interface, platform integration, source code management and builds, and administrative tasks.    Where is it hosted? Self-hosted; cloud   What platform does it run? Containers; virtual machines   What is its pricing model? Open source      Jenkins CI/CD Tool    CircleCI   CircleCI is an excellent platform for build automation and testing along with a branch-focused deployment process. It integrates seamlessly with several version control systems, container systems, and delivery mechanisms, including GitHub and Bitbucket as well as build tools such as Gradle and Apache Maven. You can host CircleCI on premise or integrate it with AWS, Google Cloud, and other cloud services. It’s highly customizable and performance-optimized for quick builds, and it also provides analytics to measure build performance.    Where is it hosted? Self-hosted; cloud   What platform does it run? Containers; virtual machine   What is its pricing model? Free entry-level version; Premium starts at $30      Circle CI CI/CD tool    GitHub Actions   Introduced in 2018, GitHub Actions is one of the newer tools in the CI/CD tech stack. It is fully integrated within GitHub, making it manageable from a single place.   Integration with GitHub means you can build, test, and deploy code directly from your GitHub repository. GitHub manages the execution and provides feedback and security for the entire CI process.   GitHub Actions offers a wide range of automation tasks and actions that allow you to create, share, reuse, and branch software development workflows directly in your GitHub repository. It also supports Docker for multi-container testing and offers several CI templates.    Where is it hosted? Self-hosted; cloud   What platform does it run? Container; virtual machine   What is its pricing model? Free for public repositories and self-hosted runners. For private repositories, build minutes/month depend on account type and spending limits      GitHub Actions CI/CD tool    Azure DevOps   Azure DevOps by Microsoft is a platform for creating a CI/CD pipeline to Azure. It provides several advanced features and services that support the software development cycle from planning to deployment. Azure DevOps integrates with both Team Foundation Version Control and Git for version control, code repository management, and build automation.   Azure DevOps also integrates with major languages and platforms, allowing you to build, test and deploy in Java, .Net, Android, or iOS. It also runs parallel on Linux, macOS, and Windows and on both virtual machines and containers.   One standout feature of Azure DevOps is that it supports automated load testing, which can simulate thousands of users using your app at the same time. This helps your developers uncover bottlenecks and improve throughput before an application is released.    Where is it hosted? Self-hosted; cloud   What platform does it run? Container; virtual machine   What is its pricing model? Free up to a specific number of builds, but build servers can be reserved at a cost for higher volumes      Azure DevOps CI/CD Tool    Continuous Integration Best Practices   To get the most out of your CI process, you’ll need to set it up with the following best practices: consistency between environments, disciplined use of the CI/CD pipeline (no sidestepping it for special cases), prioritizing tests by speed, and the “Build Once” practice.   Strive for Consistency Between Environments   We’ve all had it happen: code that works perfectly in your development environment throws a hissy fit in production.   Your CI environment should either match production exactly or be customized in a way that mitigates any bugs that might happen due to the difference in the two environments. The wider the difference between your development or staging and production environments, the less accurate your tests will be in showing how the code will perform in the real world.   A few ways to make sure that your environments are consistent are as follows:    Using blue-green deployments. This release strategy involves running two parallel versions of the production environment and involves using a load balancer to swap production traffic between two environments alternately designated as production (green) and staging (blue).   Deploy a scaled-down version of your production environment to your development or staging environment. If you’re using this method, ensure that the code is consistent and that differences between the two environments are well-documented.   Use a clone of the production environment to make sure that your CI environment is an exact match.    All Deployments Must Go Through CI   CI acts as a watchman to enforce best practices in the development process and ensure that changes are in line with your company’s standards and procedures. A failure during integration is flagged immediately and prevents the affected code from moving forward into other parts of the development process. This protects subsequent environments like production from untrusted or error-prone code.   For CI to be successful, you’ll need to make sure that the CI/CD pipeline is the only mechanism through which code enters your production environment. This could be via continuous delivery with manual approval processes and batched releases or through automated continuous deployment practices.   Development teams may feel pressured to make exceptions and circumvent the CI process when problems arise. It’s tempting to bypass the system to mitigate excessive downtime and fix other issues as soon as possible, but adhering to the CI/CD pipeline helps ensure that the changes being made won’t worsen the current problem or introduce new ones.   Sending all changes through the CI/CD pipeline helps to protect the integrity of your deployments and prevents ad hoc fixes from being erased by subsequent updates.   Run Your Fastest Tests/Checks First   The general goal of the CI/CD process is to provide rapid feedback to developers and promote rapid software delivery to users. You want to keep the entire pipeline fast, but the reality is that some parts will be faster than others. If developers have to wait too long to get feedback from testing, they might look for ways around the process.   Because you want to discover failures as early as possible, prioritize and run the tests that complete quickest first and leave longer running tests until later.   This usually means running your unit tests first, as those are faster, make up most of your tests, and can give you immediate feedback on bugs and errors introduced by the latest update. After unit testing is complete, run integration tests next to see how different parts of your code interact. Then follow up with system-wide tests such as GUI, performance, load and security tests, and manual acceptance tests.   Build Only Once and Promote the Result Through the Pipeline   One aim of CI/CD is to ensure that your end product is robust and won’t produce unexpected results. This is why it’s important to perform your build step only once and then advance resulting binaries through the entire pipeline. Software builds that occur separately at each new stage of the pipeline can introduce inconsistencies, and tests completed in earlier environments become invalid because they may not be targeting the same software that is eventually deployed.   In the “Build Once” best practice, the build process always occurs as the first step in the pipeline, and the resulting artifact is versioned and uploaded to the central repository where it can be pulled and used in the later stages. This ensures that the build does not change as it moves through the pipeline.   What’s Next?   Continuous integration speeds up the software development process and helps development teams avoid common pitfalls such as broken application builds, and chaotic release cycles. Rather than catching issues just before (or even after) they’re released, continuous integration allows you to mitigate errors while you’re working on a feature.   Earthly is a free and open-source build automation tool that works with your existing build systems to create repeatable, containerized, language-agnostic builds. It acts as a layer between language-specific tools such as Gradle and Apache Maven and the CI buildspec and allows for faster iteration on build scripts and easier debugging. You can discuss automation and other topics in the Earthly Community on Slack.   To find out more about how Earthly can help you simplify your CI systems, check us out on GitHub. With CI automation in place, developers can push changes more frequently, get faster feedback, and ensure that every change is integrated, tested, and verified.">



  <meta property="og:image" content="/blog/generated/assets/images/continuous-integration/header-800-9917dbdc9.jpg">



  <meta name="twitter:site" content="@EarthlyTech">
  <meta name="twitter:title" content="What Is Continuous Integration?">
  <meta name="twitter:description" content="Continuous integration has become prevalent in software development, but it’s still a complex and wide-ranging topic. In this post, we’ll cover the basics of continuous integration, the differences between CI and CD, and common CI tools. You’ll also find some tips for the best way to set up CI in your environment.   What Is Continuous Integration?   Continuous integration (CI) is a set of operating principles and practices in the DevOps process that helps software development teams release faster and more reliable application updates. With the advancement of modern tooling, most CI processes center around automated tests, static analysis, and building releasable software. This process is helpful for teams that want to ensure each update to their software is working, stable, and ready to deploy before they integrate it into their production environment.   For example, if a team member makes a change to a project, they might make updates on a new branch (assuming they’re using git for version control). When complete, they push these changes to a shared repository where a continuous integration workflow will automatically install dependencies, run tests, and check for linting errors before merging the changes into the main branch.   The Relationship Between Continuous Integration and Continuous Delivery/Deployment   Continuous integration is the first part of the CI/CD process. The CD stands for either continuous delivery or continuous deployment. Although these terms are sometimes used interchangeably, they are not quite the same.   In both cases, code is released in short cycles. However, with continuous delivery, code changes are automatically deployed through the development and testing stages, but must be manually reviewed and approved before being batched and released to production.   With continuous deployment, code changes that successfully pass through all stages of the development process are automatically released to production without human intervention. A failed test along the pipeline is the only event that will prevent a change from reaching production.   Why CI Is Important to Software Development    “Continuous integration doesn’t get rid of bugs, but it does make them dramatically easier to find and remove.” – Martin Fowler, Chief Scientist, ThoughtWorks    Before continuous integration became an industry standard, developers’ changes were tested less frequently, often only when it was time to release a new version of the software. This meant the team had to spend unnecessary hours fixing bugs that could have been caught earlier in the process with a robust continuous integration process.   CI helps developers avoid such problems while increasing productivity. Because code changes are automatically and continuously tested, verified, and built, developers should not have to manually check for integration issues. Because testing in CI is frequent and automated, developers can find and address bugs faster and earlier in the software development life cycle. This promotes a culture that delivers faster, higher-quality releases into production.   How CI Works   CI validates changes upon check-in using an automated build process that also runs validation and integration tests. The continuous integration process aims to detect bugs and errors faster and eliminate the integration issues that occur when developers work in isolation, resulting in higher quality software releases and faster delivery times.   A Typical CI Build Process     Earthly integration diagram    In a typical CI build process, developers push code changes from a branch to a central repository such as GitHub. CI automation servers such as Jenkins and CircleCI continuously monitor the repository to check for code updates.   Once it detects a change, the automation server triggers the build process to compile and build the code, then run validation and integration tests. CI automation servers interface with compilation tools such as Docker, Bash, and Makefile to create deployable artifacts such as binaries, packages, or Docker images. When continuous deployment is employed, the built application is then deployed and run on subsequent testing or production environments. Other developers can also pull down the resulting image and test locally.   If the build fails, the development team will typically receive an alert, allowing them to fix any errors that occur.   How Has CI Changed in the Past Few Years?   CI became popular as an integral part of agile software development but has since developed into one of the pillars of the DevOps process. Guided by key principles such as revision control, software integration, and build automation, it is now an industry standard in software development.   As DevOps practices continue to evolve, we see trends moving toward self-service and a more cloud-centric model to give developers more autonomy. Because of COVID-19, CIOs and other IT leaders have recognized the need to adjust and adapt to support more cloud-based workflows and applications. Moving forward, cloud-native approaches, including multi-cloud solutions, will become the standard for hosting, pipelines, storage, and load balancing.   As part of the self-service trend, developers will no longer have to wait for a separate operations team to dispatch new applications or updates, but will instead be able to build DevOps infrastructure that allows them to deploy updates themselves. Self-service capabilities are already available today for several DevOps processes, including development environments, CI/CD workflows, and audit logging.   Common Tools for CI   Your choice of CI tools will largely depend on your business requirements, the tech stack you already have or plan to implement, and your daily workflow. There are many CI tools and solutions to choose from. Let’s look at four of them.   Jenkins   Jenkins is the most well-known continuous integration tool and has a reputation for reliability. Written in Java, it’s an open-source cross-platform tool with a large community following that contributes to its development.   Jenkins works as a standalone CI server or a continuous delivery platform and offers several features to support the entire software development life cycle, including automated builds and testing, code debugging and analysis, and project deployment.   It can run on any operating system including Windows, OS X, and Unix, and you can easily configure it via a web GUI interface or console commands. Jenkins is highly extensible; thanks to its robust ecosystem of almost 1400 plugins, you can add several features for user interface, platform integration, source code management and builds, and administrative tasks.    Where is it hosted? Self-hosted; cloud   What platform does it run? Containers; virtual machines   What is its pricing model? Open source      Jenkins CI/CD Tool    CircleCI   CircleCI is an excellent platform for build automation and testing along with a branch-focused deployment process. It integrates seamlessly with several version control systems, container systems, and delivery mechanisms, including GitHub and Bitbucket as well as build tools such as Gradle and Apache Maven. You can host CircleCI on premise or integrate it with AWS, Google Cloud, and other cloud services. It’s highly customizable and performance-optimized for quick builds, and it also provides analytics to measure build performance.    Where is it hosted? Self-hosted; cloud   What platform does it run? Containers; virtual machine   What is its pricing model? Free entry-level version; Premium starts at $30      Circle CI CI/CD tool    GitHub Actions   Introduced in 2018, GitHub Actions is one of the newer tools in the CI/CD tech stack. It is fully integrated within GitHub, making it manageable from a single place.   Integration with GitHub means you can build, test, and deploy code directly from your GitHub repository. GitHub manages the execution and provides feedback and security for the entire CI process.   GitHub Actions offers a wide range of automation tasks and actions that allow you to create, share, reuse, and branch software development workflows directly in your GitHub repository. It also supports Docker for multi-container testing and offers several CI templates.    Where is it hosted? Self-hosted; cloud   What platform does it run? Container; virtual machine   What is its pricing model? Free for public repositories and self-hosted runners. For private repositories, build minutes/month depend on account type and spending limits      GitHub Actions CI/CD tool    Azure DevOps   Azure DevOps by Microsoft is a platform for creating a CI/CD pipeline to Azure. It provides several advanced features and services that support the software development cycle from planning to deployment. Azure DevOps integrates with both Team Foundation Version Control and Git for version control, code repository management, and build automation.   Azure DevOps also integrates with major languages and platforms, allowing you to build, test and deploy in Java, .Net, Android, or iOS. It also runs parallel on Linux, macOS, and Windows and on both virtual machines and containers.   One standout feature of Azure DevOps is that it supports automated load testing, which can simulate thousands of users using your app at the same time. This helps your developers uncover bottlenecks and improve throughput before an application is released.    Where is it hosted? Self-hosted; cloud   What platform does it run? Container; virtual machine   What is its pricing model? Free up to a specific number of builds, but build servers can be reserved at a cost for higher volumes      Azure DevOps CI/CD Tool    Continuous Integration Best Practices   To get the most out of your CI process, you’ll need to set it up with the following best practices: consistency between environments, disciplined use of the CI/CD pipeline (no sidestepping it for special cases), prioritizing tests by speed, and the “Build Once” practice.   Strive for Consistency Between Environments   We’ve all had it happen: code that works perfectly in your development environment throws a hissy fit in production.   Your CI environment should either match production exactly or be customized in a way that mitigates any bugs that might happen due to the difference in the two environments. The wider the difference between your development or staging and production environments, the less accurate your tests will be in showing how the code will perform in the real world.   A few ways to make sure that your environments are consistent are as follows:    Using blue-green deployments. This release strategy involves running two parallel versions of the production environment and involves using a load balancer to swap production traffic between two environments alternately designated as production (green) and staging (blue).   Deploy a scaled-down version of your production environment to your development or staging environment. If you’re using this method, ensure that the code is consistent and that differences between the two environments are well-documented.   Use a clone of the production environment to make sure that your CI environment is an exact match.    All Deployments Must Go Through CI   CI acts as a watchman to enforce best practices in the development process and ensure that changes are in line with your company’s standards and procedures. A failure during integration is flagged immediately and prevents the affected code from moving forward into other parts of the development process. This protects subsequent environments like production from untrusted or error-prone code.   For CI to be successful, you’ll need to make sure that the CI/CD pipeline is the only mechanism through which code enters your production environment. This could be via continuous delivery with manual approval processes and batched releases or through automated continuous deployment practices.   Development teams may feel pressured to make exceptions and circumvent the CI process when problems arise. It’s tempting to bypass the system to mitigate excessive downtime and fix other issues as soon as possible, but adhering to the CI/CD pipeline helps ensure that the changes being made won’t worsen the current problem or introduce new ones.   Sending all changes through the CI/CD pipeline helps to protect the integrity of your deployments and prevents ad hoc fixes from being erased by subsequent updates.   Run Your Fastest Tests/Checks First   The general goal of the CI/CD process is to provide rapid feedback to developers and promote rapid software delivery to users. You want to keep the entire pipeline fast, but the reality is that some parts will be faster than others. If developers have to wait too long to get feedback from testing, they might look for ways around the process.   Because you want to discover failures as early as possible, prioritize and run the tests that complete quickest first and leave longer running tests until later.   This usually means running your unit tests first, as those are faster, make up most of your tests, and can give you immediate feedback on bugs and errors introduced by the latest update. After unit testing is complete, run integration tests next to see how different parts of your code interact. Then follow up with system-wide tests such as GUI, performance, load and security tests, and manual acceptance tests.   Build Only Once and Promote the Result Through the Pipeline   One aim of CI/CD is to ensure that your end product is robust and won’t produce unexpected results. This is why it’s important to perform your build step only once and then advance resulting binaries through the entire pipeline. Software builds that occur separately at each new stage of the pipeline can introduce inconsistencies, and tests completed in earlier environments become invalid because they may not be targeting the same software that is eventually deployed.   In the “Build Once” best practice, the build process always occurs as the first step in the pipeline, and the resulting artifact is versioned and uploaded to the central repository where it can be pulled and used in the later stages. This ensures that the build does not change as it moves through the pipeline.   What’s Next?   Continuous integration speeds up the software development process and helps development teams avoid common pitfalls such as broken application builds, and chaotic release cycles. Rather than catching issues just before (or even after) they’re released, continuous integration allows you to mitigate errors while you’re working on a feature.   Earthly is a free and open-source build automation tool that works with your existing build systems to create repeatable, containerized, language-agnostic builds. It acts as a layer between language-specific tools such as Gradle and Apache Maven and the CI buildspec and allows for faster iteration on build scripts and easier debugging. You can discuss automation and other topics in the Earthly Community on Slack.   To find out more about how Earthly can help you simplify your CI systems, check us out on GitHub. With CI automation in place, developers can push changes more frequently, get faster feedback, and ensure that every change is integrated, tested, and verified.">
  <meta name="twitter:url" content="https://earthly.dev/blog/continuous-integration/">

  
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://earthly.dev/blog/generated/assets/images/continuous-integration/header-800-9917dbdc9.jpg">
  

  



  <meta property="article:published_time" content="2021-05-17T00:00:00-04:00">





  

  


<link rel="canonical" href="https://earthly.dev/blog/continuous-integration/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Organization",
      "url": "https://earthly.dev/blog/",
      "logo": "/assets/images/logo-header.png"
    
  }
</script>






<!-- end _includes/seo.html -->



  <link href="/blog/feed.xml" type="application/atom+xml" rel="alternate" title="Earthly Blog Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/blog/assets/css/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->


  
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-161831101-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-161831101-5');
</script>
  <!-- Facebook Pixel Code -->
<script>
    !function(f,b,e,v,n,t,s)
    {if(f.fbq)return;n=f.fbq=function(){n.callMethod?
    n.callMethod.apply(n,arguments):n.queue.push(arguments)};
    if(!f._fbq)f._fbq=n;n.push=n;n.loaded=!0;n.version='2.0';
    n.queue=[];t=b.createElement(e);t.async=!0;
    t.src=v;s=b.getElementsByTagName(e)[0];
    s.parentNode.insertBefore(t,s)}(window, document,'script',
    'https://connect.facebook.net/en_US/fbevents.js');
    fbq('init', '259843109045285');
    fbq('track', 'PageView');
    </script>
    <noscript><img height="1" width="1" style="display:none"
    src="https://www.facebook.com/tr?id=259843109045285&ev=PageView&noscript=1"
    />
</noscript>
 <!-- End Facebook Pixel Code -->
  <!-- Twitter universal website tag code -->
<script>
  !function(e,t,n,s,u,a){e.twq||(s=e.twq=function(){s.exe?s.exe.apply(s,arguments):s.queue.push(arguments);
  },s.version='1.1',s.queue=[],u=t.createElement(n),u.async=!0,u.src='//static.ads-twitter.com/uwt.js',
  a=t.getElementsByTagName(n)[0],a.parentNode.insertBefore(u,a))}(window,document,'script');
  // Insert Twitter Pixel ID and Standard Event data below
  twq('init','o5s6p');
  twq('track','PageView');
  </script>
  <!-- End Twitter universal website tag code -->


  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/"><img src="/blog/assets/images/white-logo.png" alt="Earthly"></a>
        
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/blog/">Blog home</a>
            </li><li class="masthead__menu-item">
              <a href="/blog/categories/articles/">Articles</a>
            </li><li class="masthead__menu-item">
              <a href="/blog/categories/news/">News</a>
            </li><li class="masthead__menu-item">
              <a href="/blog/categories/tutorials/">Tutorials</a>
            </li><li class="masthead__menu-item">
              <a href="https://github.com/earthly/earthly">GitHub</a>
            </li></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      




  







<div class="page__hero"
  style=" background-image: url('');"
>
  
      <picture class="page__hero-image"><source srcset="/blog/generated/assets/images/continuous-integration/header-400-86bc25bf9.webp 400w, /blog/generated/assets/images/continuous-integration/header-600-86bc25bf9.webp 600w, /blog/generated/assets/images/continuous-integration/header-800-86bc25bf9.webp 800w, /blog/generated/assets/images/continuous-integration/header-1000-86bc25bf9.webp 1000w, /blog/generated/assets/images/continuous-integration/header-1200-86bc25bf9.webp 1200w" type="image/webp"><source srcset="/blog/generated/assets/images/continuous-integration/header-400-86bc25bf9.png 400w, /blog/generated/assets/images/continuous-integration/header-600-86bc25bf9.png 600w, /blog/generated/assets/images/continuous-integration/header-800-86bc25bf9.png 800w, /blog/generated/assets/images/continuous-integration/header-1000-86bc25bf9.png 1000w, /blog/generated/assets/images/continuous-integration/header-1200-86bc25bf9.png 1200w" type="image/png"><img src="/blog/generated/assets/images/continuous-integration/header-800-86bc25bf9.jpg" alt="What Is Continuous Integration?"></picture>

  
  
</div>





<div id="main" role="main">
  
  <div class="sidebar">
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="What Is Continuous Integration?">
    <meta itemprop="description" content="Continuous integration has become prevalent in software development, but it’s still a complex and wide-ranging topic. In this post, we’ll cover the basics of continuous integration, the differences between CI and CD, and common CI tools. You’ll also find some tips for the best way to set up CI in your environment.What Is Continuous Integration?Continuous integration (CI) is a set of operating principles and practices in the DevOps process that helps software development teams release faster and more reliable application updates. With the advancement of modern tooling, most CI processes center around automated tests, static analysis, and building releasable software. This process is helpful for teams that want to ensure each update to their software is working, stable, and ready to deploy before they integrate it into their production environment.For example, if a team member makes a change to a project, they might make updates on a new branch (assuming they’re using git for version control). When complete, they push these changes to a shared repository where a continuous integration workflow will automatically install dependencies, run tests, and check for linting errors before merging the changes into the main branch.The Relationship Between Continuous Integration and Continuous Delivery/DeploymentContinuous integration is the first part of the CI/CD process. The CD stands for either continuous delivery or continuous deployment. Although these terms are sometimes used interchangeably, they are not quite the same.In both cases, code is released in short cycles. However, with continuous delivery, code changes are automatically deployed through the development and testing stages, but must be manually reviewed and approved before being batched and released to production.With continuous deployment, code changes that successfully pass through all stages of the development process are automatically released to production without human intervention. A failed test along the pipeline is the only event that will prevent a change from reaching production.Why CI Is Important to Software Development“Continuous integration doesn’t get rid of bugs, but it does make them dramatically easier to find and remove.” – Martin Fowler, Chief Scientist, ThoughtWorksBefore continuous integration became an industry standard, developers’ changes were tested less frequently, often only when it was time to release a new version of the software. This meant the team had to spend unnecessary hours fixing bugs that could have been caught earlier in the process with a robust continuous integration process.CI helps developers avoid such problems while increasing productivity. Because code changes are automatically and continuously tested, verified, and built, developers should not have to manually check for integration issues. Because testing in CI is frequent and automated, developers can find and address bugs faster and earlier in the software development life cycle. This promotes a culture that delivers faster, higher-quality releases into production.How CI WorksCI validates changes upon check-in using an automated build process that also runs validation and integration tests. The continuous integration process aims to detect bugs and errors faster and eliminate the integration issues that occur when developers work in isolation, resulting in higher quality software releases and faster delivery times.A Typical CI Build ProcessEarthly integration diagramIn a typical CI build process, developers push code changes from a branch to a central repository such as GitHub. CI automation servers such as Jenkins and CircleCI continuously monitor the repository to check for code updates.Once it detects a change, the automation server triggers the build process to compile and build the code, then run validation and integration tests. CI automation servers interface with compilation tools such as Docker, Bash, and Makefile to create deployable artifacts such as binaries, packages, or Docker images. When continuous deployment is employed, the built application is then deployed and run on subsequent testing or production environments. Other developers can also pull down the resulting image and test locally.If the build fails, the development team will typically receive an alert, allowing them to fix any errors that occur.How Has CI Changed in the Past Few Years?CI became popular as an integral part of agile software development but has since developed into one of the pillars of the DevOps process. Guided by key principles such as revision control, software integration, and build automation, it is now an industry standard in software development.As DevOps practices continue to evolve, we see trends moving toward self-service and a more cloud-centric model to give developers more autonomy. Because of COVID-19, CIOs and other IT leaders have recognized the need to adjust and adapt to support more cloud-based workflows and applications. Moving forward, cloud-native approaches, including multi-cloud solutions, will become the standard for hosting, pipelines, storage, and load balancing.As part of the self-service trend, developers will no longer have to wait for a separate operations team to dispatch new applications or updates, but will instead be able to build DevOps infrastructure that allows them to deploy updates themselves. Self-service capabilities are already available today for several DevOps processes, including development environments, CI/CD workflows, and audit logging.Common Tools for CIYour choice of CI tools will largely depend on your business requirements, the tech stack you already have or plan to implement, and your daily workflow. There are many CI tools and solutions to choose from. Let’s look at four of them.JenkinsJenkins is the most well-known continuous integration tool and has a reputation for reliability. Written in Java, it’s an open-source cross-platform tool with a large community following that contributes to its development.Jenkins works as a standalone CI server or a continuous delivery platform and offers several features to support the entire software development life cycle, including automated builds and testing, code debugging and analysis, and project deployment.It can run on any operating system including Windows, OS X, and Unix, and you can easily configure it via a web GUI interface or console commands. Jenkins is highly extensible; thanks to its robust ecosystem of almost 1400 plugins, you can add several features for user interface, platform integration, source code management and builds, and administrative tasks.Where is it hosted? Self-hosted; cloudWhat platform does it run? Containers; virtual machinesWhat is its pricing model? Open sourceJenkins CI/CD ToolCircleCICircleCI is an excellent platform for build automation and testing along with a branch-focused deployment process. It integrates seamlessly with several version control systems, container systems, and delivery mechanisms, including GitHub and Bitbucket as well as build tools such as Gradle and Apache Maven. You can host CircleCI on premise or integrate it with AWS, Google Cloud, and other cloud services. It’s highly customizable and performance-optimized for quick builds, and it also provides analytics to measure build performance.Where is it hosted? Self-hosted; cloudWhat platform does it run? Containers; virtual machineWhat is its pricing model? Free entry-level version; Premium starts at $30Circle CI CI/CD toolGitHub ActionsIntroduced in 2018, GitHub Actions is one of the newer tools in the CI/CD tech stack. It is fully integrated within GitHub, making it manageable from a single place.Integration with GitHub means you can build, test, and deploy code directly from your GitHub repository. GitHub manages the execution and provides feedback and security for the entire CI process.GitHub Actions offers a wide range of automation tasks and actions that allow you to create, share, reuse, and branch software development workflows directly in your GitHub repository. It also supports Docker for multi-container testing and offers several CI templates.Where is it hosted? Self-hosted; cloudWhat platform does it run? Container; virtual machineWhat is its pricing model? Free for public repositories and self-hosted runners. For private repositories, build minutes/month depend on account type and spending limitsGitHub Actions CI/CD toolAzure DevOpsAzure DevOps by Microsoft is a platform for creating a CI/CD pipeline to Azure. It provides several advanced features and services that support the software development cycle from planning to deployment. Azure DevOps integrates with both Team Foundation Version Control and Git for version control, code repository management, and build automation.Azure DevOps also integrates with major languages and platforms, allowing you to build, test and deploy in Java, .Net, Android, or iOS. It also runs parallel on Linux, macOS, and Windows and on both virtual machines and containers.One standout feature of Azure DevOps is that it supports automated load testing, which can simulate thousands of users using your app at the same time. This helps your developers uncover bottlenecks and improve throughput before an application is released.Where is it hosted? Self-hosted; cloudWhat platform does it run? Container; virtual machineWhat is its pricing model? Free up to a specific number of builds, but build servers can be reserved at a cost for higher volumesAzure DevOps CI/CD ToolContinuous Integration Best PracticesTo get the most out of your CI process, you’ll need to set it up with the following best practices: consistency between environments, disciplined use of the CI/CD pipeline (no sidestepping it for special cases), prioritizing tests by speed, and the “Build Once” practice.Strive for Consistency Between EnvironmentsWe’ve all had it happen: code that works perfectly in your development environment throws a hissy fit in production.Your CI environment should either match production exactly or be customized in a way that mitigates any bugs that might happen due to the difference in the two environments. The wider the difference between your development or staging and production environments, the less accurate your tests will be in showing how the code will perform in the real world.A few ways to make sure that your environments are consistent are as follows:Using blue-green deployments. This release strategy involves running two parallel versions of the production environment and involves using a load balancer to swap production traffic between two environments alternately designated as production (green) and staging (blue).Deploy a scaled-down version of your production environment to your development or staging environment. If you’re using this method, ensure that the code is consistent and that differences between the two environments are well-documented.Use a clone of the production environment to make sure that your CI environment is an exact match.All Deployments Must Go Through CICI acts as a watchman to enforce best practices in the development process and ensure that changes are in line with your company’s standards and procedures. A failure during integration is flagged immediately and prevents the affected code from moving forward into other parts of the development process. This protects subsequent environments like production from untrusted or error-prone code.For CI to be successful, you’ll need to make sure that the CI/CD pipeline is the only mechanism through which code enters your production environment. This could be via continuous delivery with manual approval processes and batched releases or through automated continuous deployment practices.Development teams may feel pressured to make exceptions and circumvent the CI process when problems arise. It’s tempting to bypass the system to mitigate excessive downtime and fix other issues as soon as possible, but adhering to the CI/CD pipeline helps ensure that the changes being made won’t worsen the current problem or introduce new ones.Sending all changes through the CI/CD pipeline helps to protect the integrity of your deployments and prevents ad hoc fixes from being erased by subsequent updates.Run Your Fastest Tests/Checks FirstThe general goal of the CI/CD process is to provide rapid feedback to developers and promote rapid software delivery to users. You want to keep the entire pipeline fast, but the reality is that some parts will be faster than others. If developers have to wait too long to get feedback from testing, they might look for ways around the process.Because you want to discover failures as early as possible, prioritize and run the tests that complete quickest first and leave longer running tests until later.This usually means running your unit tests first, as those are faster, make up most of your tests, and can give you immediate feedback on bugs and errors introduced by the latest update. After unit testing is complete, run integration tests next to see how different parts of your code interact. Then follow up with system-wide tests such as GUI, performance, load and security tests, and manual acceptance tests.Build Only Once and Promote the Result Through the PipelineOne aim of CI/CD is to ensure that your end product is robust and won’t produce unexpected results. This is why it’s important to perform your build step only once and then advance resulting binaries through the entire pipeline. Software builds that occur separately at each new stage of the pipeline can introduce inconsistencies, and tests completed in earlier environments become invalid because they may not be targeting the same software that is eventually deployed.In the “Build Once” best practice, the build process always occurs as the first step in the pipeline, and the resulting artifact is versioned and uploaded to the central repository where it can be pulled and used in the later stages. This ensures that the build does not change as it moves through the pipeline.What’s Next?Continuous integration speeds up the software development process and helps development teams avoid common pitfalls such as broken application builds, and chaotic release cycles. Rather than catching issues just before (or even after) they’re released, continuous integration allows you to mitigate errors while you’re working on a feature.Earthly is a free and open-source build automation tool that works with your existing build systems to create repeatable, containerized, language-agnostic builds. It acts as a layer between language-specific tools such as Gradle and Apache Maven and the CI buildspec and allows for faster iteration on build scripts and easier debugging. You can discuss automation and other topics in the Earthly Community on Slack.To find out more about how Earthly can help you simplify your CI systems, check us out on GitHub. With CI automation in place, developers can push changes more frequently, get faster feedback, and ensure that every change is integrated, tested, and verified.">
    <meta itemprop="datePublished" content="2021-05-17T00:00:00-04:00">
    

    <div class="page__inner-wrap">
      

      <section class="page__content" itemprop="text">
        
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">What Is Continuous Integration?
</h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          11 minute read
        
        
        &nbsp;	&nbsp;<i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2021-05-17T00:00:00-04:00">May 17, 2021</time>
        

      </span>
    
    <span>
      
      
      
      <div class="author__avatar_top">
          <picture class="image-author"><source srcset="/blog/generated/assets/images/authors/deborahruck-240-5d060f805.webp 240w" type="image/webp"><source srcset="/blog/generated/assets/images/authors/deborahruck-240-5cea5d792.jpg 240w" type="image/jpeg"><img src="/blog/generated/assets/images/authors/deborahruck-240-5cea5d792.jpg" alt="Deborah Ruck %"></picture>

          &nbsp;	&nbsp;
          Deborah Ruck
      </div>
      
    </span>
  </p>


        </header>
      
        
          <aside class="sidebar__right ">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#what-is-continuous-integration">What Is Continuous Integration?</a></li><li><a href="#the-relationship-between-continuous-integration-and-continuous-deliverydeployment">The Relationship Between Continuous Integration and Continuous Delivery/Deployment</a><ul><li><a href="#why-ci-is-important-to-software-development">Why CI Is Important to Software Development</a></li></ul></li><li><a href="#how-ci-works">How CI Works</a><ul><li><a href="#a-typical-ci-build-process">A Typical CI Build Process</a></li><li><a href="#how-has-ci-changed-in-the-past-few-years">How Has CI Changed in the Past Few Years?</a></li></ul></li><li><a href="#common-tools-for-ci">Common Tools for CI</a><ul><li><a href="#jenkins">Jenkins</a></li><li><a href="#circleci">CircleCI</a></li><li><a href="#github-actions">GitHub Actions</a></li><li><a href="#azure-devops">Azure DevOps</a></li></ul></li><li><a href="#continuous-integration-best-practices">Continuous Integration Best Practices</a><ul><li><a href="#strive-for-consistency-between-environments">Strive for Consistency Between Environments</a></li><li><a href="#all-deployments-must-go-through-ci">All Deployments Must Go Through CI</a></li><li><a href="#run-your-fastest-testschecks-first">Run Your Fastest Tests/Checks First</a></li><li><a href="#build-only-once-and-promote-the-result-through-the-pipeline">Build Only Once and Promote the Result Through the Pipeline</a></li></ul></li><li><a href="#whats-next">What’s Next?</a></li></ul>

            </nav>
          </aside>
        
        <p>Continuous integration has become prevalent in software development, but it’s still a complex and wide-ranging topic. In this post, we’ll cover the basics of continuous integration, the differences between CI and CD, and common CI tools. You’ll also find some tips for the best way to set up CI in your environment.</p>
<h2 id="what-is-continuous-integration">What Is Continuous Integration?</h2>
<p>Continuous integration (CI) is a set of operating principles and practices in the DevOps process that helps software development teams release faster and more reliable application updates. With the advancement of modern tooling, most CI processes center around automated tests, static analysis, and building releasable software. This process is helpful for teams that want to ensure each update to their software is working, stable, and ready to deploy before they integrate it into their production environment.</p>
<p>For example, if a team member makes a change to a project, they might make updates on a new branch (assuming they’re using <a href="https://git-scm.com/">git for version control</a>). When complete, they <em>push</em> these changes to a shared <a href="/blog/monorepo-vs-polyrepo">repository</a> where a continuous integration workflow will automatically install dependencies, run tests, and check for linting errors before merging the changes into the main branch.</p>
<h2 id="the-relationship-between-continuous-integration-and-continuous-deliverydeployment">The Relationship Between Continuous Integration and Continuous Delivery/Deployment</h2>
<p>Continuous integration is the first part of the CI/CD process. The <em>CD</em> stands for either <em>continuous delivery</em> or <em>continuous deployment</em>. Although these terms are sometimes used interchangeably, they are not quite the same.</p>
<p>In both cases, code is released in short cycles. However, with continuous delivery, code changes are automatically deployed through the development and <a href="/blog/unit-vs-integration">testing stages</a>, but must be manually reviewed and approved before being batched and released to production.</p>
<p>With continuous deployment, code changes that successfully pass through all stages of the development process are automatically released to production without human intervention. A failed test along the pipeline is the only event that will prevent a change from reaching production.</p>
<h3 id="why-ci-is-important-to-software-development">Why CI Is Important to Software Development</h3>
<blockquote>
<p>“Continuous integration doesn’t get rid of bugs, but it does make them dramatically easier to find and remove.” – <a href="http://www.thoughtworks.com/continuous-integration?utm_source=Codeship&amp;utm_medium=CI-Guide" title="CI explainer at ThoughtWorks">Martin Fowler</a>, Chief Scientist, ThoughtWorks</p>
</blockquote>
<p>Before continuous integration became an industry standard, developers’ changes were tested less frequently, often only when it was time to release a new version of the software. This meant the team had to spend unnecessary hours fixing bugs that could have been caught earlier in the process with a robust continuous integration process.</p>
<p>CI helps developers avoid such problems while increasing productivity. Because code changes are automatically and continuously tested, verified, and built, developers should not have to manually check for integration issues. Because testing in CI is frequent and automated, developers can find and address bugs faster and earlier in the software development life cycle. This promotes a culture that delivers faster, higher-quality releases into production.</p>
<h2 id="how-ci-works">How CI Works</h2>
<p>CI validates changes upon check-in using an automated build process that also runs validation and integration tests. The continuous integration process aims to detect bugs and errors faster and eliminate the integration issues that occur when developers work in isolation, resulting in higher quality software releases and faster delivery times.</p>
<h3 id="a-typical-ci-build-process">A Typical CI Build Process</h3>
<figure>
<img src="/blog/assets/images/continuous-integration/r80Ri4R.png" alt="Earthly integration diagram" /><figcaption aria-hidden="true">Earthly integration diagram</figcaption>
</figure>
<p>In a typical CI build process, developers push code changes from a branch to a central repository such as GitHub. CI automation servers such as Jenkins and CircleCI continuously monitor the repository to check for code updates.</p>
<p>Once it detects a change, the automation server triggers the build process to compile and build the code, then run validation and integration tests. CI automation servers interface with compilation tools such as Docker, Bash, and Makefile to create deployable artifacts such as binaries, packages, or Docker images. When continuous deployment is employed, the built application is then deployed and run on subsequent testing or production environments. Other developers can also pull down the resulting image and test locally.</p>
<p>If the build fails, the development team will typically receive an alert, allowing them to fix any errors that occur.</p>
<h3 id="how-has-ci-changed-in-the-past-few-years">How Has CI Changed in the Past Few Years?</h3>
<p>CI became popular as an integral part of agile software development but has since developed into one of the pillars of the DevOps process. Guided by key principles such as revision control, software integration, and build automation, it is now an industry standard in software development.</p>
<p>As DevOps practices <a href="https://www.novelvista.com/blogs/project-management/3-devops-trends-in-2020" title="NovelVista blog on DevOps changes in 2020">continue to evolve</a>, we see trends moving toward self-service and a more cloud-centric model to give developers more autonomy. Because of COVID-19, CIOs and other IT leaders have recognized the need to adjust and adapt to support more cloud-based workflows and applications. Moving forward, cloud-native approaches, including multi-cloud solutions, will become the standard for hosting, pipelines, storage, and load balancing.</p>
<p>As part of the self-service trend, developers will no longer have to wait for a separate operations team to dispatch new applications or updates, but will instead be able to build DevOps infrastructure that allows them to deploy updates themselves. Self-service capabilities are already available today for several DevOps processes, including development environments, CI/CD workflows, and audit logging.</p>
<h2 id="common-tools-for-ci">Common Tools for CI</h2>
<p>Your choice of CI tools will largely depend on your business requirements, the tech stack you already have or plan to implement, and your daily workflow. There are many CI tools and solutions to choose from. Let’s look at four of them.</p>
<h3 id="jenkins">Jenkins</h3>
<p><a href="https://www.jenkins.io/">Jenkins</a> is the most well-known continuous integration tool and has a reputation for reliability. Written in Java, it’s an open-source cross-platform tool with a large community following that contributes to its development.</p>
<p>Jenkins works as a standalone CI server or a continuous delivery platform and offers several features to support the entire software development life cycle, including automated builds and testing, code debugging and analysis, and project deployment.</p>
<p>It can run on any operating system including Windows, OS X, and Unix, and you can easily configure it via a web GUI interface or console commands. Jenkins is highly extensible; thanks to its robust ecosystem of almost 1400 plugins, you can add several features for user interface, platform integration, source code management and builds, and administrative tasks.</p>
<ul>
<li><strong>Where is it hosted?</strong> Self-hosted; cloud</li>
<li><strong>What platform does it run?</strong> Containers; virtual machines</li>
<li><strong>What is its pricing model?</strong> Open source</li>
</ul>
<figure>
<img src="/blog/assets/images/continuous-integration/xoiqawt.png" alt="Jenkins CI/CD Tool" /><figcaption aria-hidden="true">Jenkins CI/CD Tool</figcaption>
</figure>
<h3 id="circleci">CircleCI</h3>
<p><a href="https://circleci.com/">CircleCI</a> is an excellent platform for build automation and testing along with a branch-focused deployment process. It integrates seamlessly with several version control systems, container systems, and delivery mechanisms, including GitHub and Bitbucket as well as build tools such as Gradle and Apache Maven. You can host CircleCI on premise or integrate it with AWS, Google Cloud, and other cloud services. It’s highly customizable and performance-optimized for quick builds, and it also provides analytics to measure build performance.</p>
<ul>
<li><strong>Where is it hosted?</strong> Self-hosted; cloud</li>
<li><strong>What platform does it run?</strong> Containers; virtual machine</li>
<li><strong>What is its pricing model?</strong> Free entry-level version; Premium starts at $30</li>
</ul>
<figure>
<img src="/blog/assets/images/continuous-integration/HmA7mZy.png" title="Circle CI CI/CD tool" alt="Circle CI CI/CD tool" /><figcaption aria-hidden="true">Circle CI CI/CD tool</figcaption>
</figure>
<h3 id="github-actions">GitHub Actions</h3>
<p>Introduced in 2018, <a href="https://github.com/features/actions">GitHub Actions</a> is one of the newer tools in the CI/CD tech stack. It is fully integrated within GitHub, making it manageable from a single place.</p>
<p>Integration with GitHub means you can build, test, and deploy code directly from your GitHub repository. GitHub manages the execution and provides feedback and security for the entire CI process.</p>
<p>GitHub Actions offers a wide range of automation tasks and actions that allow you to create, share, reuse, and branch software development workflows directly in your GitHub repository. It also supports Docker for multi-container testing and offers several CI templates.</p>
<ul>
<li><strong>Where is it hosted?</strong> Self-hosted; cloud</li>
<li><strong>What platform does it run?</strong> Container; virtual machine</li>
<li><strong>What is its pricing model?</strong> Free for public repositories and self-hosted runners. For private repositories, build minutes/month depend on account type and spending limits</li>
</ul>
<figure>
<img src="/blog/assets/images/continuous-integration/Gu0ruur.png" title="GitHub Actions CI/CD tool" alt="GitHub Actions CI/CD tool" /><figcaption aria-hidden="true">GitHub Actions CI/CD tool</figcaption>
</figure>
<h3 id="azure-devops">Azure DevOps</h3>
<p><a href="https://azure.microsoft.com/en-us/services/devops/">Azure DevOps</a> by Microsoft is a platform for creating a CI/CD pipeline to Azure. It provides several advanced features and services that support the software development cycle from planning to deployment. Azure DevOps integrates with both Team Foundation Version Control and Git for version control, code repository management, and build automation.</p>
<p>Azure DevOps also integrates with major languages and platforms, allowing you to build, test and deploy in Java, .Net, Android, or iOS. It also runs parallel on Linux, macOS, and Windows and on both virtual machines and containers.</p>
<p>One standout feature of Azure DevOps is that it supports automated load testing, which can simulate thousands of users using your app at the same time. This helps your developers uncover bottlenecks and improve throughput before an application is released.</p>
<ul>
<li><strong>Where is it hosted?</strong> Self-hosted; cloud</li>
<li><strong>What platform does it run?</strong> Container; virtual machine</li>
<li><strong>What is its pricing model?</strong> Free up to a specific number of builds, but build servers can be reserved at a cost for higher volumes</li>
</ul>
<figure>
<img src="/blog/assets/images/continuous-integration/iIfItCx.png" title="Azure DevOps CI/CD Tool" alt="Azure DevOps CI/CD Tool" /><figcaption aria-hidden="true">Azure DevOps CI/CD Tool</figcaption>
</figure>
<h2 id="continuous-integration-best-practices">Continuous Integration Best Practices</h2>
<p>To get the most out of your CI process, you’ll need to set it up with the following best practices: consistency between environments, disciplined use of the CI/CD pipeline (no sidestepping it for special cases), prioritizing tests by speed, and the “Build Once” practice.</p>
<h3 id="strive-for-consistency-between-environments">Strive for Consistency Between Environments</h3>
<p>We’ve all had it happen: code that works perfectly in your development environment throws a hissy fit in production.</p>
<p>Your CI environment should either match production exactly or be customized in a way that mitigates any bugs that might happen due to the difference in the two environments. The wider the difference between your development or staging and production environments, the less accurate your tests will be in showing how the code will perform in the real world.</p>
<p>A few ways to make sure that your environments are consistent are as follows:</p>
<ul>
<li>Using <a href="https://www.redhat.com/en/topics/devops/what-is-blue-green-deployment">blue-green deployments</a>. This release strategy involves running two parallel versions of the production environment and involves using a load balancer to swap production traffic between two environments alternately designated as production (green) and staging (blue).</li>
<li>Deploy a scaled-down version of your production environment to your development or staging environment. If you’re using this method, ensure that the code is consistent and that differences between the two environments are well-documented.</li>
<li>Use a clone of the production environment to make sure that your CI environment is an exact match.</li>
</ul>
<h3 id="all-deployments-must-go-through-ci">All Deployments Must Go Through CI</h3>
<p>CI acts as a watchman to enforce best practices in the development process and ensure that changes are in line with your company’s standards and procedures. A failure during integration is flagged immediately and prevents the affected code from moving forward into other parts of the development process. This protects subsequent environments like production from untrusted or error-prone code.</p>
<p>For CI to be successful, you’ll need to make sure that the CI/CD pipeline is the only mechanism through which code enters your production environment. This could be via continuous delivery with manual approval processes and batched releases or through automated continuous deployment practices.</p>
<p>Development teams may feel pressured to make exceptions and circumvent the CI process when problems arise. It’s tempting to bypass the system to mitigate excessive downtime and fix other issues as soon as possible, but adhering to the CI/CD pipeline helps ensure that the changes being made won’t worsen the current problem or introduce new ones.</p>
<p>Sending all changes through the CI/CD pipeline helps to protect the integrity of your deployments and prevents ad hoc fixes from being erased by subsequent updates.</p>
<h3 id="run-your-fastest-testschecks-first">Run Your Fastest Tests/Checks First</h3>
<p>The general goal of the CI/CD process is to provide rapid feedback to developers and promote rapid software delivery to users. You want to keep the entire pipeline fast, but the reality is that some parts will be faster than others. If developers have to wait too long to get feedback from testing, they might look for ways around the process.</p>
<p>Because you want to discover failures as early as possible, prioritize and run the tests that complete quickest first and leave longer running tests until later.</p>
<p>This usually means running your unit tests first, as those are faster, make up most of your tests, and can give you immediate feedback on bugs and errors introduced by the latest update. After unit testing is complete, run integration tests next to see how different parts of your code interact. Then follow up with system-wide tests such as GUI, performance, load and security tests, and manual acceptance tests.</p>
<h3 id="build-only-once-and-promote-the-result-through-the-pipeline">Build Only Once and Promote the Result Through the Pipeline</h3>
<p>One aim of CI/CD is to ensure that your end product is robust and won’t produce unexpected results. This is why it’s important to perform your build step only once and then advance resulting binaries through the entire pipeline. Software builds that occur separately at each new stage of the pipeline can introduce inconsistencies, and tests completed in earlier environments become invalid because they may not be targeting the same software that is eventually deployed.</p>
<p>In the “Build Once” best practice, the build process always occurs as the first step in the pipeline, and the resulting artifact is versioned and uploaded to the central repository where it can be pulled and used in the later stages. This ensures that the build does not change as it moves through the pipeline.</p>
<h2 id="whats-next">What’s Next?</h2>
<p>Continuous integration speeds up the software development process and helps development teams avoid common pitfalls such as broken application builds, and chaotic release cycles. Rather than catching issues just before (or even after) they’re released, continuous integration allows you to mitigate errors <em>while</em> you’re working on a feature.</p>
<p><a href="https://earthly.dev/">Earthly</a> is a free and open-source build automation tool that works with your existing build systems to create repeatable, containerized, language-agnostic builds. It acts as a layer between language-specific tools such as Gradle and Apache Maven and the CI buildspec and allows for faster iteration on build scripts and easier debugging. You can discuss automation and other topics in the <a href="https://earthly.dev/slack">Earthly Community on Slack</a>.</p>
<p>To find out more about how Earthly can help you simplify your CI systems, check us out on <a href="https://github.com/earthly/earthly" title="Earthly build automation tool documentation and download">GitHub</a>. With CI automation in place, developers can push changes more frequently, get faster feedback, and ensure that every change is integrated, tested, and verified.</p>

        
      </section>

      


<div itemscope itemtype="https://schema.org/Person">
  <!-- <h5>About The Author</h5> -->

  
    <div class="author__avatar">
      
        <picture class="image-author"><source srcset="/blog/generated/assets/images/authors/deborahruck-240-5d060f805.webp 240w" type="image/webp"><source srcset="/blog/generated/assets/images/authors/deborahruck-240-5cea5d792.jpg 240w" type="image/jpeg"><img src="/blog/generated/assets/images/authors/deborahruck-240-5cea5d792.jpg" alt="Deborah Ruck %"></picture>

      
    </div>
  

  <div class="author__content">
    
      <h4 class="author__name" itemprop="name">
        Deborah Ruck
    
    
    </h4>
    
      <div class="author__bio" itemprop="description">
        <p>Deborah Ruck is a software developer turned freelance writer. She enjoys using her two decades of experience to create engaging, well-researched, educational content. When she’s not working, you can find her learning something new or just relaxing at home on the sunny island of Barbados. Connect with her on her <a href="https://deborahruck.com/%20“Deborah%20Ruck’s%20website”">website</a> or on <a href="http://www.linkedin.com/in/deborah-ruck-44105623%20“Deborah%20Ruck’s%20LinkedIn%20profile”">LinkedIn</a>.</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <!-- <button class="btn btn--inverse">Follow</button> -->
    <ul class="author__urls social-icons">
      

     

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

      <footer class="page__meta">
        
        



  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/blog/categories/articles" class="page__taxonomy-item" rel="tag">Articles</a>
    
    </span>
  </p>



        
  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2021-05-17T00:00:00-04:00">May 17, 2021</time></p>


      </footer>

      

      
  <nav class="pagination">
    
      <a href="/blog/dos-gaming-in-docker/" class="pagination--pager" title="DOS Gaming In Docker
">Previous</a>
    
    
      <a href="/blog/repeatable-builds-every-time/" class="pagination--pager" title="Getting a Repeatable Build, Every Time
">Next</a>
    
  </nav>

    </div>
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">You may also enjoy</h4>
      <div class="grid__wrapper">
        
          










<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
      <div class="archive__item-teaser">
        <picture><source srcset="/blog/generated/assets/images/video-camera-on/header-600-739475018.webp 600w, /blog/generated/assets/images/video-camera-on/header-800-739475018.webp 800w" type="image/webp"><source srcset="/blog/generated/assets/images/video-camera-on/header-600-5573f622c.jpg 600w, /blog/generated/assets/images/video-camera-on/header-800-5573f622c.jpg 800w" type="image/jpeg"><img src="/blog/generated/assets/images/video-camera-on/header-800-5573f622c.jpg"></picture>

      </div>
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/blog/video-camera-on/" rel="permalink">SQL Errors and Video Cameras
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          7 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">

Some years ago, when I worked in a physical office, I was having trouble with a new report I was developing. The reasonably complex SQL that generated the ...</p>
  </article>
</div>

        
          










<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
      <div class="archive__item-teaser">
        <picture><source srcset="/blog/generated/assets/images/markdown-lint/header-600-193822b16.webp 600w, /blog/generated/assets/images/markdown-lint/header-800-193822b16.webp 800w" type="image/webp"><source srcset="/blog/generated/assets/images/markdown-lint/header-600-490715c18.jpg 600w, /blog/generated/assets/images/markdown-lint/header-800-490715c18.jpg 800w" type="image/jpeg"><img src="/blog/generated/assets/images/markdown-lint/header-800-490715c18.jpg"></picture>

      </div>
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/blog/markdown-lint/" rel="permalink">Linting Markdown And Documentation
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          9 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">
Many linting, code formatting, and static analysis tools exist for code. You can use eslint, gofmt, or many other static analysis tools, combined with a gre...</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
          <li><a href="https://twitter.com/earthlytech" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
        
          <li><a href="https://github.com/earthly/earthly" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
      
    

    
      <li><a href="/blog/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2021 <a href="https://earthly.dev/">Earthly</a>. </div>

      </footer>
    </div>

    <script src="/blog/assets/js/vendor/jquery/jquery-3.5.1.js"></script>
<script src="/blog/assets/js/plugins/jquery.fitvids.js"></script>
<script src="/blog/assets/js/plugins/smooth-scroll.js"></script>
<script src="/blog/assets/js/plugins/gumshoe.js"></script>
<script src="/blog/assets/js/plugins/jquery.magnific-popup.js"></script>
<script src="/blog/assets/js/main.min.js"></script>

  <script> // minified version of https://earthly.dev/assets/js/analytics.js
    function setCookie(e,t,r){var i="";if(r){var o=new Date;o.setTime(o.getTime()+24*r*60*60*1e3),i="; expires="+o.toUTCString()}document.cookie=e+"="+(t||"")+i+"; path=/"}function getCookie(e){for(var t=e+"=",r=document.cookie.split(";"),i=0;i<r.length;i++){for(var o=r[i];" "==o.charAt(0);)o=o.substring(1,o.length);if(0==o.indexOf(t))return o.substring(t.length,o.length)}return null}function uuidv4(){return([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,e=>(e^crypto.getRandomValues(new Uint8Array(1))[0]&15>>e/4).toString(16))}function getAnalyticCookie(){cookieName="earthlyID";var e=getCookie(cookieName);return null==e&&(e=uuidv4()),setCookie(cookieName,e,36500),e}jQuery.ajax({type:"POST",url:"https://api.earthly.dev/analytics",data:JSON.stringify({key:"website",url:window.location.href,referrer:document.referrer,earthlyID:getAnalyticCookie()})});
</script>




  </body>
</html>
